<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>timezonenames</title>
<style>
</style>
</head>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=800">
	<title>pluralrules</title>
	<link rel="stylesheet" type="text/css" href="testindex.css">
	<script src="testglobals.js"></script>
	<script src="testgeneric.js"></script>
	<!-- custom -->
	<style>
		table {width: 780px;}
		hr {color: #dcdc8c}
	</style>
</head>
<body>

	<table>
	<tr><td><h2>TorZillaPrint</h2></td></tr>
	<tr><td class="blurb"><a class="return" href="../index.html">return to TZP index</a></td></tr>
	</table>

	<table id="tb4">
		<col width="30%"><col width="70%">
		<thead><tr><th colspan="2">
			<div class="nav-title">timeZoneName
			<div class="nav-up"><span class="c perf" id="perf"></span></div>
			</div>
		</th></tr></thead>
		<tr><td colspan="2" class="intro">
			<span class="no_color">Testing language results in timeZoneName</span>
		</td></tr>
		<tr>
			<td class="mono spaces" id="legend" style="text-align: left; vertical-align: top; color: #b3b3b3; font-size: 11px"></td>
			<td class="mono" style="text-align: left; vertical-align: top;">
				<span id="b0" class="btn4 btnfirst" onClick="run('0')">[ S ]</span>
				<span id="b1" class="btn4 btn" onClick="run('1')">[ L ]</span>
				<span id="b2" class="btn4 btn" onClick="run('2')">[ SO ]</span>
				<span id="b3" class="btn4 btn" onClick="run('3')">[ LO ]</span>
				<span id="b4" class="btn4 btn" onClick="run('4')">[ SG ]</span>
				<span id="b5" class="btn4 btn" onClick="run('5')">[ LG ]</span>
				<!--<span id="bALL" class="btn4 btn" onClick="run('ALL')">[ ALL ]</span>-->
				<span class="btn4 btn"><input type="checkbox" id="supported" style="margin: 0; height: 12px"> supported [dtf]</span>
			<br><br><hr><br>
				<span id ="results"></span>
			</td></tr>
	</table>
	<br>

<script>
'use strict';

var list = [
"aa,afar",
"ab,abkhazian",
"ach,acholi",
"ae,avestan",
"af,afrikaans",
"ak,akan",
"am,amharic",
"an,aragonese",
"ar,arabic",
"as,assamese",
"ast,asturian",
"av,avaric",
"ay,aymara",
"az,azerbaijani",
"ba,bashkir",
"be,belarusian",
"bg,bulgarian",
"bh,bihari",
"bi,bislama",
"bm,bambara",
"bn,bengali",
"bo,tibetan",
"br,breton",
"bs,bosnian",
"ca,catalan",
"cak,kaqchikel",
"ce,chechen",
"ch,chamorro",
"ckb,central kurdish",
"co,corsican",
"cr,cree",
"crh,crimean tatar",
"cs,czech",
"csb,kashubian",
"cu,church slavic",
"cv,chuvash",
"cy,welsh",
"da,danish",
"de,german",
"dsb,lower sorbian",
"dv,divehi",
"dz,dzongkha",
"ee,ewe",
"el,greek",
"en,english",
"eo,esperanto",
"es,spanish",
"et,estonian",
"eu,basque",
"fa,persian",
"ff,fulah",
"fi,finnish",
"fj,fijian",
"fo,faroese",
"fr,french",
"fur,friulian",
"fy,frisian",
"ga,irish",
"gd,scottish gaelic",
"gl,galician",
"gn,guarani",
"gu,gujarati",
"gv,manx",
"ha,hausa",
"haw,hawaiian",
"he,hebrew",
"hi,hindi",
"hil,hiligaynon",
"ho,hiri motu",
"hr,croatian",
"hsb,upper sorbian",
"ht,haitian",
"hu,hungarian",
"hy,armenian",
"hye,eastern armenian",
"hz,herero",
"ia,interlingua",
"id,indonesian",
"ie,interlingue",
"ig,igbo",
"ii,sichuan yi",
"ik,inupiaq",
"io,ido",
"is,icelandic",
"it,italian",
"iu,inuktitut",
"ja,japanese",
"jv,javanese",
"ka,georgian",
"kab,kabyle",
"kg,kongo",
"ki,kikuyu",
"kj,kuanyama",
"kk,kazakh",
"kl,greenlandic",
"km,khmer",
"kn,kannada",
"ko,korean",
"kok,konkani",
"kr,kanuri",
"ks,kashmiri",
"ku,kurdish",
"kv,komi",
"kw,cornish",
"ky,kirghiz",
"la,latin",
"lb,luxembourgish",
"lg,ganda",
"li,limburgan",
"lij,ligurian",
"ln,lingala",
"lo,lao",
"lt,lithuanian",
"ltg,latgalian",
"lu,luba-katanga",
"lv,latvian",
"mai,maithili",
"meh,sw tlaxiaco mixtec",
"mg,malagasy",
"mh,marshallese",
"mi,maori",
"mix,mixtepec mixtec",
"mk,macedonian",
"ml,malayalam",
"mn,mongolian",
"mr,marathi",
"ms,malay",
"mt,maltese",
"my,burmese",
"na,nauru",
"nb,norwegian bokmål",
"nd,ndebele north",
"ne,nepali",
"ng,ndonga",
"nl,dutch",
"nn,norwegian nynorsk",
"no,norwegian",
"nr,ndebele south",
"nso,sotho northern",
"nv,navajo",
"ny,chichewa",
"oc,occitan",
"oj,ojibwa",
"om,oromo",
"or,odia",
"os,ossetian",
"pa,punjabi",
"pi,pali",
"pl,polish",
"ps,pashto",
"pt,portuguese",
"qu,quechua",
"rm,rhaeto-romanic",
"rn,kirundi",
"ro,romanian",
"ru,russian",
"rw,kinyarwanda",
"sa,sanskrit",
"sat,santali", // 1731528
"sc,sardinian",
"sco,scots", // 1714293
"sd,sindhi",
"se,northern sami",
"sg,sango",
"si,sinhala",
"sk,slovak",
"sl,slovenian",
"sm,samoan",
"sn,shona",
"so,somali",
"son,songhay",
"sq,albanian",
"sr,serbian",
"ss,siswati",
"st,sotho southern",
"su,sundanese",
"sv,swedish",
"sw,swahili",
"szl,silesian", // 1691695
"ta,tamil",
"te,telugu",
"tg,tajik",
"th,thai",
"ti,tigrinya",
"tig,tigre",
"tk,turkmen",
"tl,tagalog",
"tlh,klingon",
"tn,tswana",
"to,tonga",
"tr,turkish",
"trs,triqui", // 1583177
"ts,tsonga",
"tt,tatar",
"tw,twi",
"ty,tahitian",
"ug,uighur",
"uk,ukrainian",
"ur,urdu",
"uz,uzbek",
"ve,venda",
"vi,vietnamese",
"vo,volapük",
"wa,walloon",
"wen,sorbian",
"wo,wolof",
"xh,xhosa",
"yi,yiddish",
"yo,yoruba",
"za,zhuang",
"zam,miahuatlán zapotec",
"zh,chinese",
"zh-cn,chinese china",
"zh-Hans,chinese simple",
"zh-Hant,chinese traditional",
"zh-hk,chinese hong kong",
"zh-sg,chinese singapore",
"zh-tw,chinese taiwan",
"zu,zulu",
]

var aLegend = [],
	aLegendSupported = [],
	aLocales = [],
	aSupported = [],
	useSupportedOnly = true

s4 = s4.trim()
s12 = s12.trim()
s14 = s14.trim()
s16 = s16.trim()
sg = sg.trim()
sb = sb.trim()

function legend() {
	// build once: legend, locales, supportedlocales
	if (aLegend.length == 0) {
		list.sort()
		for (let i = 0 ; i < list.length; i++) {
			let str = list[i].toLowerCase()
			let code = str.split(",")[0].trim()
			let name = str.split(",")[1].trim()
			aLocales.push(code)
			let test = Intl.DateTimeFormat.supportedLocalesOf([code])
			if (test.length) {
				aSupported.push(code)
				aLegendSupported.push(code.padStart(7) +": "+ name)
			}
			aLegend.push(code.padStart(7) +": "+ name)
		}
	}
	// output
	useSupportedOnly = dom.supported.checked
	let aDisplay = aLegend
	if (useSupportedOnly) {aDisplay = aLegendSupported}
	let	header = s4 +"   LEGEND ["+ aDisplay.length
		+ (useSupportedOnly ? " supported" : "") +"]"+ sc +"<br><br>"
	dom.legend.innerHTML = header + aDisplay.join("<br>")
}

function run_main(type) {
	let t0 = performance.now()
	let data = []
	let tzUnknown = []
	let tzTZN = []

	let tzNames = ["short","long","shortOffset","longOffset","shortGeneric","longGeneric"]
	let tzDays = [Date.UTC(2019, 1, 1, 13, 0, 0), Date.UTC(2019, 7, 1, 0, 0, 0)]
	let spacer = "<br><br>"
	
	if (type !== "ALL") {
		let tmp = tzNames[type]
		tzNames = [tmp]
	}

	function getTZNames(code) {
		// note: use hour12 - https://bugzilla.mozilla.org/show_bug.cgi?id=1645115#c9
		let tzRes = []
		try {
			tzDays.forEach(function(day) {
				tzNames.forEach(function(name) {
					let tz = ""
					let tzDate = new Date(day)
					try {
						let tzFormatter = Intl.DateTimeFormat(code, {hour12: true, timeZoneName: name})
						let tzDateString = tzFormatter.formatToParts(day).map(({type, value}) => {
							// FF91: extended TZNs are type "unknown"
							if (type == "timeZoneName" || type == "unknown") {
								tz = value
							}
							if (type == "timeZoneName") {tzTZN.push(code +": "+ type + " :"+ value)}
							if (type == "unknown") {tzUnknown.push(code +": "+ type + " :"+ value)}
							return type +":"+ value
						})
						//console.debug(tzDateString, code)
					} catch(e) {
						tz = (e.name == "RangeError" ? zNS : zB0)
					}
					if (tz !== zNS) {tzRes.push(tz)}
				})
			})
			return tzRes.join(", ")
		} catch(e) {
			return zB0
		}
	}

	useSupportedOnly = dom.supported.checked
	let loop = useSupportedOnly ? aSupported : aLocales
	try {
		// get data
		loop.forEach(function(code) {
			let res = getTZNames(code)
			if (res.length > 0) {
				data.push(sha1(res) +":"+ code +":" + res)
			}
		})

		if (data.length) {
			// if supported only, also add undefined
			if (useSupportedOnly) {
				let res = getTZNames(undefined)
				data.push(sha1(res) +":undefined:" + res)
			}
			// check types: FF91 extended timezonenames are type unknown
			//if (tzUnknown.length) {console.debug("type: unknown\n", tzUnknown)}
			//if (tzTZN.length) {console.debug("type: timeZoneName\n", tzTZN)}

			// get one line per hash
			data.sort()
			let next = "", codes = []
			let aHash = [], aBucketsR = [], aBucketsC = []
			for (let i = 0 ; i < data.length; i++) {
				// get current item
				let parts = data[i].split(":")
				let tmpH = parts[0]
				let tmpL = parts[1]
				let tmpR = parts.slice(2, parts.length).join(":")
				codes.push(tmpL)
				// grab next item
				if (i < data.length - 1) {
					next = data[(i+1)].substring(0,40)
				} else {
					next = "end"
				}
				// build new item
				if (next !== tmpH) {
					aBucketsR.push(tmpR) // hash of results
					aBucketsC.push(codes.join()) // hash of locale groups
					let str = s12 + tmpH + sc + s4 + " ["+ codes.length +"]"+ sc
						+ "<br><ul><li>" + s16 +"R: "+ sc + tmpR +"</li>"
						+ "<li>"+ s12 +"L: "+ sc + codes.join(", ") + "</li></ul>"
					aHash.push(str)
					codes = [] // reset
				}
			}
			// buckets
			aBucketsR.sort()
			aBucketsC.sort()
			if (type !== "ALL") {
				type = tzNames[0]
				dom.results.innerHTML = s4 + type.toUpperCase() +" ["+ aHash.length
					+ (useSupportedOnly ? sc +" from "+ s4 + loop.length +" supported"+ sc +" + undefined"+ s4 : "")
					+"]"+ sc	+ spacer
					+ s16 +"results: "+ sc + sha1(aBucketsR.join()) +"<br>"
					+ s12 +"locales: "+ sc + sha1(aBucketsC.join()) + spacer
					+ aHash.join("<br>")
			}
		} else {
			if (type !== "ALL") {
				type = tzNames[0]
				dom.results.innerHTML = s4 + type.toUpperCase() + sc + spacer + "not supported"
			}
		}
		
		// perf
		dom.perf.innerHTML = Math.round(performance.now() - t0) +" ms"

	} catch(e) {
		dom.results.innerHTML = "<br>"+ s4 + e.name +": "+ sc + e.message
	}
}

function run(type) {
	//reset
	dom.results.innerHTML = "<br>running test..."
	dom.perf = ""
	legend()
	setBtn(type)
	// delay so users see change and allow paint
	setTimeout(function() {
		if (type == "ALL") {
			dom.results.innerHTML = "<br>not coming soon... it's too slow"
		} else {
			run_main(type * 1)
		}
	}, 1)
}

function setBtn(type) {
	// reset btns
	let items = document.getElementsByClassName("btn8")
	for (let i=0; i < items.length; i++) {
		items[i].classList.add("btn4")
		items[i].classList.remove("btn8")
	}
	// set btn
	let el = document.getElementById("b"+ type)
	el.classList.add("btn8")
	el.classList.remove("btn4")
}

dom.supported.checked = true
legend()

</script>
</body>
</html>
