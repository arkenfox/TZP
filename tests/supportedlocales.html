<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>supportedlocalesof</title>
<style>
</style>
</head>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=800">
	<title>pluralrules</title>
	<link rel="stylesheet" type="text/css" href="testindex.css">
	<script src="testglobals.js"></script>
	<script src="testgeneric.js"></script>
	<!-- custom -->
	<style>
		table {width: 780px;}
		hr {color: #dcdc8c}
	</style>
</head>
<body>

	<table>
	<tr><td><h2>TorZillaPrint</h2></td></tr>
	<tr><td class="blurb"><a class="return" href="../index.html">return to TZP index</a></td></tr>
	</table>

	<table id="tb4">
		<col width="30%"><col width="70%">
		<thead><tr><th colspan="2">
			<div class="nav-title">supportedlocalesof
			<div class="nav-up"><span class="c perf" id="perf"></span></div>
			</div>
		</th></tr></thead>
		<tr><td colspan="2" class="intro">
			<span class="no_color">Return supported locales, including mappings and duplicates, for each given Intl constructor</span>
		</td></tr>
		<tr>
			<td class="mono spaces" id="legend" style="text-align: left; vertical-align: top; color: #b3b3b3; font-size: 11px"></td>
			<td class="mono" style="text-align: left; vertical-align: top;">
				<span id="bC" class="btn4 btnfirst" onClick="run('C')">[ C ]</span>
				<span id="bDTF" class="btn4 btn" onClick="run('DTF')">[DTF]</span>
				<span id="bDN" class="btn4 btn" onClick="run('DN')">[ DN ]</span>
				<span id="bLF" class="btn4 btn" onClick="run('LF')">[ LF ]</span>
				<!--<span id="bLI" class="btn4 btn" onClick="run('LI')">[LI]</span>-->
				<span id="bNF" class="btn4 btn" onClick="run('NF')">[ NF ]</span>
				<span id="bPR" class="btn4 btn" onClick="run('PR')">[ PR ]</span>
				<span id="bRTF" class="btn4 btn" onClick="run('RTF')">[RTF]</span>
				<span id="bS" class="btn4 btn" onClick="run('S')">[ S ]</span>
				<span id="bALL" class="btn4 btn" onClick="run('ALL')">[ALL]</span>
				<br><br><hr><br>
				<span id ="results"></span>
			</td></tr>
	</table>
	<br>

<script>
'use strict';

var list = [
"aa,afar",
"ab,abkhazian",
"ach,acholi",
"ae,avestan",
"af,afrikaans",
"ak,akan",
"am,amharic",
"an,aragonese",
"ar,arabic",
"ar-bh, arabic (bahrain)",
"ar-dz, arabic (algeria)",
"ar-eg, arabic (egypt)",
"ar-iq, arabic (iran)",
"ar-jo, arabic (jordan)",
"ar-kw, arabic (kuwait)",
"ar-lb, arabic (lenanon)",
"ar-ly, arabic (lybia)",
"ar-mo, arabic (morocco)",
"ar-om, arabic (oman)",
"ar-qa, arabic (qatar)",
"ar-sa, arabic (saudi arabia)",
"ar-sy, arabic (syria)",
"ar-tn, arabic (tunisia)",
"ar-ae, arabic (uae)",
"ar-ye, arabic (yemen)",
"as,assamese",
"ast,asturian",
"av,avaric",
"ay,aymara",
"az,azerbaijani",
"ba,bashkir",
"be,belarusian",
"bg,bulgarian",
"bh,bihari",
"bho,bhojpuri",
"bi,bislama",
"bm,bambara",
"bn,bengali",
"bo,tibetan",
"br,breton",
"bs,bosnian",
"ca,catalan",
"ca-valencia, catalan (valencia)",
"cak,kaqchikel",
"ce,chechen",
"ch,chamorro",
"ckb,central kurdish",
"co,corsican",
"cr,cree",
"crh,crimean tatar",
"cs,czech",
"csb,kashubian",
"cu,church slavic",
"cv,chuvash",
"cy,welsh",
"da,danish",
"de,german",
"de-at,german (austria)",
"de-ch,german (switzerland)",
"de-de,german (germany)",
"de-li,german (liechtenstein)",
"de-lu,german (luxembourg)",
"dsb,lower sorbian",
"dv,divehi",
"dz,dzongkha",
"ee,ewe",
"el,greek",
"en,english",
"en-au,english (australia)",
"en-be,english (belize)",
"en-ca,english (canada)",
"en-ie,english (ireland)",
"en-jm,english (jamaica)",
"en-nz,english (new zealand)",
"en-ph,english (philippines)",
"en-za,english (south africa)",
"en-tt,english (trinidad and tobago)",
"en-gb,english (united kingdom)",
"en-us,english (united states)",
"en-zw,english (zimbabwe)",
"eo,esperanto",
"es,spanish",
"es-ar,spanish (argentina)",
"es-bo,spanish (bolivia)",
"es-cl,spanish (chile)",
"es-co,spanish (colombia)",
"es-cr,spanish (costa rica)",
"es-do,spanish (dominican republic)",
"es-ec,spanish (ecuador)",
"es-es,spanish (spain)",
"es-gt,spanish (guatemala)",
"es-hn,spanish (honduras)",
"es-mx,spanish (mexico)",
"es-ni,spanish (nicaragua)",
"es-pa,spanish (panama)",
"es-py,spanish (paraguay)",
"es-pe,spanish (peru)",
"es-pr,spanish (puerto rico)",
"es-sv,spanish (el salvador)",
"es-uy,spanish (uruguay)",
"es-ve,spanish (venezuela)",
"et,estonian",
"eu,basque",
"fa,persian",
"fa-ir,persian (iran)",
"ff,fulah",
"fi,finnish",
"fil,filipino",
"fj,fijian",
"fo,faroese",
"fr,french",
"fr-be,french (belgium)",
"fr-ca,french (canada)",
"fr-fr,french (france)",
"fr-lu,french (luxembourg)",
"fr-mc,french (monaco)",
"fr-ch,french (switzerland)",
"fur,friulian",
"fy,frisian",
"ga,irish",
"gd,scottish gaelic",
"gl,galician",
"gn,guarani",
"gu,gujarati",
"gv,manx",
"ha,hausa",
"haw,hawaiian",
"he,hebrew",
"hi,hindi",
"hil,hiligaynon",
"ho,hiri motu",
"hr,croatian",
"hsb,upper sorbian",
"ht,haitian",
"hu,hungarian",
"hy,armenian",
"hye,eastern armenian",
"hz,herero",
"ia,interlingua",
"id,indonesian",
"ie,interlingue",
"ig,igbo",
"ii,sichuan yi",
"ik,inupiaq",
"io,ido",
"is,icelandic",
"it,italian",
"it-ch,italian (switzerland)",
"iu,inuktitut",
"ja,japanese",
"jv,javanese",
"ka,georgian",
"kab,kabyle",
"kg,kongo",
"ki,kikuyu",
"kj,kuanyama",
"kk,kazakh",
"kl,greenlandic",
"km,khmer",
"kn,kannada",
"ko,korean",
"ko-kp,korean (north korea)",
"ko-kr,korean (south korea)",
"kok,konkani",
"kr,kanuri",
"ks,kashmiri",
"ku,kurdish",
"kv,komi",
"kw,cornish",
"ky,kirghiz",
"la,latin",
"lb,luxembourgish",
"lg,ganda",
"li,limburgan",
"lij,ligurian",
"ln,lingala",
"lo,lao",
"lt,lithuanian",
"ltg,latgalian",
"lu,luba-katanga",
"lv,latvian",
"mai,maithili",
"meh,southwestern tlaxiaco mixtec",
"mg,malagasy",
"mh,marshallese",
"mi,maori",
"mix,mixtepec mixtec",
"mk,macedonian",
"mk-mk,macedonian (north macedonia)",
"ml,malayalam",
"mn,mongolian",
"mr,marathi",
"ms,malay",
"mt,maltese",
"my,burmese",
"na,nauru",
"nb,norwegian bokmål",
"nd,ndebele north",
"ne,nepali",
"ng,ndonga",
"nl,dutch",
"nl-be,dutch (belgium)",
"nn,norwegian nynorsk",
"no,norwegian",
"nr,ndebele south",
"nso,sotho northern",
"nv,navajo",
"ny,chichewa",
"oc,occitan",
"oj,ojibwa",
"om,oromo",
"or,odia",
"os,ossetian",
"pa,punjabi",
"pa-in,punjabi (india)",
"pa-pk,punjabi (pakistan)",
"pi,pali",
"pl,polish",
"ps,pashto",
"pt,portuguese",
"pt-br,portuguese (brazil)",
"pt-pt,portuguese (portugal)",
"qu,quechua",
"rm,rhaeto-romanic",
"rn,kirundi",
"ro,romanian",
"ro-md,romanian (moldova)",
"ro-ro,romanian (romania)",
"ru,russian",
"ru-md,russian (moldova)",
"rw,kinyarwanda",
"sa,sanskrit",
"sat,santali", // 1731528
"sc,sardinian",
"sco,scots", // 1714293
"sd,sindhi",
"se,northern sami",
"sg,sango",
"si,sinhala",
"sk,slovak",
"sl,slovenian",
"sm,samoan",
"sn,shona",
"so,somali",
"son,songhay",
"son-ml,songhay (mali)",
"sq,albanian",
"sr,serbian",
"ss,siswati",
"st,sotho southern",
"su,sundanese",
"sv,swedish",
"sv-fi,swedish (finland)",
"sv-se,swedish (sweden)",
"sw,swahili",
"szl,silesian", // 1691695
"ta,tamil",
"te,telugu",
"tg,tajik",
"th,thai",
"ti,tigrinya",
"tig,tigre",
"tk,turkmen",
"tl,tagalog",
"tlh,klingon",
"tn,tswana",
"to,tonga",
"tr,turkish",
"trs,triqui", // 1583177
"ts,tsonga",
"tt,tatar",
"tw,twi",
"ty,tahitian",
"ug,uighur",
"uk,ukrainian",
"ur,urdu",
"uz,uzbek",
"ve,venda",
"vi,vietnamese",
"vo,volapük",
"wa,walloon",
"wen,sorbian",
"wo,wolof",
"xh,xhosa",
"yi,yiddish",
"yo,yoruba",
"za,zhuang",
"zam,miahuatlán zapotec",
"zh,chinese",
"zh-cn,chinese (china)",
"zh-Hans,chinese (simple)",
"zh-Hant,chinese (traditional)",
"zh-hk,chinese (hong kong)",
"zh-sg,chinese (singapore)",
"zh-tw,chinese (taiwan)",
"zu,zulu",
]

var aLegend = [],
	aLocales = [],
	aSummary = []

s4 = s4.trim()
s12 = s12.trim()
s14 = s14.trim()
s16 = s16.trim()
sg = sg.trim()
sb = sb.trim()

function legend() {
	// build once
	if (aLegend.length == 0) {
		list.sort()
		for (let i = 0 ; i < list.length; i++) {
			let str = list[i].toLowerCase()
			let code = str.split(",")[0].trim()
			let name = str.split(",")[1].trim()
			aLocales.push(code)
			aLegend.push(code.padStart(7) +": "+ name)
		}
	}
	// output
	dom.legend.innerHTML = s4 +"   LEGEND ["+ aLegend.length +"]"+ sc +"<br><br>"+ aLegend.join("<br>")
}

function run_main(method, isLoopy) {
	let t0 = performance.now()
	let legend = [], data = [], map = [], nocase = [], nocasemap = [], all = []
	let spacer = "<br><br>", hashLookup = "", lookupSummary = ""
	let display = []

	function getPretty(method) {
		let pretty = ""
		if (method == "C") {pretty = "collator"
		} else if (method == "DTF") {pretty = "datetimeformat"
		} else if (method == "DN") {pretty = "displaynames"
		} else if (method == "LF") {pretty = "listformat"
		} else if (method == "LI") {pretty = "localeinfo"
		} else if (method == "NF") {pretty = "numberformat"
		} else if (method == "PR") {pretty = "pluralrules"
		} else if (method == "RTF") {pretty = "relativetimeformat"
		} else if (method == "S") {pretty = "segmenter"
		}
		return pretty
	}

	try {
		// hash
		function getNotation(hash, method) {
			let notation = ""
			if (method == "C") {
				if (hash == "7ceb94a6") {notation = " [FF91+]"
				} else if (hash == "07163e7d") {notation = " [FF78-90]" // 186
				} else if (hash == "7c5535e9") {notation = " [FF70-77]" // 185
				} else if (hash == "0822ee11") {notation = " [FF65-69]" // 182
				} else if (hash == "7d1d5e24") {notation = " [FF59-64]" // 179
				} else if (hash == "668af03e") {notation = " [FF52-58]" // 178
				} else if (isFF) { notation = zNEW
				}
			} else {
				if (hash == "e73fc2d6") {notation = " [FF96+]" // 152
				} else if (hash == "a73b6346") {notation = " [FF91-95]" // 
				} else if (hash == "51ddc587") { // 225
				 if (method == "DN") {
						notation = " [FF86-90]"
				} else {
					notation = " [FF78-90]"
				}
				} else if (hash == "c565d90c") {notation = " [FF70-77]" // 222
				} else if (hash == "01f03482") {notation = " [FF65-69]" // 218
				} else if (hash == "0d5e02cc") {notation = " [FF59-64]" // 211
				} else if (hash == "8fd5b0f1") {notation = " [FF52-58]" // 208
				} else if (isFF) { notation = zNEW
				}
			}
			if (notation !== zNEW) notation = s12 + notation + sc
			return notation
		}
		// get data
		function getSupported(type, method) {
			data = []
			map = []
			all = []
			for (let i = 0 ; i < list.length; i++) {
				// split: code, name
				let code = list[i].split(",")[0]
				let name = list[i].split(",")[1]
				// test
				let test = ""
				if (method == "C") {
					test = Intl.Collator.supportedLocalesOf([code], {localeMatcher: type})
				} else if (method == "DTF") {
					test = Intl.DateTimeFormat.supportedLocalesOf([code], {localeMatcher: type})
				} else if (method == "DN") {
					test = Intl.DisplayNames.supportedLocalesOf([code], {localeMatcher: type})
				} else if (method == "LF") {
					test = Intl.ListFormat.supportedLocalesOf([code], {localeMatcher: type})
				} else if (method == "LI") {
					test = Intl.LocaleInfo.supportedLocalesOf([code], {localeMatcher: type})
				} else if (method == "NF") {
					test = Intl.NumberFormat.supportedLocalesOf([code], {localeMatcher: type})
				} else if (method == "PR") {
					test = Intl.PluralRules.supportedLocalesOf([code], {localeMatcher: type})
				} else if (method == "RTF") {
					test = Intl.RelativeTimeFormat.supportedLocalesOf([code], {localeMatcher: type})
				} else if (method == "S") {
					test = Intl.Segmenter.supportedLocalesOf([code], {localeMatcher: type})
				}
				if (test.length) {
					let found = test[0]
					all.push(found +":"+ code)
					if (type == "lookup") {
						nocase.push(found.toLowerCase())
						if (code.toLowerCase() !== found.toLowerCase()) {
							nocasemap.push(code)
						}
					}
					if (code.toLowerCase() !== found.toLowerCase()) {
						map.push(code +" -> "+ found)
						data.push(code +" -> "+ found)
					} else {
						data.push(found)
					}
				}
			}
			// don't sort or remove any dupes
			let hash = mini(data.join())

			// dupes
			all.sort()
			let dupes = [], dupesclean = [], tmpCodes = [], tmpCount = 0
			let nextItem = ""
			for (let i = 0 ; i < all.length; i++) {
				let a = all[i].split(":")[0] // found locale
				let b = all[i].split(":")[1] // tested code
				tmpCodes.push(b)
				if (i < all.length - 1) {
					nextItem = all[(i+1)].split(":")[0]
				} else {
					nextItem = "end"
				}
				if (nextItem !== a) {
					if (tmpCodes.length > 1) {
						dupes.push(s16 + a + sc + s4 +" ["+ tmpCodes.length +"] "+ sc + tmpCodes.join(", "))
						dupesclean.push(a)
					}
					tmpCodes = []
					tmpCount = 0
				}
			}
			// not in legend
			let notlist = [], notlistclean = [], map2 = []
			for (let i = 0 ; i < map.length; i++) {
				let x = map[i].split(" -> ")[0] // tested
				let y = map[i].split(" -> ")[1] // found
				if (!aLocales.includes(y)) {
					notlist.push(s12 + y + sc +" ["+ x +"]")
					notlistclean.push(y)
				}
				map2.push(s14 + x + sc + " -> "+ y)
			}
			// color up results
			if (!isLoopy) {
				for (let i = 0 ; i < data.length; i++) {
					let r = data[i]
					if (map.includes(r)) {
						let part1 = r.split(" -> ")[0],
							part2 = r.split(" -> ")[1]
						if (dupesclean.includes(part2)) {
							data[i] = s14 + part1 +" -> "+ sc + s16 + part2 + sc
						} else if (notlistclean.includes(part2)) {
							data[i] = s14 + part1 +" -> "+ sc + s12 + part2 + sc
						} else {
							data[i] = s14 + r + sc
						}
					} else {
						if (dupesclean.includes(r)) {
							data[i] = s16 + r + sc
						}
					}
				}
			}
			// output
			let str = ""
			if (type == "lookup") {hashLookup = hash}

			if (isLoopy) {
				// build summary
				if (type == "lookup") {
					lookupSummary = "<ul><li>" + hashLookup + s4 +" ["+ data.length +"]"+ sc + getNotation(hash, method) +"</li>"
					if (map2.length) {lookupSummary += "<li>"+ s14 +"MAPPED: "+ sc + map2.join(", ") +"</li>"}
					if (dupes.length) {lookupSummary += "<li>"+ s16 +"DUPES: "+ sc + dupes.join(", ") +"</li>"}
					if (notlist.length) {lookupSummary += "<li>"+ s12 +"NOT LISTED: "+ sc + notlist.join(", ") +"</li>"}					
					lookupSummary += "</ul>"
				} else {
					str = s4 + getPretty(method).toUpperCase() + sc
						+ (hash == hashLookup ? "" : sb +" [localeMatcher mismatch]"+ sc)
					str += "<br>" + lookupSummary
					aSummary.push(str)
				}
			} else {
				str = s4 + type.toUpperCase() + sc
				if (type == "lookup") {
					str = s4 + getPretty(method).toUpperCase() + sc + spacer + str + spacer
					str += sg + hash + sc + s4 +" ["+ data.length +"]"+ sc + getNotation(hash, method)
					// nocase used to color legend items
					nocase.sort()
					nocase = nocase.filter(function(item, position) {return nocase.indexOf(item) === position})
					nocasemap.sort()
					nocasemap = nocasemap.filter(function(item, position) {return nocasemap.indexOf(item) === position})
				} else {
					str = spacer + "<hr>" + "<br>" + str + spacer
					str += hash + s4 +" ["+ data.length +"]"+ sc + (hash == hashLookup ? sg : sb) +" [match]"+ sc
				}
				str += spacer + data.join(", ")
				if (map2.length) {str += spacer + s14 +"MAPPED"+ sc + spacer + map2.join("<br>")}
				if (dupes.length) {str += spacer + s16 +"DUPES"+ sc + spacer + dupes.join("<br>")}
				if (notlist.length) {str += spacer + s12 +"NOT LISTED"+ sc + spacer + notlist.join("<br>")}
				display.push(str)
			}
		}

		getSupported("lookup", method)
		getSupported("best fit", method)

		if (!isLoopy) {
			dom.results.innerHTML = display.join("<br>")
			// build + color legend
			for (let i = 0 ; i < list.length; i++) {
				// split: code, name
				let str = list[i].toLowerCase()
				let code = str.split(",")[0].trim()
				let name = str.split(",")[1].trim()
				if (nocase.includes(code.toLowerCase())) {
					legend.push(sg + code.padStart(7) +": "+ name + sc)
				} else {
					if (nocasemap.includes(code)) {
						legend.push(s14 + code.padStart(7) +": "+ name + sc)
					} else {
						legend.push(code.padStart(7) +": "+ name)
					}
				}
			}
			// display legend
			dom.legend.innerHTML = s4 +"   LEGEND ["+ legend.length +"]"+ sc +"<br><br>"+ legend.join("<br>")
			// perf
			dom.perf.innerHTML = Math.round(performance.now() - t0) +" ms"
		}
	} catch(e) {
		// catch unsupported
		let msg = e.message
		if (isFF) {msg = msg.replace("can't access property \"supportedLocalesOf\", ", "")} // trim *error_fix
		if (isLoopy) {
			let x = s4 + getPretty(method).toUpperCase() + sc
				+ "<ul><li>"+ e.name +": "+ msg +"</li></ul>"
			aSummary.push(x)
		} else {
			dom.results.innerHTML = "<br>"+ s4 + e.name +": "+ sc + msg
		}
	}
}

function run(method) {
	//reset
	legend()
	dom.results = ""
	dom.perf = ""
	setBtn(method)
	// delay so users see change and allow paint
	setTimeout(function() {
		if (method == "ALL") {
			run_all()
		} else {
			run_main(method, false)
		}
	}, 250)
}

function run_all() {
	let t0 = performance.now()
	aSummary = []
	run_main("C", true)
	run_main("DTF", true)
	run_main("DN", true)
	run_main("LF", true)
	//run_main("LI", true)
	run_main("NF", true)
	run_main("PR", true)
	run_main("RTF", true)
	run_main("S", true)
	dom.results.innerHTML = aSummary.join("<br>")
	let t1 = performance.now()
	dom.perf.innerHTML = Math.round(t1-t0) +"ms"
}

function setBtn(method) {
	// reset btns
	let items = document.getElementsByClassName("btn8")
	for (let i=0; i < items.length; i++) {
		items[i].classList.add("btn4")
		items[i].classList.remove("btn8")
	}
	// set btn
	let el = document.getElementById("b"+ method)
	el.classList.add("btn8")
	el.classList.remove("btn4")
}

legend()
Promise.all([
	get_globals()
]).then(function(){
	run("ALL")
})

</script>
</body>
</html>
