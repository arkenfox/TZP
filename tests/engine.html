<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=620">
	<title>engine</title>
	<link rel="stylesheet" type="text/css" href="testindex.css">
	<script src="testglobals.js"></script>
	<script src="testgeneric.js"></script>
	<!-- custom -->
	<style>
		table {width: 700px;}
		#tb3 td:first-child { text-align: left; vertical-align: top;}
		hr {color: #dcc18c}
	</style>
</head>

<body>
	<div class="offscreen">
		<div id="mozFont"></div>
		<div id="test95a" style="width: min-content; hyphens: auto; border: 1px solid red">2020-1</div>
		<div id="test95b" style="width: min-content; hyphens: auto; border: 1px solid red">2020-12020-1</div>
	</div>
	<div class="hidden">
		<div><input type="time" min="14:00:00" max="12:00:00" value="15:00:00" id="test76"></div>
		<span id="mozColor"></span>
	</div>

	<table>
	<tr><td><h2>TorZillaPrint</h2></td></tr>
	<tr><td class="blurb"><a class="return" href="../index.html">return to TZP index</a></td></tr>
	</table>

	<table id="tb3">
		<col width="50%"><col width="50%">
		<thead><tr><th colspan="2">engine</th></tr></thead>
		<tr><td colspan="2" class="intro">
			<span class="no_color">An itsy-bitsy, teeny-weeny, minuscule sample of the thousands of myriad ways engines differ.
			This test is tweaked for gecko [FF52+]: you want <span class="s9"><b> &#x2713 </b></span>'s. Anything different
			<span class="bad"><b> &#x2716 </b></span> or blocked <span class="s4"><b> &#x2715 </b></span> only makes you stand out.
			</span>
		</td></tr>
		<tr><td colspan="2"><hr></td></tr>
		<tr><td colspan="2"><span class="no_color c mono spaces" id="results"></span></td></tr>
	</table>
	<br>

<script>
'use strict';

s3 = s3.trim()
s14 = s14.trim()
s16 = s16.trim()
sb = sb.trim()
sg = sg.trim()

function fnRFP() {
	// detectable in FF56+
	let isPerf2 = true
	if (Math.trunc(performance.now() - performance.now()) !== 0) {isPerf2 = false}
	try {
		performance.mark("a")
		let r = performance.getEntriesByName("a","mark").length
			+ performance.getEntries().length
			+ performance.getEntries({name:"a",entryType:"mark"}).length
			+ performance.getEntriesByName("a","mark").length
			performance.clearMarks()
		isRFP56plus = (r == 0)
		if (!isPerf2) {isRFP56plus = false}
	} catch(e) {}
}

function fnTrim(str, len) {
	str = str.replace(/(\r\n|\n|\r)/gm,"")
	if (str.length > len) {str = str.slice(0,len-3) +"..."}
	return str
}

function fnClean(str) {
	if (str == "") {str = "empty string"
	} else if (str === undefined) {str = zU
	} else if (str == zU) {str = zUQ}
	return str
}

function fnDisplay() {
	// data -> ordered results
	const names = Object.keys(data).sort((a,b) => a-b)
	for (const k of names) {results.push(k +"~~~"+ data[k])}
	let display = [],
		errcount = 0
	let countTrue = 0, countFalse = 0, countBlock = 0, countNA = 0
	// check no numbers duplicated
	if (expected !== results.length) {
		display.push(sb+ "ERROR:"+ sc + " duplicate numbers detected<br>")
	}
	// parse for pretty output
	for (let i=0; i < results.length; i++) {
		let pad = 35
		let order = results[i].split("~~~")[0],
			desc = results[i].split("~~~")[1].trim(),
			result = results[i].split("~~~")[2],
			match = results[i].split("~~~")[3]
		if (desc == "header") {
			let note = ""
			if (result == "errors") {
				note = " [there are thousands of these]"
			}
			result = s14 + result.toUpperCase() + sc + note
			display.push("<span>"+ result + "</span><br>")
		} else if (desc == "hr") {
			display.push("<br><hr>")
		} else {
			if (match == zB0) {match = yellow_block; countBlock++
			} else if (match == "true") {match = green_tick; countTrue++
			} else if (match == "false") {match = red_cross; countFalse++
			} else {match = white_na; countNA++}
			match += " "
			if (desc == "error") {
				pad = 3; errcount++; desc = errcount.toString()
			}
			desc = s3 + desc.padStart(pad) + sc
			let sectionspace = ""
			if (i+1 < results.length) {
				let nextitem = results[i+1].split("~~~")[1].trim()
				if (nextitem == "header") {sectionspace = "<br>"}
			}
			if (bNum) {desc = desc + s16 +" "+ order + sc}
			display.push(desc + match +" "+ result + sectionspace)
		}
	}
	// summary
	let countValid = countTrue + countFalse + countBlock // na tests ignored
	let countFail = countFalse + countBlock
	let percentPassed = Math.floor((countTrue/countValid)*100)
	let isPass = percentPassed == 100 ? true : false
	let percentFailed = Math.ceil((countFail/countValid)*100)
	let summary = s14 +"SUMMARY "+ sc
		+"PASSED: ".padStart(9) + countTrue + (isPass? sg : sb) +" ["+ percentPassed +"%]"+ sc
		+"FAILED: ".padStart(9) + countFail + (isPass? sg : sb) +" ["+ percentFailed +"%]"+ sc
	if (countNA > 0) {summary += "N/A: ".padStart(7) + countNA}
	if (isFF) {
		summary += s14+ "DEBUG ".padStart(8) + sc +"RFP:".padStart(6) + (isRFP56plus ? green_tick : red_cross)
		let strVer = isVer
		strVer += (isVer == topVer ? "+" : "")
		strVer += (isVer == minVer ? " or lower" : "")
		summary += "VER: ".padStart(8) + strVer
	}
	// output
	dom.results.innerHTML = summary + "<br><br>" + display.join("<br>")
}

function fnRecord(order, description, result, match, error) {
	if (error !== undefined) {
		let ehash = sha1(error).substring(0,10)
		if (ehash !== "ffc0031b7a" && ehash !== "2772736bc6") {
			console.error(order, result, error)
		}
		result += s3+ " ["+ ehash +"]"+ sc
	}
	order = (order+"").padStart(3,"0")
	data[order] = description +"~~~"+ result +"~~~"+ match
	count ++
	itemnumbers.push(order +" "+ description)
	if (count == expected) {
		fnDisplay()
	}
	if (count > expected) {console.error(count, "expected count too low")}
}

function get_canvaskeys(num) {
	let strT = "[2d canvas] keys", testT = false
	try {
		if (bBlock) {bB = 1}
		let aMCanvas = []
		let aMCanvasGood = ['mozCurrentTransform', 'mozCurrentTransformInverse', 'mozImageSmoothingEnabled', 'mozTextStyle']
		for (const key in CanvasRenderingContext2D.prototype) {aMCanvas.push(key)}
		aMCanvas = aMCanvas.filter(x => aMCanvasGood.includes(x))
		aMCanvas.sort()
		let resT = "none"
		if (aMCanvas.length > 0) {
			resT = sha1(aMCanvas.join())
			if (resT == "f2821c307f0190b324b9eb1dd36da9e40aadc852") {
				testT = true
			} else if (isVer > 101) {
			// 1765063: FF102+: Disable mozCurrentTransform on early beta and earlier
				if (resT == "3edbfe7a636b1109796885e6b6dd221f9267b0b3") {testT = true}
			}
			resT += s3 +" ["+ aMCanvas.length +"]"+ sc
		}
		fnRecord(num, strT, resT, testT)
	} catch(e) {
		fnRecord(num, strT, e.name, zB0, e.message)
	}
}

function get_colorgamut(num, title) {
	let q = "(color-gamut: ", res = "undefined", bolC = false
	try {
		if (bBlock) {bB = 1}
		if (window.matchMedia(q +"srgb)").matches) {res = "srgb"}
		if (window.matchMedia(q +"p3)").matches) {res = "p3"}
		if (window.matchMedia(q +"rec2020)").matches) {res = "rec2020"}
		fnRecord(num, title, res, res == "undefined")
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_dates(num) {
	// 1274354: meta
	// 1557650
	let strA = "[5 digit year] new Date"
	try {
		if (bBlock) {bB = 1}
		let resA = new Date("19999-11-11")
		let bolA = resA == "Invalid Date" ? true : false
		if (!bolA) {resA = fnTrim(resA.toString(), 40)}
		fnRecord(num, strA, resA, bolA)
	} catch(e) {
		fnRecord(num, strA, e.name, zB0, e.message)
	}
	// 1515318
	let strB = "[hyphen] new Date"
	try {
		if (bBlock) {bB = 1}
		let resB = new Date("31-Mar-2011").getFullYear()
		// FF: 63 and lower = NaN, 64+ = -2011
		let bolB = false
		if (resB == -2011) {bolB = true
		} else if (isVer < 64 && isNaN(resB)) {bolB = true}
		fnRecord(num+1, strB, resB, bolB)
	} catch(e) {
		fnRecord(num+1, strB, e.name, zB0, e.message)
	}
	// 1439800
	let strC = "[string] new Data"
	try {
		if (bBlock) {bB = 1}
		let resC = new Date("11-Nov-11")
		let bolC = resC.toString() == "Invalid Date" ? true : false
		if (!bolC) {resC = fnTrim(resC.toString(), 40)}
		fnRecord(num+2, strC, resC, bolC)
	} catch(e) {
		fnRecord(num+2, strC, e.name, zB0, e.message)
	}
	// 1599375
	let strD = "[+0000 UTC] Date.parse"
	try {
		if (bBlock) {bB = 1}
		let resD = Date.parse("2019-11-26 07:39:58.286157072 +0000 UTC")
		let bolD = isNaN(resD) ? true : false
		fnRecord(num+3, strD, resD, bolD)
	} catch(e) {
		fnRecord(num+3, strD, e.name, zB0, e.message)
	}
	// 1730155
	let strE = "[localized] Date.parse"
	try {
		if (bBlock) {bB = 1}
		let resE = Date.parse("Mercredi 8 Septembre 2021")
		let bolE = isNaN(resE) ? true : false
		fnRecord(num+4, strE, resE, bolE)
	} catch(e) {
		fnRecord(num+4, strE, e.name, zB0, e.message)
	}
}

function get_doc_values(num, title) {
	let strFS = "[mozFullScreen] "+ title
	try {
		if (bBlock) {bB = 1}
		// FF expected true/false
		let boolFS = false
		let testFS = document.mozFullScreenEnabled
		if (testFS == true || testFS == false) {boolFS = true} else {fnClean(testFS)}
		fnRecord(num, strFS, testFS, boolFS)
	} catch(e) {
		fnRecord(num, strFS, e.name, zB0, e.message)
	}
}

function get_errors(num) {
	let tests = [
		["var a = {}; a.b = a; JSON.stringify(a)", "TypeError: cyclic object value"],
		["alert('A)","SyntaxError: '' string literal contains an unescaped line break"],
		["let a = 1_00_;","SyntaxError: underscore can appear only between digits, not after t...", // FF72+
			"SyntaxError: identifier starts immediately after numeric literal", // FF60-69
			"SyntaxError: missing digit after '_' numeric separator"], // FF70-71
		["const foo;foo.bar","SyntaxError: missing = in const declaration"],
		["null.bar","TypeError: can't access property \"bar\" of null","TypeError: null has no properties"],
		["(1).toString(1000)","RangeError: radix must be an integer at least 2 and no greater than 36"],
		["var x = new Array(-1)","RangeError: invalid array length"],
		["[...undefined].length","TypeError: can't access property Symbol.iterator of undefined","TypeError: undefined has no properties"],
		["const tzp=1; const tzp=2;","SyntaxError: redeclaration of const tzp"],
		["const foo;foo.bar","SyntaxError: missing = in const declaration"],
		["var x = @","SyntaxError: illegal character U+0040","SyntaxError: illegal character"],
	]
	tests.forEach(function(array) {
		try {
			newFn(array[0])
		} catch(e) {
			let bool = false
			let str = fnTrim(e.name +": "+ e.message, 70)
			if (isVer < 60 && array[0] == "alert('A)") {
				if (str == "SyntaxError: unterminated string literal") {bool = true}
			} else {
				if (str == array[1] || str == array[2] || str == array[3]) {bool = true}
			}
			fnRecord(num, "error", str, bool)
			num++
		}
	})
}

function get_eval_length(num, title) {
	let bool = false
	try {
		if (bBlock) {bB = 1}
		let test = eval.toString().length
		if (test == 37) {bool = true}
		fnRecord(num, title, test, bool)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_iframe_props(num1, num2, title) {
	// just a small sample
	let listE = ['dump','fullScreen','getDefaultComputedStyle','mozInnerScreenX',
		'mozInnerScreenY','netscape','onmozfullscreenchange','onmozfullscreenerror']
	let listU = ['BatteryManager','HID','Keyboard','Lock','Serial',
		'USB','WakeLock','WebKitMutationObserver','XRAnchor','chrome','webkitCancelAnimationFrame',
		'webkitMediaStream','webkitRTCPeerConnection','webkitRequestAnimationFrame',
		'webkitRequestFileSystem','webkitResolveLocalFileSystemURL','webkitStorageInfo']
	// FYI: don't use MIDIAccess: FF60+ behind dom.webmidi.enabled... 1752906: FF99+ default enabled

	if (isVer > 92) {
		// FF93+ "dom.weblocks.enabled"
		// 1739233: FF96+ Lock
		listU = listU.filter(x => !["Lock"].includes(x))
	}
	try {
		if (bBlock) {bB = 1}
		// create & append iframe
		let id = "iframe-window-version"
		let el = document.createElement("iframe")
		el.setAttribute("id", id)
		el.setAttribute('style', 'display: none')
		document.body.appendChild(el)
		// get props
		let iframe = document.getElementById(id)
		let contentWindow = iframe.contentWindow
		let props = Object.getOwnPropertyNames(contentWindow)
		// remove iframe
		iframe.parentNode.removeChild(iframe)
		props.sort()
		// expected
		let arrayE = props.filter(x => listE.includes(x))
		let resE = "", boolE = false
		if (arrayE.length) {
			resE = sha1(arrayE.join()) + s3 +" ["+ arrayE.length +"]"+ sc
			if (arrayE.length > 4) {boolE = true}
		} else {
			resE = "none"
		}
		// unexpected
		let arrayU = props.filter(x => listU.includes(x))
		// ignore BatteryManager FF72+
		if (isFF && isVer < 72) {arrayU = arrayU.filter(x => !["BatteryManager"].includes(x))}
		let resU = "", boolU = false
		if (arrayU.length) {
			resU = sha1(arrayU.join()) + s3 +" ["+ arrayU.length +"]"+ sc
		} else {
			resU = "none"
			boolU = true
		}
		// record
		fnRecord(num1, title, resE, boolE)
		fnRecord(num2, title, resU, boolU)
	} catch(e) {
		fnRecord(num1, title, e.name, zB0, e.message)
		fnRecord(num2, title, e.name, zB0, e.message)
	}
}

function get_installtrigger(num) {
	// FF100+: 1754441 behind prefs slated for deprecation
	let strA = "[typeof] InstallTrigger", boolA = false
	try {
		if (bBlock) {bB = 1}
		let resA = typeof InstallTrigger
		if (resA == "object") {boolA = true}
		if (isVer > 99) {
			fnRecord(num, strA, zNA +": FF99 or lower" + s3 +" ["+ resA +"]"+ sc, zNA)
		} else {
			fnRecord(num, strA, resA, boolA)
		}
	} catch(e) {
		fnRecord(num, strA, e.name, zB0, e.message)
	}

	let strB = "[window] InstallTrigger", boolB = false
	try {
		if (bBlock) {bB = 1}
		let resB = "InstallTrigger" in window
		if (isVer > 99) {
			fnRecord(num+1, strB, zNA +": FF99 or lower" + s3 +" ["+ resB +"]"+ sc, zNA)
		} else {
			fnRecord(num+1, strB, resB, resB)
		}
	} catch(e) {
		fnRecord(num+1, strB, e.name, zB0, e.message)
	}

	let strC = "[typeof] InstallTriggerImpl", boolC = false
	// FF60 or lower
	if (isFF && isVer < 61) {
		fnRecord(num+2, strC, zNA +": FF61+ required", zNA)
	} else {
		try {
			if (bBlock) {bB = 1}
			let resC = typeof InstallTriggerImpl
			if (resC == "function") {boolC = true}
			if (isVer > 99) {
				fnRecord(num+2, strC, zNA +": FF99 or lower" + s3 +" ["+ resC +"]"+ sc, zNA)
			} else {
				fnRecord(num+2, strC, resC, boolC)
			}
		} catch(e) {
			fnRecord(num+2, strC, e.name, zB0, e.message)
		}
	}
}

function get_intl_canonical_locale(num, title) {
	try {
		if (bBlock) {bB = 1}
		let list = ["bh","hye","no","tl","tw"], bool = false
		let res = []
		list.forEach(function(i) {
			res.push(i +": "+ Intl.getCanonicalLocales(i))
		})
		let hash = sha1(res.join())
		if (hash == "f52b504f78de0569f1dd6ae8830fac589a7a83e2") {bool = true // FF91+
		} else if (hash == "620140a916991fed2fc5b3f3b69731745793bbd3") {bool = true // FF70-90
		} else if (hash == "992692585f2bb1b00689181a905eb237a71c7823") {bool = true // FF60-69
		}
		// FF60-69 : bh=bh,  hye=hye, no=no, tl=tl,  tw=tw
		// FF70-90 : bh=bho, hye=hy,  no=nb, tl=fil, tw=ak
		// FF91+   : bh=bho, hye=hy,  no=no, tl=fil, tw=ak
		// blink   : bh=bh,  hye=hy,  no=no, tl=fil, tw=tw
		// webkit  : bh=bh,  hye=hy,  no=no, tl=tl,  tw=tw
		fnRecord(num, title, hash, bool)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_intl_collator(num, title) {
	try {
		if (bBlock) {bB = 1}
		// 22 FF60+ locales with unique collations not in chrome (lost my list vs safari)
		// 24 chars: approx 40ms
		let list = ['az','cy','dsb','ee','eo','gl','ha','haw','hsb','ig',
			'ka','kk','ln','lo','mt','no','om','pa','se','sq','to','wo',]
		let	chars = ['c','C','ch','ez','n','ng','r','ts','tt','\u00E4','\u0107',
			'\u00E7\a','\u0109','\u00EB','\u00ED','\u00EE','\u0144','\u00F1','\u0649',
			'\u0453','\u10D0','\u0E9A','\u1D95','\u025B',]
		let res = [], unique = [], same = []
		// webkit has everything FF does for collation that can be detected
		// except in FF70+, no (same as fo), so swap that out
		if (isVer < 70 && isFF) {
			list.push("fo")
			list = list.filter(x => !["no"].includes(x))
		}
		list.sort()
		chars.sort() // reset
		let control = sha1(chars.sort(Intl.Collator(undefined).compare))
		let bool = false
		list.forEach(function(i) {
			chars.sort() // reset
			chars.sort(Intl.Collator(i).compare)
			let test = sha1(chars.join())
			unique.push(test)
			if (test == control) {same.push(test)}
			res.push(i +" "+ test)
		})
		let hash = sha1(res.join())
		if (bLog) {
			unique = unique.filter(function (item, position) {return unique.indexOf(item) === position})
			let counts = (unique.length == list.length) ? "100\u0025 unique" : "["+ unique.length + "/" + list.length +"]"
			counts += " ["+ same.length +" = control]"
			console.log(title +": "+ hash +", "+ counts +"\n", res)
		}
		if (isVer > 69) {
			if (hash == "6d7bb7fc6054900b3e0e322a843ba96bc2e0c11e") {bool = true} // FF70+
		} else if (isVer > 58) {
			if (hash == "152220e565cdba8e36d483a78128a2a501ac3428") {bool = true} // FF59-69
		} else {
			if (hash == "f3dd69682f15cb6b95951a45659546283f71ea8f") {bool = true} // FF52-58
			if (hash == "152220e565cdba8e36d483a78128a2a501ac3428") {bool = true} // WFClassic isVer = 58
		}
		fnRecord(num, title, hash, bool)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_intl_display_names(num, title) {
	try {
		if (bBlock) {bB = 1}
		let test = Intl.DisplayNames.supportedLocalesOf("en")
		fnRecord(num, title, zNA +": coming soon", zNA)
	} catch(e) {
		// FF85-: TypeError: Intl.DisplayNames is undefined
		if (isFF) {
			if (isVer > 85) {
				fnRecord(num, title, e.name, zB0, e.message)
			} else {
				let msg = e.message
				msg = msg.replace("can't access property \"supportedLocalesOf\", ", "") // trim *error_fix
				if (e.name == "TypeError" && msg == "Intl.DisplayNames is undefined") {
					fnRecord(num, title, zNA +": FF86+ required", zNA)
				} else {
					fnRecord(num, title, e.name, zB0, e.message)
				}
			}
		} else {
			fnRecord(num, title, zNA +": not supported", zNA)
		}
	}
}

function get_intl_dtf(num, title) {
	try {
		if (bBlock) {bB = 1}
		// 78 locales supported in FF60+ not supported in blink: unique results
		let list = ['ak','ast','be','bm','bo','ce','ckb','eo','no','to']
		let bool = false
		let date = new Date("January 30, 2019 13:00:00"),
			options = {weekday: "long", month: "long", day: "numeric", year: "numeric", hour: "numeric",
				minute: "numeric", second: "numeric", hour12: true}
		let res = [], unique = [], same = []
		if (isVer < 70 && isFF) {
			list.push("fo")
			list = list.filter(x => !["no"].includes(x))
		}
		list.sort()
		let control = Intl.DateTimeFormat(undefined, options).format(date)
		list.forEach(function(locale) {
			let test = Intl.DateTimeFormat(locale, options).format(date)
			unique.push(test)
			if (test == control) {same.push(locale)}
			res.push(locale +" "+ test)
		})
		let hash = sha1(res.join())
		if (bLog) {
			unique = unique.filter(function (item, position) {return unique.indexOf(item) === position})
			let counts = (unique.length == list.length) ? "100\u0025 unique" : "["+ unique.length + "/" + list.length +"]"
			counts += " ["+ same.length +" = control]"
			console.log(title +": "+ hash +", "+ counts +"\n", res)
		}
		if (isVer > 100) {
			if (hash == "f3292db015c0915ce6099982d84727986140f999") {bool = true} // FF101+
		} else if (isVer > 69) {
			if (hash == "1a3f0c7c622a644a1f2a355790faf6ff834012b6") {bool = true} // FF70-100
		} else if (isVer > 58) {
			if (hash == "661319323bd37daabe3c83a649f024e5929a499d") {bool = true} // FF59-69
		} else {
			if (hash == "407454b2169899f2c4b3264a716223315d844f0b") {bool = true} // FF55-57 RFP
			if (hash == "f5089491bdc7f062e689571ade2a94a0aa67c7e3") {bool = true} // FF52-58
			if (hash == "5e50264aff470447e8c19c899061eada3528ed45") {bool = true} // WFClassic52 RFP
			if (hash == "661319323bd37daabe3c83a649f024e5929a499d") {bool = true} // WFClassic isVer = 58
		}
		fnRecord(num, title, hash, bool)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_intl_list_format(num, title) {
	try {
		if (bBlock) {bB = 1}
		let test = Intl.ListFormat.supportedLocalesOf("en")
		fnRecord(num, title, zNA +": coming soon", zNA)
	} catch(e) {
		// FF77-: TypeError: Intl.ListFormat is undefined
		if (isFF) {
			if (isVer > 77) {
				fnRecord(num, title, e.name, zB0, e.message)
			} else {
				let msg = e.message
				msg = msg.replace("can't access property \"supportedLocalesOf\", ", "") // trim *error_fix
				if (e.name == "TypeError" && msg == "Intl.ListFormat is undefined") {
					fnRecord(num, title, zNA +": FF78+ required", zNA)
				} else {
					fnRecord(num, title, e.name, zB0, e.message)
				}
			}
		} else {
			fnRecord(num, title, zNA +": not supported", zNA)
		}
	}
}

function get_intl_number_format(num, title) {
	try {
		if (bBlock) {bB = 1}
		let list = ['mai','no','su','tl','tw'] // gecko not in webkit: FF70/78
		list.push('af','bo','lb','se','to') // some FF60+ gecko not in blink
    list.push('co','cv','nso','oc','tig') // some webkit only
		let res = []
		list.forEach(function(locale) {
			let test = Intl.NumberFormat.supportedLocalesOf(locale)
			if (test.length) {res.push(locale)}
		})
		res.sort()
		let hash = sha1(res.join()),
			bool = false
		if (hash == "f727ab8e719e15bbc50cb2a80a4f8a170e257364") {bool = true // FF78+
		} else if (hash == "10260ae28405581ccf307457ba54fce1314028ff") {bool = true // FF70-77
		} else if (hash == "ed89e80134f060f82515f6cf8e4658bd0e0405e2") {bool = true // FF60-69
		}
		fnRecord(num, title, hash + s3 +" ["+ res.length +"]"+ sc, bool)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_intl_pluralrules(num, title) {
	try {
		if (bBlock) {bB = 1}
		let list = ['mai','no','su','tl','tw'] // gecko not in webkit: FF70/78
		list.push('ki','qu') // some FF60+ gecko not in blink
		list.push('an','lij','vo') // chrome only
		list.push('ba','co','cv','gn','oc') // webkit only
		let res = []
		list.forEach(function(locale) {
			let test = Intl.PluralRules.supportedLocalesOf(locale)
			if (test.length) {res.push(locale)}
		})
		res.sort()
		let hash = sha1(res.join()),
			bool = false
		if (hash == "e37e6be93df8ebcb231c0ce502e34d2647e45bf0") {bool = true // FF78+
		} else if (hash == "f1c25801863b1bc07dbabc13dfea31417ba9d533") {bool = true // FF70-77
		} else if (hash == "eb8994a2172fbf52b6f0e9461869a48b0bfaa06c") {bool = true // FF60-69
		}
		fnRecord(num, title, hash + s3 +" ["+ res.length +"]"+ sc, bool)
	} catch(e) {
		// FF57 or lower
		let result = e.name
		let type = zB0
		let error = e.message
		if (isVer < 59 && e.message == "Intl.PluralRules is undefined") {
			result = zNA +": FF58+ required"
			type = zNA
			error = undefined
		}
		fnRecord(num, title, result, type, error)
	}
}

function get_intl_rtf(num, title) {
	try {
		if (bBlock) {bB = 1}
		let test = Intl.RelativeTimeFormat.supportedLocalesOf("en")
		fnRecord(num, title, zNA +": coming soon", zNA)
	} catch(e) {
		// FF64-: TypeError: Intl.RelativeTimeFormat is undefined
		if (isFF) {
			if (isVer > 64) {
				fnRecord(num, title, e.name, zB0, e.message)
			} else {
				if (e.name == "TypeError" && e.message == "Intl.RelativeTimeFormat is undefined") {
					fnRecord(num, title, zNA +": FF65+ required", zNA)
				} else {
					fnRecord(num, title, e.name, zB0, e.message)
				}
			}
		} else {
			fnRecord(num, title, zNA +": not supported", zNA)
		}
	}
}

function get_js_client_hints(num, title) {
	// testing: https://web.dev/user-agent-client-hints/
	// https://user-agent-client-hints.glitch.me/javascript.html
	// TypeError can't access property "X", navigator.X is undefined
	function output() {
		if (res.length) {
			//console.log(res)
			res.sort()
			let hash = sha1(res.join())
			fnRecord(num, title, hash + s3 +" ["+ res.length +"]"+ sc, false)
		} else {
			fnRecord(num, title, "none", true)
		}
	}
	let res = []
	try {
		let resB = navigator.userAgentData.brands
		resB.forEach(function(object) {
			let valueB = fnClean(object.version)
			res.push("brands: "+ object.brand +": "+ valueB)
		})
	} catch(e) {}
	try {
		res.push("mobile: " + navigator.userAgentData.mobile)
	} catch(e) {}
	try {
		res.push("platform: " + navigator.userAgentData.platform)
	} catch(e) {}
	try {
		navigator
			.userAgentData.getHighEntropyValues(
				["architecture","bitness","brands","mobile","model","platform","platformVersion","uaFullVersion"]
			).then(ua => {
				const names = Object.keys(ua)
				for (const k of names) {
					let valueU = fnClean(ua[k])
					res.push("high entropy: "+ k +": "+ valueU)
				}
				output()
			})
	} catch(e) {
		output()
	}
}

function get_last_prototype_keys(num1, title) {
	// HTMLAnchorElement
	let title1 = title +" HTMLAnchorElement"
	try {
		if (bBlock) {bB = 1}
		Object.keys(HTMLAnchorElement.prototype)
		let props1 = Object.getOwnPropertyNames(HTMLAnchorElement.prototype) // includes the constructor
		let res1 = props1.slice(-3).join(", ")
		// search, hash, constructor
		fnRecord(num1, title1, res1, res1 == "search, hash, constructor")
	} catch(e) {
		fnRecord(num1, title1, e.name, zB0, e.message)
	}

	// HTMLLinkElement
	let title2 = title +" HTMLLinkElement"
	let num2 = num1 + 1
	try {
		if (bBlock) {bB = 1}
		Object.keys(HTMLLinkElement.prototype)
		let props2 = Object.getOwnPropertyNames(HTMLLinkElement.prototype) // includes the constructor
		let res2 = props2.slice(-3).join(", ")
		let bol2 = res2 == "as, sheet, constructor"
		// 52-55: integrity, sheet, constructor
		if (isVer <= 56 && res2 == "integrity, sheet, constructor") {bol2 = true}
		fnRecord(num2, title2, res2, bol2)
	} catch(e) {
		fnRecord(num2, title2, e.name, zB0, e.message)
	}
}

function get_locale_compare(num, title) {
	try {
		if (bBlock) {bB = 1}
		let bool = false
		let list = [
			["az","\u00F6","\u1EE3"],
			["cy","n","ng"],
			["dsb","\u0144","\u00F1"],
			["ee","ts","tt"],
			["eo","\u0109","\u00E7\a"],
			["gl","\u00F1","ng"],
			["ha","ts","tt"],
			["haw","\u00F0","\u00EB"],
			["hsb","\u0107","\u0109"],
			["ig","c","ch"],
			["ka","\u0107","\u10D0"],
			["kk","r","\u0453"],
			["ln","\u1D95","\u025B"],
			["lo","\u0107","\u0E9A"],
			["mt","c","C"],
			["no","\u00F6","\u1EE3"],
			["om","ch","\u00ED"],
			["pa","\u0107","\u0649"],
			["se","\u00F6","\u1EE3"],
			["sq","\u00EB","ez"],
			["to","\u00ED","\u00EE"],
			["wo","\u00EB","ez"],
		]
		let res = [], same = []
		// webkit: see intl.collator notes: swap "fo" with "no" FF70+
		list.forEach(function(item) {
			let code = item[0]
			if (isVer < 70 && isFF && code == "no") {code = "fo"} // isFF only
			let strA = item[1]
			let test = strA.localeCompare(item[2], code)
			if (test !== 1) {same.push(code)}
			res.push(code +" "+ test +" "+ strA +","+ item[2])
		})
		res.sort()
		let hash = sha1(res.join())
		if (bLog) {
			let counts = " ["+ same.length +" = control]"
			console.log(title +": "+ hash +", "+ counts +"\n", res)
		}
		if (isVer > 69) {
			if (hash == "7619f44ddbccfdbcde0caf9417cef76196f32776") {bool = true} // FF70+
		} else if (isVer > 58) {
			if (hash == "d47a4f0e61d5d6d1583419a177c39f284611c9cf") {bool = true} // FF59-69
		} else {
			if (hash == "1cfcca8eaa05f4d004015953c01c312f22c261ab") {bool = true} // FF52-58
			if (hash == "d47a4f0e61d5d6d1583419a177c39f284611c9cf") {bool = true} // WFClassic isVer = 58
		}
		fnRecord(num, title, hash, bool)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_math(num, title) {
	// polyfill
	function cbrt(x) {
		try {
			let y = Math.pow(Math.abs(x), 1 / 3)
			return x < 0 ? -y : y
		} catch(e) {
			return "error"
		}
	}
	try {
		if (bBlock) {bB = 1}
		let res = []
		for(let i=0; i < 6; i++) {
			try {
				let fnResult = "unknown"
				if (i == 0) {fnResult = cbrt(Math.PI) // polyfill
				} else if (i == 1) {fnResult = Math.log10(7*Math.LOG10E)
				} else if (i == 2) {fnResult = Math.log10(2*Math.SQRT1_2)
				} else if (i == 3) {fnResult = Math.acos(0.123)
				} else if (i == 4) {fnResult = Math.acosh(Math.SQRT2)
				} else if (i == 5) {fnResult = Math.atan(2)
				}
				res.push(fnResult)
			} catch(e) {
				res.push("error")
			}
		}
		let hash = sha1(res.join()).substring(0,20)
		let engine = ""
		if (hash == "ede9ca53efbb1902cc21") {engine = "blink"
		} else if (hash == "05513f36d87dd78af60a") {engine = "webkit"
		} else if (hash == "38172d9426d77af71baa") {engine = "edgeHTML"
		} else if (hash == "36f067c652c8cfd90725") {engine = "trident"
		} else if (hash == "225f4a612fdca4065043") {engine = "gecko"
		} else if (hash == "cb89002a8d6fabf859f6") {engine = "gecko"
		}

		let bool = engine == "gecko" ? true : false
		if (bool) {
			// full hash for gecko
			hash = sha1(res.join())
		} else {
			// trimmed hash + notation for non-gecko
			hash += "... "
			if (engine == "") {hash += sb +"[that's dodgy]"+sc
			} else {hash += s3 +"["+ engine +"]"+sc}
		}
		fnRecord(num, title, hash, bool)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_media_constraints(num, title) {
	// blink: 18c59e90bb3af0ce32be8efaa4457ead01fcacd8 [32]
	try {
		if (bBlock) {bB = 1}
		let data = navigator.mediaDevices.getSupportedConstraints()
		let res = Object.keys(data)
		res.sort()
		let hash = sha1(res.join())
		let bool = false
		if (isVer > 69) {
			if (hash == "2e72961b2b902ea8d3f652e86eb7c0b56da5901f") {bool = true} // FF70+
		} else {
			if (hash == "4b24a64fb54b15868d13ee77cbcbd87e2272c7dc") {bool = true} // FF56-69
			if (isVer < 57) {
				if (hash == "827e0cc87e804fc83ec5d67d43f0547f9cf0e624") {bool = true} // FF55
			}
			if (isVer < 55) {
				if (hash == "f772cf52c7cb9623cc62652f2b0879597e096f37") {bool = true} // FF52-54
			}
		}
		fnRecord(num, title, hash + s3 +" ["+ res.length +"]"+ sc, bool)
	} catch(e) {
		// e.g. TB disables mediaDevices
		let error = sha1(e.name +": "+ e.message), isNA = false
		if (error == "8d6b18a941659cb64de87e474d683a3503d01fce") {isNA = true}
		if (error == "ad64c7024fe40248168aef7da50f3272efffb221") {isNA = true}
		if (isNA) {
			fnRecord(num, title, zNA +": disabled", zNA)
		} else {
			fnRecord(num, title, e.name, zB0, e.message)
		}
	}
}

function get_mimetypes(num, title) {
	try {
		if (bBlock) {bB = 1}
		if ("mimeTypes" in navigator) {
			let res = [], bool = false, isFlash = false
			let m = navigator.mimeTypes
			if (m.length == 0) {
				fnRecord(num, title, "none", true)
			} else {
				for (let i=0; i < m.length; i++) {
					res.push( m[i].type + (m[i].description == "" ? ": * " : ": "+ m[i].type)
						+ (m[i].suffixes == "" ? ": *" : ": "+ m[i].suffixes) )
				}
				res.sort()
				// FF84 or lower allow just Flash
				if (isFF && isVer < 85 && res.length == 2) {
					let mime1 = res[0].split(":")[0]
					let mime2 = res[1].split(":")[0]
					if (mime1 == "application/x-futuresplash" && mime2 == "application/x-shockwave-flash") {
						bool = true; isFlash = true
					}
				}
				let hash = sha1(res.join()) + s3 +" ["+ res.length +"]"+ sc
				if (isVer > 98 || !isFF) { // allow non-FF to have the same
					// FF99+: controlled by pdfjs.disabled
					// 1720353: hardcoded mimeTypes = 33c916c1a0e2e4e72047e6e142a7b43c6b1eba22
					if (sha1(res.join()) == "33c916c1a0e2e4e72047e6e142a7b43c6b1eba22") {
						bool = true
						num = 710 // move to specific values
					}
				} else if (isFF) {
					if (isFlash) {hash = "flash detected [FF84 or lower]"}
				}
				fnRecord(num, title, hash, bool)
			}
		} else {
			fnRecord(num, title, e.name, zB0)
		}
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_moz_colors(num, title) {
	let aList = [
		// css4
		'-moz-activehyperlinktext','-moz-default-color','-moz-default-background-color','-moz-hyperlinktext','-moz-visitedhyperlinktext',
		// stand-ins
		'-moz-buttondefault','-moz-buttonhoverface','-moz-buttonhovertext','-moz-cellhighlight','-moz-cellhighlighttext','-moz-combobox','-moz-comboboxtext','-moz-dialog','-moz-dialogtext','-moz-dragtargetzone','-moz-eventreerow','-moz-field','-moz-fieldtext','-moz-html-cellhighlight','-moz-html-cellhighlighttext','-moz-mac-chrome-active','-moz-mac-chrome-inactive','-moz-mac-disabledtoolbartext','-moz-mac-focusring','-moz-mac-menuselect','-moz-mac-menushadow','-moz-mac-menutextdisable','-moz-mac-menutextselect','-moz-mac-secondaryhighlight','-moz-menubarhovertext','-moz-menubartext','-moz-menuhover','-moz-menuhovertext','-moz-nativehyperlinktext','-moz-oddtreerow','-moz-win-communicationstext','-moz-win-mediatext',
		// moz
		'-moz-accent-color','-moz-accent-color-foreground','-moz-appearance','-moz-colheaderhovertext','-moz-colheadertext','-moz-gtk-buttonactivetext','-moz-gtk-info-bar-text','-moz-mac-accentdarkestshadow','-moz-mac-accentdarkshadow','-moz-mac-accentface','-moz-mac-accentlightesthighlight','-moz-mac-accentlightshadow','-moz-mac-accentregularhighlight','-moz-mac-accentregularshadow','-moz-mac-active-menuitem','-moz-mac-active-source-list-selection','-moz-mac-buttonactivetext','-moz-mac-defaultbuttontext','-moz-mac-menuitem','-moz-mac-menupopup','-moz-mac-source-list','-moz-mac-source-list-selection','-moz-mac-tooltip','-moz-mac-vibrancy-dark','-moz-mac-vibrancy-light','-moz-mac-vibrant-titlebar-dark','-moz-mac-vibrant-titlebar-light','-moz-win-accentcolor','-moz-win-accentcolortext','-moz-win-communications-toolbox','-moz-win-media-toolbox',
	]
	aList.sort()
	try {
		if (bBlock) {bB = 1}
		let aRes = []
		let element = dom.mozColor
		let strColor = "rgba(1, 2, 3, 0.5)"
		aList.forEach(function(style) {
			element.style.backgroundColor = strColor // always reset
			element.style.backgroundColor = style
			let rgb = window.getComputedStyle(element, null).getPropertyValue("background-color")
			if (rgb !== strColor) {
				aRes.push(style +":"+ rgb) // only record those affected
			}
		})
		//console.debug(aRes)
		let bool = aRes.length > 0
		let hash = bool ? mini_sha1(aRes) + s3 +" ["+ aRes.length +"]"+ sc : "none"
		fnRecord(num, title, hash, bool)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_moz_computed_styles(num, title) {
	/* https://github.com/abrahamjuliot/creepjs */
		let styleVersion = type => {
			return new Promise(resolve => {

			// get CSSStyleDeclaration
			try {
				if (bBlock) {bB = 1}
				let cssStyleDeclaration = (
					type == 0 ? getComputedStyle(document.body) :
					type == 1 ? document.body.style :
					type == 2 ? document.styleSheets[0].cssRules[0].style :
					undefined
				)
				if (!cssStyleDeclaration) {
					throw new TypeError("invalid argument string")
				}
				// get properties
				let prototype = Object.getPrototypeOf(cssStyleDeclaration),
					prototypeProperties = Object.getOwnPropertyNames(prototype),
					ownEnumerablePropertyNames = [],
					cssVar = /^--.*$/
				Object.keys(cssStyleDeclaration).forEach(key => {
					let numericKey = !isNaN(key),
						value = cssStyleDeclaration[key],
						customPropKey = cssVar.test(key),
						customPropValue = cssVar.test(value)
					if (numericKey && !customPropValue) {
						return ownEnumerablePropertyNames.push(value)
					} else if (!numericKey && !customPropKey) {
						return ownEnumerablePropertyNames.push(key)
					}
					return
				})
				// get properties in prototype chain (required only in chrome)
				let propertiesInPrototypeChain = {}
				let capitalize = str => str.charAt(0).toUpperCase() + str.slice(1),
					uncapitalize = str => str.charAt(0).toLowerCase() + str.slice(1),
					removeFirstChar = str => str.slice(1),
					caps = /[A-Z]/g
				ownEnumerablePropertyNames.forEach(key => {
					if (propertiesInPrototypeChain[key]) {
						return
					}
					// determine attribute type
					let isNamedAttribute = key.indexOf('-') > -1,
						isAliasAttribute = caps.test(key)
					// reduce key for computation
					let firstChar = key.charAt(0),
						isPrefixedName = isNamedAttribute && firstChar == '-',
						isCapitalizedAlias = isAliasAttribute && firstChar == firstChar.toUpperCase()
					key = (
						isPrefixedName ? removeFirstChar(key) :
						isCapitalizedAlias ? uncapitalize(key) :
						key
					)
					// find counterpart in CSSStyleDeclaration object or its prototype chain
					if (isNamedAttribute) {
						let aliasAttribute = key.split('-').map((word, index) => index == 0 ? word : capitalize(word)).join('')
						if (aliasAttribute in cssStyleDeclaration) {
							propertiesInPrototypeChain[aliasAttribute] = true
						} else if (capitalize(aliasAttribute) in cssStyleDeclaration) {
							propertiesInPrototypeChain[capitalize(aliasAttribute)] = true
						}
					} else if (isAliasAttribute) {
						let namedAttribute = key.replace(caps, char => '-' + char.toLowerCase())
						if (namedAttribute in cssStyleDeclaration) {
							propertiesInPrototypeChain[namedAttribute] = true
						} else if (`-${namedAttribute}` in cssStyleDeclaration) {
							propertiesInPrototypeChain[`-${namedAttribute}`] = true
						}
					}
					return
				})
				// compile keys
				let keys = [
					...new Set([
						...prototypeProperties,
						...ownEnumerablePropertyNames,
						...Object.keys(propertiesInPrototypeChain)
					])
				]
				// checks
				let moz = keys.filter(key => (/moz/i).test(key)) //.length,
					//webkit = keys.filter(key => (/webkit/i).test(key)).length,
					//prototypeName = ('' + prototype).match(/\[object (.+)\]/)[1]
				// output
				return resolve({
					//keys,
					moz
					//webkit,
					//prototypeName
				})
			} catch(e) {
				fnRecord(num, title, e.name, zB0, e.message)
				return resolve("error")
			}
		})
	}

	// run
	Promise.all([
		styleVersion(0), // we only need one result
	]).then(res => {
		if (res == "error") {
			return
		}
		try {
			let aRes = res[0]["moz"]
			aRes.sort()
			let bool = aRes.length > 0
			let hash = bool ? mini_sha1(aRes) + s3 +" ["+ aRes.length +"]"+ sc : "none"
			bool = aRes.length > 50 // just in case someone spoofs a couple, or older/other browsers have some
			fnRecord(num, title, hash, bool)
		} catch(err) {
			fnRecord(num, title, err.name, zB0, err.message)
		}
	}).catch(error => {
		fnRecord(num, title, error.name, zB0, error.message)
	})
}

function get_moz_fonts(num, title) {
	let aResults = [],
		m = "-moz-",
		aFonts = [m+"window",m+"desktop",m+"document",m+"workspace",m+"info",m+"pull-down-menu",m+"dialog",m+"button",m+"list",m+"field"]
	try {
		let el = dom.mozFont
		if (bBlock) {bB = 1}
		aFonts.forEach(function(font){
			// catch blocked
			let test = getComputedStyle(el).getPropertyValue("font-family")
			el.style.font = "99px sans-serif"
			try {el.style.font = font} catch(err) {}
			let s = ""
			if (window.getComputedStyle) {
				try {
					s = getComputedStyle(el, null)
				} catch(e) {}
			}
			if (s !== "") {
				let f = s.fontSize != "99px" ? s.fontFamily : undefined
				if (f !== undefined) {aResults.push(f)}
			}
		})
		let bool = aResults.length > 0
		let hash = bool ? mini_sha1(aResults) + s3 +" ["+ aResults.length +"]"+ sc : "none"
		fnRecord(num, title, hash, bool)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_nav_keys(num1, num2, title) {
	try {
		if (bBlock) {bB = 1}
		let aNavKeys = Object.keys(Object.getOwnPropertyDescriptors(Navigator.prototype))
		// expected FF only
		let aNavExpected = ["buildID","oscpu","taintEnabled"]
		let aNavCheckE = aNavKeys.filter(x => aNavExpected.includes(x))
		let resNavCheckE = aNavCheckE.length ? aNavCheckE.join(", ") : "none"
		let testNavCheckE = aNavCheckE.length == 3 ? true : false
		fnRecord(num1, title, resNavCheckE, testNavCheckE)
		// not expected: blink items
		let aNavNotExpected = ["canShare","clearAppBadge","deviceMemory","getBattery","getInstalledRelatedApps",
			"getUserMedia","globalPrivacyControl","hid","keyboard","locks","managed","presentation","scheduling",
			"serial","setAppBadge","unregisterProtocolHandler","usb","userActivation","userAgentData","wakeLock",
			"webkitGetUserMedia","webkitPersistentStorage","webkitTemporaryStorage","xr","SharedWorker","Worker"]
		// FYI: don't use requestMIDIAccess: FF60+ behind dom.webmidi.enabled... 1752906: FF99+ default enabled
		if (isVer > 95) {
			// 1666203: FF96+ canShare
			aNavNotExpected = aNavNotExpected.filter(x => !["canShare"].includes(x))
		}
		if (isVer > 94 || isEngine == "goanna") {
			// 1670058: FF95+ globalPrivacyControl
			// PM 30
			aNavNotExpected = aNavNotExpected.filter(x => !["globalPrivacyControl"].includes(x))
		}
		if (isVer > 92) {
			// FF93+ "dom.weblocks.enabled"
			// 1739233: FF96+ locks
			aNavNotExpected = aNavNotExpected.filter(x => !["locks"].includes(x))
		}
		let aNavCheckNotE = aNavKeys.filter(x => aNavNotExpected.includes(x))
		let resNavCheckNotE = sha1(aNavCheckNotE.join()) + s3 + " ["+ aNavCheckNotE.length +"]"+ sc
		if (aNavCheckNotE.length == 0) {resNavCheckNotE = "none"}
		fnRecord(num2, title, resNavCheckNotE, aNavCheckNotE.length ? false : true)
	} catch(e) {
		fnRecord(num1, title, e.name, zB0, e.message)
		fnRecord(num2, title, e.name, zB0, e.message)
	}
}

function get_nav_screen(num) {
	let strA = "[left] screen", boolA = false
	try {
		if (bBlock) {bB = 1}
		let resA = screen.left
		if (!isNaN(resA)) {boolA = true} else {resA = fnClean(resA)}
		fnRecord(num, strA, resA, boolA)
	} catch(e) {
		fnRecord(num, strA, e.name, zB0, e.message)
	}
	let strB = "[top] screen", boolB = false
	try {
		if (bBlock) {bB = 1}
		let resB = screen.top
		if (!isNaN(resB)) {boolB = true} else {resB = fnClean(resB)}
		fnRecord(num+1, strB, resB, boolB)
	} catch(e) {
		fnRecord(num+1, strB, e.name, zB0, e.message)
	}
}

function get_nav_values(num1, num2, num3) {
	// expected
	let strA = "[oscpu] navigator", boolA = false
	try {
		if (bBlock) {bB = 1}
		let resA = navigator.oscpu
		if (typeof resA !== "string") {
			//console.debug(typeof resA)
		} else {
			if (resA == "") {resA = "empty string"
			} else if (resA == undefined) {resA = zU
			} else if (resA == zU) {resA = zUQ
			} else {boolA = true}
		}
		fnRecord(num1, strA, resA, boolA)
	} catch(e) {
		fnRecord(num1, strA, e.name, zB0, e.message)
	}

	// not expected
	// bluetooth
	let strBT = "[bluetooth] navigator", boolBT = false, numBT = num2
	try {
		if (bBlock) {bB = 1}
		let resBT = navigator.bluetooth
		if (resBT === undefined) {
			fnRecord(numBT, strBT, zU, true)
		} else {
			try {
				navigator.bluetooth.getAvailability().then(available => {
					if (available) {
						fnRecord(numBT, strBT, "supported", boolBT)
					} else {
						fnRecord(numBT, strBT, "not supported", boolBT)
					}
				})
			} catch(e) {
				fnRecord(numBT, strBT, e.name, zB0)
			}
		}
	} catch(e) {
		fnRecord(numBT, strBT, e.name, zB0, e.message)
	}
	// deviceMemory
	let strDM = "[deviceMemory] navigator", boolDM = false, numDM = num2+2
	try {
		if (bBlock) {bB = 1}
		let resDM = navigator.deviceMemory
		if (resDM == undefined) {boolDM = true}
		resDM = fnClean(resDM)
		fnRecord(numDM, strDM, resDM, boolDM)
	} catch(e) {
		fnRecord(numDM, strDM, e.name, zB0, e.message)
	}
	// getbattery
	let strB = "[getBattery] navigator", boolB = false, numB = num2+4
	let resB = []
	try {
		if (bBlock) {bB = 1}
		// not going to add eventlisteners
		navigator.getBattery().then(function(battery) {
			try {resB.push(battery.level * 100 + "%")} catch(e) {resB.push("error")}
			try {resB.push((battery.charging ? "": "not ") +"charging")} catch(e) {resB.push("error")}
			try {resB.push(battery.chargingTime)} catch(e) {resB.push("error")}
			try {resB.push(battery.dischargingTime)} catch(e) {resB.push("error")}
			fnRecord(numB, strB, resB.join(", "), false)
		})
	} catch(e) {
		if (e.name == "TypeError" && e.message.substring(0,38) == "navigator.getBattery is not a function") {
			if (e.message == "navigator.getBattery is not a function") {boolB = true} // webkit wil be false
			fnRecord(numB, strB, e.name, boolB, e.message)
		} else {
			fnRecord(numB, strB, e.name, zB0, e.message)
		}
	}
	// globalprivacycontrol
	let strG = "[gpc] navigator", boolG = false, numG = num2+6
	try {
		if (bBlock) {bB = 1}
		let resG = navigator.globalPrivacyControl
		resG = fnClean(resG)
		if (resG == "undefined") {boolG = true
		} else if (isEngine == "goanna" && resG == "empty string") {boolG = true; resG += s3 + " [goanna]"+ sc}

		// 1670058: FF95+ globalPrivacyControl
		if (isVer > 94) {
			resG = zNA +": FF94 or lower" + s3 +" ["+ resG +"]" + sc
			boolG = zNA
		}
		fnRecord(numG, strG, resG, boolG)
	} catch(e) {
		fnRecord(numG, strG, e.name, zB0, e.message)
	}

	// keyboard
	let strK = "[keyboard] navigator", numK = num2+8
	try {
		if (bBlock) {bB = 1}
		let resK = navigator.keyboard
		if (resK == undefined) {
			fnRecord(numK, strK, "undefined", true)
		} else {
			let keys = []
			// https://wicg.github.io/keyboard-map/
			// https://www.w3.org/TR/uievents-code/#key-alphanumeric-writing-system
			let listK = ['Backquote','Backslash','Backspace','BracketLeft','BracketRight','Comma',
				'Digit0','Digit1','Digit2','Digit3','Digit4','Digit5','Digit6','Digit7','Digit8','Digit9',
				'Equal','IntlBackslash','IntlRo','IntlYen','KeyA','KeyB','KeyC','KeyD','KeyE','KeyF','KeyG',
				'KeyH','KeyI','KeyJ','KeyK','KeyL','KeyM','KeyN','KeyO','KeyP','KeyQ','KeyR','KeyS','KeyT',
				'KeyU','KeyV','KeyW','KeyX','KeyY','KeyZ','Minus','Period','Quote','Semicolon','Slash']
			resK.getLayoutMap().then(keyboardLayoutMap => {
				listK.forEach(function(key) {
					try {keys.push(key +": "+ keyboardLayoutMap.get(key))} catch(e) {keys.push(key +": e.name")}
				})
				let hash = sha1(keys.join())
				fnRecord(numK, strK, hash, false)
			})
		}
	} catch(e) {
		fnRecord(numK, strK, e.name, zB0, e.message)
	}
	// vendor
	let strV = "[vendor] navigator", boolV = false, numV = num2+10
	try {
		if (bBlock) {bB = 1}
		let resV = navigator.vendor
		if (resV == "") {boolV = true}
		resV = fnClean(resV)
		fnRecord(numV, strV, resV, boolV)
	} catch(e) {
		fnRecord(numV, strV, e.name, zB0, e.message)
	}

	// navigator.webkitTemporaryStorage.queryUsageAndQuota
		// "TypeError: can't access property "queryUsageAndQuota", navigator.webkitTemporaryStorage is undefined"
	// navigator.webkitPersistentStorage.queryUsageAndQuota
		// "TypeError: can't access property "queryUsageAndQuota", navigator.webkitPersistentStorage is undefined"

	// specific
	let strX = "[buildID] navigator", boolX = false
	try {
		if (bBlock) {bB = 1}
		let resX = navigator.buildID
		if (isVer > 63) {
			// all FF64+
			if (resX == "20181001000000") {boolX = true}
		} else {
			resX = fnClean(resX)
			// FF52-63: 14 digit number starting with 2017
			let year = resX.slice(0,4) *1
			if (resX.length == 14) {
				let isCheck = false
				if (year > 2016 && year < 2020) {isCheck = true}
				if (isVer < 59) {if (year > 2016) {isCheck = true}} // FF52 waterfox basilisk palemoon
				if (isCheck) {
					if (!isNaN(resX * 1)) {boolX = true}
				}
			} else if (isRFP56plus) {
				// luckily RFP only alters buildID starting FF56
				// RFP FF56-63 = 20100101
				if (resX == "20100101") {boolX = true}
			}
		}
		fnRecord(num3, strX, resX, boolX)
	} catch(e) {
		fnRecord(num3, strX, e.name, zB0, e.message)
	}
	// DNT: FF: 1, unspecified
	let strDNT = "[doNotTrack] navigator", boolDNT = false, numDNT = num3+2
	try {
		if (bBlock) {bB = 1}
		let testDNT = navigator.doNotTrack
		if (testDNT == 1 || testDNT == "unspecified") {
			boolDNT = true
		} else {
			testDNT = fnClean(testDNT)
		}
		if (isFF && !boolDNT) {
			// PM not supported: returns undefined
			if (isEngine == "goanna" && testDNT == "undefined") {
				fnRecord(numDNT, strDNT, testDNT, true)
			} else {
				fnRecord(numDNT, strDNT, testDNT, zB0)
			}
		} else {
			fnRecord(numDNT, strDNT, testDNT, boolDNT)
		}
	} catch(e) {
		fnRecord(numDNT, strDNT, e.name, zB0, e.message)
	}

	let strY = "[productSub] navigator", boolY = false, numY = num3+4
	try {
		if (bBlock) {bB = 1}
		let resY = navigator.productSub
		if (resY == "20100101") {boolY = true} else {resY = fnClean(resY)}
		fnRecord(numY, strY, resY, boolY)
	} catch(e) {
		fnRecord(numY, strY, e.name, zB0, e.message)
	}
}

function get_permission(num, title) {
	try {
		if (bBlock) {bB = 1}
		let userVis = "userVisibleOnly"
		navigator.permissions.query({name:"push"}).then(function(result) {
			let res = result.state
			let bool = (res == "prompt" || res == "denied" || res == "granted") ? true : false
			fnRecord(num, title, res, bool)
		}).catch(error => {
			if ((error.message).includes(userVis)) {
				fnRecord(num, title, userVis, false)
			} else {
				fnRecord(num, title, error.name, zB0, error.message)
			}
		})
	} catch(e) {
		// not supported in webkit: https://caniuse.com/?search=push%20permission
		if (isWebkit) {
			fnRecord(num, title, "not supported", false)
		} else {
			fnRecord(num, title, e.name, zB0, e.message)
		}
	}
}

function get_plugins(num, title) {
	try {
		if (bBlock) {bB = 1}
		if ("plugins" in navigator) {
			let res = [], bool = false, isFlash = false
			let p = navigator.plugins
			if (p.length == 0) {
				fnRecord(num, title, "none", true)
			} else {
				for (let i=0; i < p.length; i++) {
					res.push(p[i].name + (p[i].filename == "" ? ": * " : ": "+ p[i].filename)
						+ (p[i].description == "" ? ": *" : ": "+ p[i].description))
				}
				res.sort()
				// FF84 or lower allow just Flash
				if (isFF && isVer < 85 && res.length == 1) {
					if (res[0].split(":")[0] == "Shockwave Flash") {bool = true; isFlash = true}
				}
				let hash = sha1(res.join()) + s3 +" ["+ res.length +"]"+ sc
				if (isVer > 98 || !isFF) { // allow non-FF to have the same
					// FF99+: controlled by pdfjs.disabled
					// 1720353: hardcoded mimeTypes = a1c55525766a48e19810c6a2accc17f62a748901
					if (sha1(res.join()) == "a1c55525766a48e19810c6a2accc17f62a748901") {
						bool = true
						num = 740 // move to specific values
					}
				} else if (isFF) {
					if (isFlash) {hash = "flash detected [FF84 or lower]"}
				}
				fnRecord(num, title, hash, bool)
			}
		} else {
			fnRecord(num, title, e.name, zB0)
		}
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_stacklength(num1, num2, num3) {
	let level = 0, test1 = 0
	function recurse() {
		level++
		recurse()
	}
	try {
		recurse()
	} catch(e) {
		test1 = level
	}
	level = 0
	try {
		recurse()
	} catch(e) {
		// columnNumber
		let strCN = "[columnNumber] error", errCN = false
		try {
			if (bBlock) {bB = 1}
			let resCN = e.columnNumber
			let testCN = resCN == undefined? false : true
			fnRecord(num1, strCN, resCN, testCN)
		} catch(n) {
			fnRecord(num1, strCN, n.name, zB0, n.message)
		}
		// fileName
		let strFN = "[fileName] error", errFN = false
		try {
			if (bBlock) {bB = 1}
			let resFN = e.fileName
			if (resFN !== undefined) {resFN = resFN.slice(0,8) + "..."}
			let testFN = resFN == undefined? false : true
			fnRecord(num1+1, strFN, resFN, testFN)
		} catch(n) {
			fnRecord(num1+1, strFN, n.name, zB0, n.message)
		}
		// lineNumber
		let strLN = "[lineNumber] error", errLN = false
		try {
			if (bBlock) {bB = 1}
			let resLN = e.lineNumber
			let testLN = resLN == undefined? false : true
			fnRecord(num1+2, strLN, resLN, testLN)
		} catch(n) {
			fnRecord(num1+2, strLN, n.name, zB0, n.message)
		}
		// first error
		let strRE = "error", resRE = e.name +": "+ e.message
		if (resRE == "InternalError: too much recursion") {
			fnRecord(num3, strRE, resRE, true)
		} else {
			fnRecord(num3, strRE, resRE, false)
		}
		// stack length
		let strSL = "stack length"
		try {
			if (bBlock) {bB = 1}
			let resSL = e.stack.toString().length
			let testSL = resSL == 8192 ? true : false
			if (isFile) {
				fnRecord(num2, strSL, zNA +": file://", zNA)
			} else {
				fnRecord(num2, strSL, resSL, testSL)
			}
		} catch(n) {
			fnRecord(num2, strSL, n.name, zB0, n.message)
		}
	}
}

function get_storage_estimate(num, title) {

	// Notes: Win10 VM is  52gb / 33gb spare | FF is always the same in PB mode
		//   2147483648 : FF57-96 Windows / Android / Win 10 VM FF60-96
	/*
	FF97+ is not stable enough: see https://bugzilla.mozilla.org/show_bug.cgi?id=1735713
   10737418240 : Windows, vannTenn's + bashonly's Linux, Android Fabrizio 100gb spare from 128gb
    5641604300 : Android Fabrizio 49gb spare from 64gb
    5512729395 : Android Thorin 44gb spare from 64gb
    5301081292 : Android bashonly 40gb spare from 64gb
    5256596684 : Win 10 VM 33gb spare from 52gb
    2934867968 : Debian XCFE 2glops 650gb spare from 1TB
    1521166745 : Ubuntu VM Fabrizio with 15GB of storage
    1177328025 : Android aleyvo 1.5gb spare from 16gb
	*/

	// other: who cares if they match
		// brave:     2147483648 (same in incognito and Tor window)
		// opera:      310418104 normal
		// opera:      521917312 private
		// chrome: 1200238045593 normal
		// chrome:   33076376370 normal android
		// chrome:     485041940 incognito
		// chrome:     204974075 incognito android

	// ToDo: check if FF97+ new storage quota is based on disk or free disk space size
	try {
		if (bBlock) {bB = 1}
		navigator.storage.estimate().then(estimate => {
			let quota = estimate.quota,
				bool = false
			if (isVer > 96) {
				bool = zNA
				quota = zNA +": variable in FF97+ "+ s3 +"["+ quota +"]"+ sc
			} else {
				if (quota > 2147000000 && quota < 2148000000) {bool = true}
			}
			fnRecord(num, title, quota, bool)
		})
	} catch(e) {
		let msg = e.message.substring(0,26)
		if (isWebkit && e.name == "TypeError" && msg == "undefined is not an object") {
			fnRecord(num, title, e.name, false, e.message)
		} else {
			// FF56 or lower
			let result = e.name
			let type = zB0
			let error = e.message
			if (isFF && isVer < 59 && e.message == "navigator.storage is undefined") {
				result = zNA +": FF57+ required"
				type = zNA
				error = undefined
			}
			fnRecord(num, title, result, type, error)
		}
	}
}

function get_window_chrome(num, title) {
	try {
		if (bBlock) {bB = 1}
		let bool = "chrome" in window
		fnRecord(num, title, bool, !bool)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_window_values(num) {
	//window.offscreenBuffering
	let strB = "[offscreenBuffering] window", boolB = false
	try {
		if (bBlock) {bB = 1}
		let resB = window.offscreenBuffering
		if (resB == undefined) {boolB = true}
		resB = fnClean(resB)
		fnRecord(num, strB, resB, boolB)
	} catch(e) {
		fnRecord(num, strB, e.name, zB0, e.message)
	}
	// window.openDatabase
	let strO = "[openDatabase] window", boolO = false
	try {
		if (bBlock) {bB = 1}
		window.openDatabase("test", "1.0", "test", 1024)
		fnRecord(num+2, strO, "success", boolO)
	} catch(e) {
		if (e.name == "TypeError" && e.message == "window.openDatabase is not a function") {
			fnRecord(num+2, strO, e.name, true, e.message)
		} else if (e.name == "UnknownError" && e.message == "Web SQL is deprecated") {
			fnRecord(num+2, strO, e.name, false, e.message) // webkit
		} else {
			fnRecord(num+2, strO, e.name, zB0, e.message)
		}
	}
}

function get_window_moz(num) {
	let strA = "[mozInnerScreenX] window", boolA = false
	try {
		if (bBlock) {bB = 1}
		let resA = window.mozInnerScreenX
		if (!isNaN(resA)) {boolA = true} else {resA = fnClean(resA)}
		fnRecord(num, strA, resA, boolA)
	} catch(e) {
		fnRecord(num, strA, e.name, zB0, e.message)
	}
	let strB = "[mozInnerScreenY] window", boolB = false
	try {
		if (bBlock) {bB = 1}
		let resB = window.mozInnerScreenY
		if (!isNaN(resB)) {boolB = true} else {resB = fnClean(resB)}
		fnRecord(num+1, strB, resB, boolB)
	} catch(e) {
		fnRecord(num+1, strB, e.name, zB0, e.message)
	}
}

let results = [],
	itemnumbers = [],
	data = {},
	count = 0,
	expected = 76,
	bBlock = false, // throw a test error
	bLog = false,
	bNum = false // display numbering

let	isVer = "",
	topVer = "",
	minVer = "",
	isRFP56plus = false,
	isWebkit = false,
	is95 = false

function get_is95() {
	return new Promise(resolve => {
		if (!isFF) {
			return resolve()
		}
		// pre-compute slow 95 test
		if ("function" === typeof self.structuredClone && "function" !== typeof crypto.randomUUID) {
			// ^ do if 94+ but not 95+ fast path
			try {
				if ("sc" !== Intl.PluralRules.supportedLocalesOf("sc").join()) {
					// but not if 96+
					let ratio = dom.test95a.offsetWidth/dom.test95b.offsetWidth
					is95 = (ratio > 0.4 && ratio < 0.6)
				}
			} catch(e) {
				console.debug(e.name, e.message)
			}
		}
		return resolve(is95)
	})
}

function get_isVer() {
	return new Promise(resolve => {
		// set webkit
		if ("chrome" in window || isFF) {} else {isWebkit = true}
		if (!isFF) {
			return resolve()
		}
		// set goanna
		if (isEngine == "gecko") {
			// check for PM28+ : fails 55 (1351795) but passes 57 (1378342)
				// note: waterfox classic passes both
			if ("undefined" !== typeof console.timeline && "function" === typeof AbortSignal) {
				isEngine = "goanna"
				// exit and return isVer as 52
				isVer = 52
				return resolve()
			}
		}
		// is55
		let is55 = false
		try {
			let maxIndex = Math.pow(2, 31)
			let list55 = []
			list55[maxIndex - 1] = 'a'
			list55[maxIndex - 0] = 'b'
			if (list55[maxIndex] !== 'b') {
			} else if (list55.slice()[maxIndex] !== 'b') {
			} else if (list55.slice(maxIndex - 1).length !== 2) {
			} else {
				is55 = true
			}
		} catch(e) {}

		isVer = cascade()
		return resolve()
		function cascade() {
			// FF52-59
			if ("function" !== typeof Animation.prototype.updatePlaybackRate) {
				if (!HTMLMediaElement.prototype.hasOwnProperty("mozAutoplayEnabled")) return 59
				if ("function" == typeof Intl.PluralRules) return 58
				if ("function" === typeof AbortSignal) return 57
				if (is55) {
					minVer = 56
					return 56
				} else {
					minVer = 54
					return 54
				}
			}
			// FF60+
			topVer = 104
			if (SVGStyleElement.prototype.hasOwnProperty("disabled")) return 104 // 1712623
			if (undefined === new ErrorEvent("error").error) return 103 // 1772494
			if (CanvasRenderingContext2D.prototype.hasOwnProperty("direction")) {
				if (Array(1).includes()) return 102 // 1767541: regression FF99
				return 101 // 1728999
			}
			if ("function" === typeof AbortSignal.timeout) return 100 // 1753309
			try {newFn("class A { #x; h(o) { return !#x in o; }}")} catch(e) {if (e.message.length == 72) return 99} // 1711715 + 1756204
			if (HTMLElement.prototype.hasOwnProperty("outerText")) return 98 // 1709790
			if ("function" === typeof AbortSignal.prototype.throwIfAborted) return 97 // 1745372
			if ("undefined" === typeof Object.toSource
				&& "sc" == Intl.PluralRules.supportedLocalesOf("sc").join()) return 96 // 1738422
				// ^ legacy perf: toSource (74+): FF68- very slow
			if ("function" === typeof crypto.randomUUID) return 95 // 1723674: fast path pref
			if (is95) return 95 // 1674204
				// ^ pre-computed
			if ("function" === typeof self.structuredClone) return 94 // 1722576
			if ("function" === typeof self.reportError) return 93 // 1722448
			if ("function" === typeof Object.hasOwn) return 92 // 1721149
			if ("object" === typeof window.clientInformation) return 91 // 1717072 fast path pref
			try {if ("sa" == Intl.Collator.supportedLocalesOf("sa").join()) return 91} catch(e) {} // 1714933
			if ("function" === typeof Array.prototype.at) return 90 // 1681371
			if ("function" === typeof CountQueuingStrategy
				&& ! new CountQueuingStrategy({highWaterMark: 1}).hasOwnProperty("highWaterMark")) return 89 // 1684316
				// ^ legacy check FF64- CountQueuingStrategy
			if (":" === document.createElement("a").protocol) return 88 // 1497557
			if (undefined === console.length) return 87 // 1688335
			if ("function" === typeof Intl.DisplayNames) return 86 // 1654116
			try {Object.getOwnPropertyDescriptor(RegExp.prototype, "global").get.call("/a")
				} catch(e) {if (e.message.length == 66) {return 85}} // 1675240
				// ^ replace ?
			if ("function" === typeof PerformancePaintTiming) return 84 // 1518999
			if (!window.HTMLIFrameElement.prototype.hasOwnProperty("allowPaymentRequest")) return 83 // 1665252
			try {if (1595289600000 === Date.parse('21 Jul 20 00:00:00 GMT')) {return 82}} catch(e) {} // 1655947
				// ^ ext fuckery: cydec
			if (new File(["x"], "a/b").name == "a/b") return 81 // 1650607
			if (CSS2Properties.prototype.hasOwnProperty("appearance")) return 80 // 1620467
			if ("function" === typeof Promise.any) return 79 // 1599769 shipped
			if (window.Document.prototype.hasOwnProperty("replaceChildren")) return 78 // 1626015
			if (window.IDBCursor.prototype.hasOwnProperty("request")) return 77 // 1536540
			if (!test76.validity.rangeOverflow) return 76 // 1608010
			if ("function" === typeof Intl.Locale) return 75 // 1613713
			if ("undefined" === typeof Object.toSource) return 74 // 1565170
			if (!VideoPlaybackQuality.prototype.hasOwnProperty("corruptedVideoFrames")) return 73 // 1602163
			if ("boolean" === typeof self.crossOriginIsolated) return 72 // 1591892
			if ("function" === typeof Promise.allSettled) return 71 // 1549176
			if ("function" === typeof Intl.RelativeTimeFormat
				&& "function" === typeof Intl.RelativeTimeFormat.prototype.formatToParts) return 70 // 1473229
				// ^ legacy check: FF64- Intl.RelativeTimeFormat
				// ^ extension fuckery: formatToParts
			try {newFn("let t = 1_050"); return 70} catch(e) {} // 1435818
			if ("function" === typeof Blob.prototype.text) return 69 // 1557121
			if (!HTMLObjectElement.prototype.hasOwnProperty("typeMustMatch")) return 68 // 1548773
			if ("function" === typeof String.prototype.matchAll) return 67 // 1531830
			if ("function" === typeof HTMLSlotElement
				&& "function" === typeof HTMLSlotElement.prototype.assignedElements) return 66 // 1425685
				// ^ legacy check: FF60- HTMLSlotElement
			if (1 === DataView.length) return 65 // 1334813
			if ("number" === typeof window.screenTop) return 64 // 1498860
			if ("desc" === Symbol('desc').description) return 63 // 1472170
			if ("function" === typeof console.timeLog) return 62 // 1458466
			if ("object" === typeof CSS) return 61 // 1455805
			return 60 // we already tested <60
		}
	})
}

function run() {
	// now get on with it
	fnRecord(0, "header", "expected")
	fnRecord(300, "header", "not expected")
	fnRecord(600, "header", "specific values")
	fnRecord(899, "hr")
	fnRecord(900, "header", "errors")
	fnRecord(440, "the spanish inquisition", "no one expects the spanish inquisition", true)
	// OK, let's kick some ass
	get_doc_values(10, "document")
	get_installtrigger(50) // 50-52
	get_canvaskeys(80, "[2d canvas] keys")
	get_moz_colors(90, "[colors] moz")
	get_moz_computed_styles(92, "[computed styles] moz")
	get_moz_fonts(95, "[fonts] moz")
	get_nav_screen(150)
	get_js_client_hints(320, "[js] client hints")
	get_nav_keys(85, 350, "[navigator] keys") // 85 expected, 350 not expected
	get_nav_values(100, 400, 720) // 100 expected, 400-410 not expected, 720.. specific
	get_window_moz(250) // 250-251
	get_iframe_props(40, 330, "[properties] iframe") // 40 expected, 330 not expected, 
	get_colorgamut(310, "[css] color-gamut"),
	get_mimetypes(370, "mimetypes")
	get_plugins(430, "plugins")
	get_window_chrome(450, "[chrome] window")
	get_window_values(460)
	get_dates(620)
	get_eval_length(630, "eval.toString().length")
	get_last_prototype_keys(640, "[last x keys]"), // 640+641
	get_intl_collator(650, "Intl.Collator")
	get_intl_dtf(656, "Intl.DateTimeFormat")
	get_intl_display_names(660, "Intl.DislayNames")
	get_intl_canonical_locale(662, "Intl.getCanonicalLocales")
	get_intl_list_format(663, "Intl.ListFormat")
	get_intl_number_format(666, "Intl.NumberFormat")
	get_intl_pluralrules(670, "Intl.PluralRules")
	get_intl_rtf(673, "Intl.RelativeTimeFormat")
	get_locale_compare(690, "locale.compare")
	get_math(695, "math")
	get_media_constraints(700, "[constraints] mediaDevices")
	get_permission(750, "[permissions] push")
	get_stacklength(30,800,901) // 30-32 error properties, 800 = stack length, 901 = first error message
	get_storage_estimate(820, "storage estimate")
	get_errors(902)
}


setTimeout(function() {
	if (isFF) {
		fnRFP()
	}
	Promise.all([
		get_is95(),
	]).then(function(){
		Promise.all([
			get_isVer(),
		]).then(function(){
			run()
		})
	})
}, 10)

</script>
</body>
</html>
