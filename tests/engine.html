<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=700">
	<title>engine</title>
	<link rel="stylesheet" type="text/css" href="testindex.css">
	<script src="testglobals.js"></script>
	<script src="testgeneric.js"></script>
	<style>
		table {width: 680px;}
		#tb3 td:first-child { text-align: left; vertical-align: top;}
	</style>
</head>

<body>
	<div class="offscreen">
		<div id="mozFont"></div>
		<div id="test95a" style="width: min-content; hyphens: auto; border: 1px solid red">2020-1</div>
		<div id="test95b" style="width: min-content; hyphens: auto; border: 1px solid red">2020-12020-1</div>
	</div>
	<div class="hidden">
		<div><input type="time" min="14:00:00" max="12:00:00" value="15:00:00" id="test76"></div>
		<span id="mozColor"></span>
	</div>

	<table>
	<tr><td><h2>TorZillaPrint</h2></td></tr>
	<tr><td class="blurb"><a class="return" href="../index.html#feature">return to TZP index</a></td></tr>
	</table>

	<table id="tb3">
		<col width="50%"><col width="50%">
		<thead><tr><th colspan="2">
			<div class="nav-title">engine
			<div class="nav-up"><span class="c perf" id="perf"></span></div>
			</div>
		</th></tr></thead>
		<tr><td colspan="2" class="intro">
			<span class="no_color">A tiny sample of the myriad ways engines differ. This test is tweaked
			for gecko [FF52+]: you want <span class="s9"><b> &#x2713; </b></span>'s. Anything different
			<span class="bad"><b> &#x2716; </b></span> or blocked <span class="s4"><b> &#x2715; </b></span>
			only makes you stand out. A single unspoofable property check can take as little as <span class="s3">0.01 ms</span>.
			</span>
		</td></tr>
		<tr><td colspan="2"><hr></td></tr>
		<tr><td colspan="2"><span class="no_color c mono spaces" id="results"></span></td></tr>
	</table>
	<br>

<script>
'use strict';

let results = [],
	itemnumbers = [],
	data = {},
	aPerf = [],
	count = 0,
	expected = 96,
	gt0, // global timer
	bBlock = false, // throw a test error
	bNum = false // display numbering instead of perf

function fnTrim(str, len) {
	str = str.replace(/(\r\n|\n|\r)/gm,"")
	if (str.length > len) {str = str.slice(0,len-3) +"..."}
	return str
}

function fnClean(str) {
	if (str == "") {str = "empty string"
	} else if (str === undefined) {str = zU
	} else if (str == zU) {str = zUQ}
	return str
}

function logPerf() {
	if (aPerf.length) {
		console.log("PERF LOG\n", aPerf)
	}
}

function fnDisplay() {
	// perf
	let perfValue = Math.round(performance.now() - gt0) +" ms"		
	let perfTop = perfValue
	// remove the first 5 items: section headers + hr
	if (aPerf.length) {
		perfTop = "<span style='cursor: pointer;' onClick='logPerf()'>" + perfTop +"</span>"
		aPerf.splice(0, 5)
	}
	dom.perf.innerHTML = perfTop

	// data -> ordered results
	const names = Object.keys(data).sort((a,b) => a-b)
	for (const k of names) {results.push(k +"~~~"+ data[k])}
	let display = [],
		errcount = 0
	let countTrue = 0, countFalse = 0, countBlock = 0, countNA = 0
	// check no numbers duplicated
	if (expected !== results.length) {
		display.push(sb+ "ERROR:"+ sc + " duplicate numbers detected<br>")
	}
	// parse for pretty output
	for (let i=0; i < results.length; i++) {
		let pad = 35
		let order = results[i].split("~~~")[0],
			desc = results[i].split("~~~")[1].trim(),
			result = results[i].split("~~~")[2],
			match = results[i].split("~~~")[3],
			perf = results[i].split("~~~")[4]
		if (perf == undefined || perf == "" || perf == "undefined") {perf = " - "
		} else if (perf !== "NaN") {
			perf = Math.round(perf)
			perf = perf.toString()
			perf = perf.padStart(2) +" "
		}

		if (desc == "header") {
			let note = ""
			if (result == "errors") {
				note = " [there are thousands of these]"
			}
			result = s14 + result.toUpperCase() + sc + note
			display.push("<span>"+ result + "</span><br>")
		} else if (desc == "hr") {
			display.push("<br><hr>")
		} else {
			if (match == zErr) {match = yellow_block; countBlock++
			} else if (match == "true") {match = green_tick; countTrue++
			} else if (match == "false") {match = red_cross; countFalse++
			} else {match = white_na; countNA++}
			match += " "
			if (desc == "error") {
				pad = 3; errcount++; desc = errcount.toString()
			}
			desc = s3 + desc.padStart(pad) + sc
			let sectionspace = ""
			if (i+1 < results.length) {
				let nextitem = results[i+1].split("~~~")[1].trim()
				if (nextitem == "header") {sectionspace = "<br>"}
			}
			desc += s99 +" "+ (bNum ? order : perf) + sc
			display.push(desc + match +" "+ result + sectionspace)
		}
	}
	// summary
	let countValid = countTrue + countFalse + countBlock // na tests ignored
	let countFail = countFalse + countBlock
	let percentPassed = Math.floor((countTrue/countValid)*100)
	let isPass = percentPassed == 100 ? true : false
	let percentFailed = Math.ceil((countFail/countValid)*100)
	let summary = ""
	if (isFFvalid) {
		let needStr = "... who needs "+ s3+ (expected - 5) + " tests" + sc
			+ " and "+ s3 + "several hundred metrics" + sc + " in "+ s3 + perfValue + sc + "?"
		summary += s14 +"MINI TESTS "+ sc + needStr +"<br><br>"
			+ "engine: "+ isEnginePretty.trim() +"<br><br>"
			+ " gecko: "+ isFFpretty.trim() +"<br><br><hr><br>"
	}
	summary += s14 +"SUMMARY "+ sc
		+"PASS: ".padStart(7) + countTrue + (isPass? sg : sb) +" ["+ percentPassed +"%]"+ sc
		+"FAIL: ".padStart(7) + countFail + (isPass? sg : sb) +" ["+ percentFailed +"%]"+ sc
	if (countNA > 0) {summary += "N/A: ".padStart(6) + countNA}
	if (isFF) {
		summary += s14+ "DEBUG".padStart(7) + sc
		let strVer = isVer
		strVer += (isVer == isVerMax ? "+" : "")
		strVer += (isVer == 52 ? " or lower" : "")
		summary += "VER: ".padStart(6) + strVer
	}
	summary += " " + buildButton(3, "all", "all details")
	// output
	dom.results.innerHTML = summary + "<br><br>" + display.join("<br>")
}

function fnRecord(order, description, result, match, error, perf) {
	if ("number" === typeof perf) {
		perf = performance.now() - perf
	}

	if (error !== undefined && error !== "skip") {
		let hash = mini(error)
		if (hash !== "d8281b3c") { // assignment to undeclared variable bB
			//console.error(order, result, error)
			hash = s3+ " ["+ hash +"]"+ sc
		} else {
			result = "test error thrown"; hash = ""
		}
		result += hash
	}
	aPerf.push([perf, order, description])
	order = (order+"").padStart(3,"0")
	data[order] = description +"~~~"+ result +"~~~"+ match + "~~~" + perf
	count ++
	itemnumbers.push(order +" "+ description)
	if (count == expected) {
		fnDisplay()
	}
	if (count > expected) {console.error(count, "expected count too low")}
}

function get_colorgamut(num, title) {
	// added in FF110+ 1422237
	let q = "(color-gamut: ", res = "undefined", bolC = false
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		if (window.matchMedia(q +"srgb)").matches) {res = "srgb"}
		if (window.matchMedia(q +"p3)").matches) {res = "p3"}
		if (window.matchMedia(q +"rec2020)").matches) {res = "rec2020"}
		let bool = res == "undefined"
		if (isVer > 109) {
			bool = zNA
			res = zNA +": FF109 or lower "+ s3 +"["+ res +"]"+ sc
		} else if (!isFF) {
			bool = zNA
			res += " [FF109 or lower]"
		}
		fnRecord(num, title, res, bool, "skip", t0)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_dates(num) {
	// 1274354: meta
	// 1557650
	let strA = "[5 digit year] new Date"
	try {
		let t0A = performance.now()
		if (bBlock) {bB = 1}
		let resA = new Date("19999-11-11")
		let bolA = resA == "Invalid Date" ? true : false
		if (!bolA) {resA = fnTrim(resA.toString(), 40)}
		if (isVer > 119) {
			bolA = zNA
			resA = zNA +": FF119 or lower " + s3 +"["+ fnTrim(resA.toString(), 23) +"]" + sc
		} else if (!isFF) {
			bolA = zNA
			resA += " [FF119 or lower]"
		}
		fnRecord(num, strA, resA, bolA, "skip", t0A)
	} catch(e) {
		fnRecord(num, strA, e.name, zErr, e.message)
	}
	// 1515318
	let strB = "[hyphen] new Date"
	try {
		let t0B = performance.now()
		if (bBlock) {bB = 1}
		let resB = new Date("31-Mar-2011").getFullYear()
		// FF: 63 and lower = NaN, 64+ = -2011
		let bolB = false
		if (resB == -2011) {bolB = true
		} else if (isVer < 64 && isNaN(resB)) {bolB = true
		} else if (isVer > 112 && resB == 2011) {
			bolB = zNA
			resB = zNA +": FF112 or lower " + s3 +"["+ resB+"]" + sc
		} else if (!isFF) {
			bolB = zNA
			resB += " [FF112 or lower]"
		}
		fnRecord(num+1, strB, resB, bolB, "skip", t0B)
	} catch(e) {
		fnRecord(num+1, strB, e.name, zErr, e.message)
	}
	// 1439800
	let strC = "[string] new Data"
	try {
		let t0C = performance.now()
		if (bBlock) {bB = 1}
		let resC = new Date("11-Nov-11")
		let bolC = resC.toString() == "Invalid Date" ? true : false
		if (!bolC) {
			if (isFF) {
				if (isVer > 112) {
					bolC = zNA
					resC = zNA +": FF112 or lower " + s3 +"["+ fnTrim(resC.toString(), 23) +"]"+sc
				} else {
					resC = fnTrim(resC.toString(), 40)
				}
			} else {
				bolC = zNA
				resC = fnTrim(resC.toString(), 22) +" [FF112 or lower]"
			}
		}
		fnRecord(num+2, strC, resC, bolC, "skip", t0C)
	} catch(e) {
		fnRecord(num+2, strC, e.name, zErr, e.message)
	}
	// 1599375
	let strD = "[+0000 UTC] Date.parse"
	try {
		let t0D = performance.now()
		if (bBlock) {bB = 1}
		let resD = Date.parse("2019-11-26 07:39:58.286157072 +0000 UTC")
		let bolD = ""
		if (isVer > 120) {
			bolD = zNA
			resD = zNA +": FF120 or lower " + s3 +"["+ fnTrim(resD.toString(), 23) +"]"+sc
		} else {
			bolD = isNaN(resD) ? true : false
		}
		fnRecord(num+3, strD, resD, bolD, "skip", t0D)
	} catch(e) {
		fnRecord(num+3, strD, e.name, zErr, e.message)
	}
	// 1730155
	let strE = "[localized] Date.parse"
	try {
		let t0E = performance.now()
		if (bBlock) {bB = 1}
		let resE = Date.parse("Mercredi 8 Septembre 2021")
		let bolE = ""
		if (isVer > 121) { // awaiting v122 test
			bolE = zNA
			resE = zNA +": FF121 or lower " + s3 +"["+ fnTrim(resE.toString(), 23) +"]"+sc
		} else {
			bolE = isNaN(resE) ? true : false
		}
		fnRecord(num+4, strE, resE, bolE, "skip", t0E)
	} catch(e) {
		fnRecord(num+4, strE, e.name, zErr, e.message)
	}
	// 1783731
	let strF = "[subtraction] Date.parse"
	try {
		let t0F = performance.now()
		if (bBlock) {bB = 1}
		let resF = Date.parse('2022-08-08') - Date.parse('2022-08-8')
		let bolF = ""
		if (isVer > 120) {
			bolF = zNA
			resF = zNA +": FF120 or lower " + s3 +"["+ fnTrim(resF.toString(), 23) +"]"+sc
		} else {
			bolF = resF == 0
		}
		fnRecord(num+6, strF, resF, bolF, "skip", t0F)
	} catch(e) {
		fnRecord(num+6, strF, e.name, zErr, e.message)
	}
}

function get_errors(num) {
	let tests = [
		["var a = {}; a.b = a; JSON.stringify(a)", "TypeError: cyclic object value"],
		["alert('A)","SyntaxError: '' string literal contains an unescaped line break"],
		["let a = 1_00_;","SyntaxError: underscore can appear only between digits, not after t...", // FF72+
			"SyntaxError: identifier starts immediately after numeric literal", // FF60-69
			"SyntaxError: missing digit after '_' numeric separator"], // FF70-71
		["const foo;foo.bar","SyntaxError: missing = in const declaration"],
		["null.bar","TypeError: can't access property \"bar\" of null","TypeError: null has no properties"],
		["(1).toString(1000)","RangeError: radix must be an integer at least 2 and no greater than 36"],
		["var x = new Array(-1)","RangeError: invalid array length"],
		["[...undefined].length","TypeError: can't access property Symbol.iterator of undefined","TypeError: undefined has no properties"],
		["const tzp=1; const tzp=2;","SyntaxError: redeclaration of const tzp"],
		["const foo;foo.bar","SyntaxError: missing = in const declaration"],
		["var x = @","SyntaxError: illegal character U+0040","SyntaxError: illegal character"],
	]
	tests.forEach(function(array) {
		let t0 = performance.now()
		try {
			newFn(array[0])
		} catch(e) {
			let bool = false
			let str = fnTrim(e.name +": "+ e.message, 70)
			if (isVer < 60 && array[0] == "alert('A)") {
				if (str == "SyntaxError: unterminated string literal") {bool = true}
			} else {
				if (str == array[1] || str == array[2] || str == array[3]) {bool = true}
			}
			fnRecord(num, "error", str, bool, "skip", t0)
			num++
		}
	})
}

function get_eval_length(num, title) {
	let bool = false
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		let test = eval.toString().length
		if (test == 37) {bool = true}
		fnRecord(num, title, test, bool, "skip", t0)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_iframe_props(num1, num2, title) {
	let t0 = performance.now()
	// just a small sample
	let listE = ['dump','fullScreen','getDefaultComputedStyle','mozInnerScreenX',
		'mozInnerScreenY','netscape','onmozfullscreenchange','onmozfullscreenerror']
	let listU = ['BatteryManager','HID','Keyboard','Lock','Serial',
		'USB','WakeLock','WebKitMutationObserver','XRAnchor','chrome','webkitCancelAnimationFrame',
		'webkitMediaStream','webkitRTCPeerConnection','webkitRequestAnimationFrame',
		'webkitRequestFileSystem','webkitResolveLocalFileSystemURL','webkitStorageInfo']
	// FYI: don't use MIDIAccess: FF60+ behind dom.webmidi.enabled... 1752906: FF99+ default enabled

	if (isVer > 121) { listU = listU.filter(x => !["WakeLock"].includes(x)) } // FF122+ dom.screenwakelock.enabled: 1589554
	if (isVer > 92) { listU = listU.filter(x => !["Lock"].includes(x)) } // FF93+ "dom.weblocks.enabled": 1739233: FF96+ Lock

	try {
		if (bBlock) {bB = 1}
		// create & append iframe
		let id = "iframe-window-version"
		let el = document.createElement("iframe")
		el.setAttribute("id", id)
		el.setAttribute('style', 'display: none')
		document.body.appendChild(el)
		// get props
		let iframe = document.getElementById(id)
		let contentWindow = iframe.contentWindow
		let props = Object.getOwnPropertyNames(contentWindow)
		// remove iframe
		iframe.parentNode.removeChild(iframe)
		props.sort()
		// expected
		let arrayE = props.filter(x => listE.includes(x))
		let resE = "", boolE = false
		if (arrayE.length) {
			sDetail["expected_"+ title] = arrayE
			resE = mini(arrayE) + buildButton(3, "expected_"+ title, arrayE.length)
			if (arrayE.length > 4) {boolE = true}
		} else {
			resE = "none"
		}
		// unexpected
		let arrayU = props.filter(x => listU.includes(x))
		// ignore BatteryManager FF72+
		if (isFF && isVer < 72) {arrayU = arrayU.filter(x => !["BatteryManager"].includes(x))}
		let resU = "", boolU = false
		if (arrayU.length) {
			sDetail["unexpected_"+ title] = arrayU
			resU = mini(arrayU) + buildButton(3, "unexpected_"+ title, arrayU.length)
		} else {
			resU = "none"
			boolU = true
		}
		// record
		fnRecord(num1, title, resE, boolE, "skip", t0)
		fnRecord(num2, title, resU, boolU, "skip", t0)
	} catch(e) {
		fnRecord(num1, title, e.name, zErr, e.message)
		fnRecord(num2, title, e.name, zErr, e.message)
	}
}

function get_installtrigger(num) {
	// FF100+: 1754441 behind prefs slated for deprecation
	let strA = "[typeof] InstallTrigger", boolA = false
	try {
		let t0A = performance.now()
		if (bBlock) {bB = 1}
		let resA = typeof InstallTrigger
		if (resA == "object") {boolA = true}
		if (isVer > 99 && !boolA) {
			fnRecord(num, strA, zNA +": FF99 or lower" + s3 +" ["+ resA +"]"+ sc, zNA, "skip", t0A)
		} else {
			if (!isFF) {resA += " [FF99 or lower]"; boolA = zNA}
			fnRecord(num, strA, resA, boolA, "skip", t0A)
		}
	} catch(e) {
		fnRecord(num, strA, e.name, zErr, e.message)
	}

	let strB = "[window] InstallTrigger", boolB = false
	try {
		let t0B = performance.now()
		if (bBlock) {bB = 1}
		let resB = "InstallTrigger" in window
		if (isVer > 99 && !resB) {
			fnRecord(num+1, strB, zNA +": FF99 or lower" + s3 +" ["+ resB +"]"+ sc, zNA, "skip", t0B)
		} else {
			if (!isFF) {resB += " [FF99 or lower]" }
			fnRecord(num+1, strB, resB, resB, "skip", t0B)
		}
	} catch(e) {
		fnRecord(num+1, strB, e.name, zErr, e.message)
	}

	let strC = "[typeof] InstallTriggerImpl", boolC = false
	// FF60 or lower
	if (isFF && isVer < 61) {
		fnRecord(num+2, strC, zNA +": FF61+ required", zNA)
	} else {
		try {
			let t0C = performance.now()
			if (bBlock) {bB = 1}
			let resC = typeof InstallTriggerImpl
			if (resC == "function") {boolC = true}
			if (isVer > 99 && !boolC) {
				fnRecord(num+2, strC, zNA +": FF99 or lower" + s3 +" ["+ resC +"]"+ sc, zNA, "skip", t0C)
			} else {
				if (!isFF) {resC += " [FF99 or lower]"; boolC = zNA }
				fnRecord(num+2, strC, resC, boolC, "skip", t0C)
			}
		} catch(e) {
			fnRecord(num+2, strC, e.name, zErr, e.message)
		}
	}
}

function get_intl_canonical_locale(num, title) {
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		let list = ['bh','hye','no','tl','tw'], bool = false
		let res = []
		list.forEach(function(i) {
			res.push(Intl.getCanonicalLocales(i))
		})
		let hash = res.length > 0 ? mini(res) : "none"
		if (hash == "df6e312d") {bool = true // FF91+
		} else if (hash == "6dc73a60") {bool = true // FF70-90
		} else if (hash == "0e0d831d") {bool = true // FF52-69
		}
		// FF60-69 : bh=bh,  hye=hye, no=no, tl=tl,  tw=tw
		// FF70-90 : bh=bho, hye=hy,  no=nb, tl=fil, tw=ak
		// FF91+   : bh=bho, hye=hy,  no=no, tl=fil, tw=ak // webkit now matches
		// blink   : bh=bh,  hye=hy,  no=no, tl=fil, tw=tw
		// webkit  : bh=bh,  hye=hy,  no=no, tl=tl,  tw=tw
		if (res.length > 0) {
			if (res.join(", ").length < 48) {
				hash = res.join(", ")
			} else {
				sDetail["specific_"+ title] = res
				hash += buildButton(3, "specific_"+ title, "details")
			}
		}
		fnRecord(num, title, hash, bool, "skip", t0)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_intl_supportedlocales(num) {
	// DTF, NF, RTF, LF, DN
	/* NOTES
	// FF52+ common items (130) not in blink103 common (59) = 71 items
		// FF52: DTF + NF / FF65: RTF / FF78: LF / FF86: DN
		// remove if present: bh bho, hye hy, no nb, tl fil, tw ak [aliases/maps]
	geckoNotBlink = [
		// mix it up per test
		'eo','gl','ka','mt','om', // used in C
			// from collator list below that is in common with this list
			// ^ note mt only added if .compare works

		'ki','lu','qu','rn','rw', // used in PR (limited choices)
		'as','fo','ln','ne','to', // used in DTF
		'br','eu','ii','ks','ps', // used in DN
		'ee','gd','kk','lo','yi', // used in LF
		'bo','ha','lb','my','sq', // used in NF
		'cy','km','mg','os','sn', // used in RTF
		// 35 spare
		'ast','be','bm','ce','ckb','dsb','dz','ff','fur','fy',
		'ga','gv','haw','hsb','ig','is','kab','kl','kok','kw',
		'ky','lg','mk','mn','nd','nn','or','rm','se','sg','si',
		'so','ti','ug','yo','zu'
	]
	// webkit items not in FF105
		// note: older webkit only: make sure one in each: 'co','cv','oc','nso','tig'
	WKnotGecko = [
		'ba','co','dv','gn','io','iu','nr','nso','nv','ny','oc','ss','st','tig','tn','ts','ve','wa'
		// 'cv' // cv is supported in FF109+
	]
	*/
	// COLLATOR
	/*
	geckoNotBlink = [
		'as','az','be','bo','bs','cy','dsb','dz','ee','eo','fo','ga','gl',
		'ha','haw','hsb','ig','is','ka','kk','kl','km','kok','ky','lb',
		'ln','lo','mk','mn','mt','my','ne','nn','om','or','pa','ps','se',
		'si','sq','to','ug','uz','yi','yo','zu'
	]
	webkit = same as gecko 91+
	old_list = [
		'az','cy','dsb','ee','eo','gl','ha','haw','hsb','ig',
		'ka','kk','ln','lo','mt','om','pa','se','sq','to',
	]
	*/
	// PR
	/*
		 FF52+  geckoNotBlink = ['ki','kok','lu','qu','rn','rw']
		FF105-  blinkNotGecko = ['an','dv','io','iu','lij','nr','nso','ny','ss','st','tig','tn','ts','ve','vo','wa']
		FF105- webkitNotGecko = ['ba','co','cv','dv','gn','io','iu','nr','nso','nv','ny','oc','ss','st','tig','tn','ts','ve','wa']
		therefore
		blinkOnly = ['an','lij','vo']
		webkitOnly = ['ba',co','cv',''gn','ny','oc']
		let list = [
			'ki','lu','qu','rn','rw', // gecko: pick 5
			'ba','co','cv','gn','oc', // webkit only: pick 4
			'an','lij','vo', // chrome only: not needed
		]
	*/
	let oList = {
		'Collator': {errVer: 50, expected: 'f7e01839', list: ['eo','gl','ka','om']},
		'DateTimeFormat': {errVer: 50, expected: '2d45bfd6', list: ['as','fo','ln','ne','to', 'co','nr','st','tig']},
		'DisplayNames': {errVer: 86, expected: '502f87c2', list: ['br','eu','ii','ks','ps','gn','iu','nv','tn']},
		'ListFormat': {errVer: 78, expected: 'a2d97917', list: ['ee','gd','kk','lo','yi','ba','io','oc','ve']},
		'NumberFormat': {errVer: 50, expected: '3709a703', list: ['bo','ha','lb','my','sq','dv','ny','oc','ts']},
		'PluralRules': {errVer: 58, expected: '73b49209', list: ['ki','lu','qu','rn','rw','ba','co','gn','oc']},
		'RelativeTimeFormat': {errVer: 65, expected: 'fc7fa0cc', list: ['cy','km','mg','os','sn','gn','nso','ss','wa']},
	}
	let control = (['c','C']).sort(Intl.Collator('mt').compare)
	if (control.join('') == 'Cc') {oList['Collator']['list'].push('mt')}

	if (isVer > 133) {
		oList.DateTimeFormat.expected = 'd240302d'
		oList.DisplayNames.expected = 'ccf106a6'
		oList.ListFormat.expected = '52f07243'
		oList.NumberFormat.expected = '741aaeb3'
		oList.PluralRules.expected = '2d5fb02b'
		oList.RelativeTimeFormat.expected = '98ac597e'
	}

	num = (num - 5)
	for (const type of Object.keys(oList)) {
		num += 5
		let t0 = performance.now(), res = [], title = "Intl."+ type
		let errVer = oList[type].errVer,
			expected = oList[type].expected,
			list = oList[type].list.sort()

		try {
			if (bBlock) {bB = 1}
			if (type == "Collator") { res = Intl.Collator.supportedLocalesOf(list)
			} else if (type == "DateTimeFormat") { res = Intl.DateTimeFormat.supportedLocalesOf(list)
			} else if (type == "DisplayNames") { res = Intl.DisplayNames.supportedLocalesOf(list)
			} else if (type == "ListFormat") { res = Intl.ListFormat.supportedLocalesOf(list)
			} else if (type == "NumberFormat") { res = Intl.NumberFormat.supportedLocalesOf(list)
			} else if (type == "PluralRules") { res = Intl.PluralRules.supportedLocalesOf(list)
			} else if (type == "RelativeTimeFormat") { res = Intl.RelativeTimeFormat.supportedLocalesOf(list)
			}
			let hash = res.length > 0 ? mini(res) : "none"
			//console.log(title, hash)
			let bool = hash == expected
			if (res.length > 0) {
				if (res.join(", ").length < 48) {
					hash = res.join(", ")
				} else {
					sDetail["specific_"+ title] = res
					hash += buildButton(3, "specific_"+ title, res.length)
				}
			}
			fnRecord(num, title, hash, bool, "skip", t0)
		} catch(e) {
			if (isFF) {
				if (isVer >= errVer) {
					fnRecord(num, title, e.name, zErr, e.message)
				} else {
					let msg = e.message
					msg = msg.replace("can't access property \"supportedLocalesOf\", ", "") // trim *error_fix
					if (e.name == "TypeError" && msg == "Intl." + type +" is undefined") {
						fnRecord(num, title, zNA +": FF" + errVer +"+ required", zNA)
					} else {
						fnRecord(num, title, e.name, zErr, e.message)
					}
				}
			} else {
				fnRecord(num, title, zNA +": not supported", zNA)
			}
		}
	}
}

function get_intl_supportedvaluesof(num, title) {
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		let aSupported = Intl.supportedValuesOf("timeZone")
		let aExpected = ['CET','EET','EST','HST','MET','MST','WET',] // b7a58624
		let res = aSupported.filter(x => aExpected.includes(x))

		let hash = res.length > 0 ? mini(res) : "none"
		let bool = hash == "b7a58624"

		if (res.length > 0) {
			if (res.join(", ").length < 48) {
				hash = res.join(", ")
			} else {
				sDetail["specific_"+ title] = res
				hash += buildButton(3, "specific_"+ title, res.length)
			}
		}
		if (isVer > 134) {
			bool = zNA
			hash = zNA +": FF109 or lower "+ s3 +"["+ hash +"]"+ sc
		} else if (!isFF) {
			bool = zNA
			hash += " [FF109 or lower]"
		}
		fnRecord(num, title, hash, bool, "skip", t0)
		//fnRecord(num, title, hash, bool, "skip", t0)

	} catch(e) {
		// FF92- not supported
		if (isVer < 93) {
			fnRecord(num, title, zNA +": not supported", zNA)
		} else {
			fnRecord(num, title, e.name, zErr, e.message)
		}
	}
}


function get_js_client_hints(num, title) {
	// testing: https://web.dev/user-agent-client-hints/
	// https://user-agent-client-hints.glitch.me/javascript.html
	// TypeError can't access property "X", navigator.X is undefined
	function output() {
		if (res.length > 0) {
			res.sort()
			sDetail["unexpected_"+ title] = res
			let hash = mini(res) + buildButton(3, "unexpected_"+ title , res.length)
			fnRecord(num, title, hash, false, "skip", t0)
		} else {
			fnRecord(num, title, "none", true, "skip", t0)
		}
	}
	let res = []
	let t0 = performance.now()

	try {
		let resB = navigator.userAgentData.brands
		resB.forEach(function(object) {
			let valueB = fnClean(object.version)
			res.push("brands: "+ object.brand +": "+ valueB)
		})
	} catch(e) {}
	try {
		res.push("mobile: " + navigator.userAgentData.mobile)
	} catch(e) {}
	try {
		res.push("platform: " + navigator.userAgentData.platform)
	} catch(e) {}
	try {
		navigator
			.userAgentData.getHighEntropyValues(
				["architecture","bitness","brands","mobile","model","platform","platformVersion","uaFullVersion"]
			).then(ua => {
				const names = Object.keys(ua)
				for (const k of names) {
					let valueU = fnClean(ua[k])
					res.push("high entropy: "+ k +": "+ valueU)
				}
				output()
			})
	} catch(e) {
		output()
	}
}

function get_last_prototype_keys(num1, title) {
	// HTMLAnchorElement
	let title1 = title +" HTMLAnchorElement"
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		Object.keys(HTMLAnchorElement.prototype)
		let props1 = Object.getOwnPropertyNames(HTMLAnchorElement.prototype) // includes the constructor
		let res1 = props1.slice(-3).join(", ")
		// search, hash, constructor
		fnRecord(num1, title1, res1, res1 == "search, hash, constructor", "skip", t0)
	} catch(e) {
		fnRecord(num1, title1, e.name, zErr, e.message)
	}

	// HTMLLinkElement
	let title2 = title +" HTMLLinkElement"
	let num2 = num1 + 1
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		Object.keys(HTMLLinkElement.prototype)
		let props2 = Object.getOwnPropertyNames(HTMLLinkElement.prototype) // includes the constructor
		let res2 = props2.slice(-3).join(", ")
		let bool2 = res2 == "as, sheet, constructor"
		// 52-55: integrity, sheet, constructor
		if (isVer <= 56 && res2 == "integrity, sheet, constructor") {bool2 = true}
		fnRecord(num2, title2, res2, bool2, "skip", t0)
	} catch(e) {
		fnRecord(num2, title2, e.name, zErr, e.message)
	}
}

function get_locale_compare(num, title) {
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		let list = [
			["cy","n","ng"],
			["gl","\u00F1","ng"],
			["ha","ts","tt"],
			["hsb","\u0107","\u0109"],
			["ig","c","ch"],
			["ka","\u0107","\u10D0"],
			["mt","c","C"], // MAC: Intl.Collator supportedlocale but does not collate it
			["om","ch","\u00ED"],
			["sq","\u00EB","ez"],
			["to","\u00ED","\u00EE"],
		]
		let res = []
		list.forEach(function(item) {
			res.push(item[1].localeCompare(item[2], item[0]))
		})
		let hash = res.length > 0 ? mini(res) : "none"
		let bool = hash == "2e086db5"
		if (res.length > 0) {
			hash = res.join(", ")
		}
		fnRecord(num, title, hash, bool, "skip", t0)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_math(num, title) {
	// polyfill
	function cbrt(x) {
		try {
			let y = Math.pow(Math.abs(x), 1 / 3)
			return x < 0 ? -y : y
		} catch(e) {
			return "error"
		}
	}
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		let res = []
		for(let i=0; i < 6; i++) {
			try {
				let fnResult = "unknown"
				if (i == 0) {fnResult = cbrt(Math.PI) // polyfill
				} else if (i == 1) {fnResult = Math.log10(7*Math.LOG10E)
				} else if (i == 2) {fnResult = Math.log10(2*Math.SQRT1_2)
				} else if (i == 3) {fnResult = Math.acos(0.123)
				} else if (i == 4) {fnResult = Math.acosh(Math.SQRT2)
				} else if (i == 5) {fnResult = Math.atan(2)
				}
				res.push(fnResult)
			} catch(e) {
				res.push("error")
			}
		}
		// I have to use sha1 due to legacy data
		let hash = sha1(res.join()).substring(0,20)
		let engine = "unkown"
		if (hash == "ede9ca53efbb1902cc21") {engine = "blink"
		} else if (hash == "05513f36d87dd78af60a") {engine = "webkit"
		} else if (hash == "38172d9426d77af71baa") {engine = "edgeHTML"
		} else if (hash == "36f067c652c8cfd90725") {engine = "trident"
		} else if (hash == "225f4a612fdca4065043") {engine = "gecko"
		} else if (hash == "cb89002a8d6fabf859f6") {engine = "gecko"
		}
		let bool = engine == "gecko" ? true : false
		// now redo as mini
		sDetail["expected_"+ title] = res
		hash = mini(res) + buildButton(3, "expected_"+ title, engine)
		fnRecord(num, title, hash, bool, "skip", t0)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_media_constraints(num, title) {
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		let noiseFF = [
			'groupId', // FF70+
			'channelCount', // FF56+
			'autoGainControl','noiseSuppression', // FF55+
			'mozAutoGainControl','mozNoiseSuppression', // FF54-
			'resizeMode', // FF144+
		]
		let data = navigator.mediaDevices.getSupportedConstraints()
		let res = Object.keys(data)
		res = res.filter(x => !noiseFF.includes(x))
		res.sort()
		let hash = res.length > 0 ? mini(res) : "none"
		let bool = hash == "27fb15ca" // FF52+
		if (res.length > 0) {
			sDetail["expected_"+ title] = res
			hash += buildButton(3, "expected_"+ title, res.length)
		}
		fnRecord(num, title, hash, bool, "skip", t0)
	} catch(e) {
		// e.g. TB disables mediaDevices
		let error = mini(e.name +": "+ e.message), isNA = false
		if (error == "f2244861") {
			// TypeError: can't access property "getSupportedConstraints", navigator.mediaDevices is undefined
			isNA = true
		} else if (error == "9fc627cf") {
			// TypeError: navigator.mediaDevices is undefined
			isNA = true
		}
		if (isNA) {
			fnRecord(num, title, zNA +": disabled", zNA)
		} else {
			fnRecord(num, title, e.name, zErr, e.message)
		}
	}
}

function get_mimetypes(num, title) {
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		if ("mimeTypes" in navigator) {
			let res = [], bool = false
			let m = navigator.mimeTypes
			if (m.length == 0) {
				fnRecord(num, title, "none", true, "skip", t0)
			} else {
				for (let i=0; i < m.length; i++) {
					res.push( m[i].type + (m[i].description == "" ? ": * " : ": "+ m[i].type)
						+ (m[i].suffixes == "" ? ": *" : ": "+ m[i].suffixes) )
				}
				res.sort()
				// FF84 or lower allow just Flash
				if (isFF && isVer < 85 && res.length == 2) {
					let mime1 = res[0].split(":")[0]
					let mime2 = res[1].split(":")[0]
					if (mime1 == "application/x-futuresplash" && mime2 == "application/x-shockwave-flash") {
						bool = true
					}
				}
				let hash = mini(res)
				if (isVer > 98 || !isFF) { // allow non-FF to have the same
					// FF99+: controlled by pdfjs.disabled
					// 1720353: hardcoded mimeTypes
					if (hash == "d63af80f") {bool = true}
				}
				sDetail["expected_"+ title] = res
				hash += buildButton(3, "expected_"+ title, res.length)
				fnRecord(num, title, hash, bool, "skip", t0)
			}
		} else {
			fnRecord(num, title, e.name, zErr)
		}
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_moz_colors(num, title) {
	let aList = [
		// css4
		'-moz-activehyperlinktext','-moz-default-color','-moz-default-background-color','-moz-hyperlinktext','-moz-visitedhyperlinktext',
		// stand-ins
		'-moz-buttondefault','-moz-buttonhoverface','-moz-buttonhovertext','-moz-cellhighlight','-moz-cellhighlighttext','-moz-combobox','-moz-comboboxtext','-moz-dialog','-moz-dialogtext','-moz-dragtargetzone','-moz-eventreerow','-moz-field','-moz-fieldtext','-moz-html-cellhighlight','-moz-html-cellhighlighttext','-moz-mac-chrome-active','-moz-mac-chrome-inactive','-moz-mac-disabledtoolbartext','-moz-mac-focusring','-moz-mac-menuselect','-moz-mac-menushadow','-moz-mac-menutextdisable','-moz-mac-menutextselect','-moz-mac-secondaryhighlight','-moz-menubarhovertext','-moz-menubartext','-moz-menuhover','-moz-menuhovertext','-moz-nativehyperlinktext','-moz-oddtreerow','-moz-win-communicationstext','-moz-win-mediatext',
		// moz
		'-moz-accent-color','-moz-accent-color-foreground','-moz-appearance','-moz-colheaderhovertext','-moz-colheadertext','-moz-gtk-buttonactivetext','-moz-gtk-info-bar-text','-moz-mac-accentdarkestshadow','-moz-mac-accentdarkshadow','-moz-mac-accentface','-moz-mac-accentlightesthighlight','-moz-mac-accentlightshadow','-moz-mac-accentregularhighlight','-moz-mac-accentregularshadow','-moz-mac-active-menuitem','-moz-mac-active-source-list-selection','-moz-mac-buttonactivetext','-moz-mac-defaultbuttontext','-moz-mac-menuitem','-moz-mac-menupopup','-moz-mac-source-list','-moz-mac-source-list-selection','-moz-mac-tooltip','-moz-mac-vibrancy-dark','-moz-mac-vibrancy-light','-moz-mac-vibrant-titlebar-dark','-moz-mac-vibrant-titlebar-light','-moz-win-accentcolor','-moz-win-accentcolortext','-moz-win-communications-toolbox','-moz-win-media-toolbox',
	]
	aList.sort()
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		let aRes = []
		let element = dom.mozColor
		let strColor = "rgba(1, 2, 3, 0.5)"
		aList.forEach(function(style) {
			element.style.backgroundColor = strColor // always reset
			element.style.backgroundColor = style
			let rgb = window.getComputedStyle(element, null).getPropertyValue("background-color")
			if (rgb !== strColor) {
				aRes.push(style +":"+ rgb) // only record those affected
			}
		})
		let bool = aRes.length > 0
		if (bool) {
			sDetail["expected_"+ title] = aRes
		}
		let hash = bool ? mini(aRes) + buildButton(3, "expected_"+ title, aRes.length) : "none"
		fnRecord(num, title, hash, bool, "skip", t0)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_moz_fonts(num, title) {
	let aResults = [],
		m = "-moz-",
		aFonts = [m+"window",m+"desktop",m+"document",m+"workspace",m+"info",m+"pull-down-menu",m+"dialog",m+"button",m+"list",m+"field"]
	try {
		let t0 = performance.now()
		let el = dom.mozFont
		if (bBlock) {bB = 1}
		aFonts.forEach(function(font){
			// catch blocked
			let test = getComputedStyle(el).getPropertyValue("font-family")
			el.style.font = "99px sans-serif"
			try {el.style.font = font} catch(err) {}
			let s = ""
			if (window.getComputedStyle) {
				try {
					s = getComputedStyle(el, null)
				} catch(e) {}
			}
			if (s !== "") {
				let f = s.fontSize != "99px" ? s.fontFamily : undefined
				if (f !== undefined) {aResults.push(f)}
			}
		})
		let bool = aResults.length > 0
		if (bool) {
			sDetail["expected_"+ title] = aResults
		}
		let hash = bool ? mini(aResults) + buildButton(3, "expected_"+ title, aResults.length) : "none"
		if (isVer > 108) {
			bool = zNA; hash = zNA +": FF108 or lower" // 1802957
		}
		if (!isFF) {hash += " [FF108 or lower]"; bool = zNA}
		fnRecord(num, title, hash, bool, "skip", t0)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_moz_objects(num, name) {
	let title = "["+ name +"] moz"
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		let res = []
		let oList = {}
		let isObj = false
		let useHas = false // use hasOwnProperty or default getOwnPropertyDescriptor

		if (name === "Document" && "function" === typeof Document) {
			oList[name] = [Document.prototype,
				["mozSetImageElement","mozCancelFullScreen","mozFullScreen","mozFullScreenEnabled",
					"mozFullScreenElement","onmozfullscreenchange","onmozfullscreenerror"]
				]
		}
		if (name === "HTMLElement" && "function" === typeof HTMLElement) {
			oList[name] = [HTMLElement.prototype, ["onmozfullscreenchange","onmozfullscreenerror"]]
		}
		if (name === "HTMLMediaElement" && "function" === typeof HTMLMediaElement) {
			oList[name] = [HTMLMediaElement.prototype, ["mozCaptureStream","mozCaptureStreamUntilEnded",
				"mozGetMetadata","mozPreservesPitch","mozAudioCaptured","mozFragmentEnd"]
			]
		}
		if (name === "HTMLVideoElement" && "function" === typeof HTMLVideoElement) {
			oList[name] = [HTMLVideoElement.prototype, ["mozParsedFrames","mozDecodedFrames",
				"mozPresentedFrames","mozPaintedFrames","mozFrameDelay","mozHasAudio"]
			]
		}
		if (name === "MouseEvent" && "function" === typeof MouseEvent) {
			oList[name] = [MouseEvent.prototype,
				["MOZ_SOURCE_UNKNOWN","MOZ_SOURCE_MOUSE","MOZ_SOURCE_PEN","MOZ_SOURCE_ERASER",
				"MOZ_SOURCE_CURSOR","MOZ_SOURCE_TOUCH","MOZ_SOURCE_KEYBOARD","mozPressure",
				"mozInputSource","MOZ_SOURCE_UNKNOWN","MOZ_SOURCE_MOUSE","MOZ_SOURCE_PEN",
				"MOZ_SOURCE_ERASER","MOZ_SOURCE_CURSOR","MOZ_SOURCE_TOUCH","MOZ_SOURCE_KEYBOARD"]
			]
		}
		if (name === "Screen" && "function" === typeof Screen) {
			oList[name] = [Screen.prototype,
				["mozLockOrientation","mozUnlockOrientation","mozOrientation","onmozorientationchange"]
			]
		}
		if (name === "SVGElement" && "function" === typeof SVGElement) {
			oList[name] = [SVGElement.prototype,["onmozfullscreenchange","onmozfullscreenerror"]]
		}
		if (name === "HTMLInputElement" && "function" === typeof HTMLInputElement) {
			oList[name] = [HTMLInputElement.prototype,["mozIsTextField"]]
		}
		if (name === "Navigator" && "function" === typeof Navigator) {
			oList[name] = [Navigator.prototype,["mozGetUserMedia"]]
		}
		if (name === "HTMLCanvasElement" && "function" === typeof HTMLCanvasElement) {
			oList[name] = [HTMLCanvasElement.prototype,["mozOpaque","mozPrintCallback"]]
		}
		if (name === "CanvasRenderingContext2D" && "function" === typeof CanvasRenderingContext2D) {
			oList[name] = [CanvasRenderingContext2D.prototype,
				["mozCurrentTransform","mozCurrentTransformInverse","mozTextStyle","mozImageSmoothingEnabled"]
			]
		}
		if (name === "MathMLElement" && "function" === typeof MathMLElement) {
			oList[name] = [MathMLElement.prototype,["onmozfullscreenchange","onmozfullscreenerror"]]
		}
		if (name === "DataTransfer" && "function" === typeof DataTransfer) {
			oList[name] = [DataTransfer.prototype,["mozCursor","mozUserCancelled","mozSourceNode"]]
		}
		if (name === "ShadowRoot" && "function" === typeof ShadowRoot) {
			oList[name] = [ShadowRoot.prototype,["mozFullScreenElement"]]
		}
		if (name === "XMLHttpRequest" && "function" === typeof XMLHttpRequest) {
			oList[name] = [XMLHttpRequest.prototype,["mozAnon","mozSystem"]]
		}
		if (name === "IDBObjectStore" && "function" === typeof IDBObjectStore) {
			oList[name] = [IDBObjectStore.prototype,["mozGetAll"]]
		}
		if (name === "IDBIndex" && "function" === typeof IDBIndex) {
			oList[name] = [IDBIndex.prototype,["mozGetAll","mozGetAllKeys"]]
		}
		if (name === "OfflineResourceList" && "function" === typeof OfflineResourceList) {
			oList[name] = [OfflineResourceList.prototype,
				["mozHasItem","mozItem","mozAdd","mozRemove","mozItems","mozLength"]
			]
		}
		if (name === "Element" && "function" === typeof Element) {
			useHas = true
			oList[name] = [Element.prototype,["mozMatchesSelector","â€‹mozRequestFullScreen"]]
		}
		if (name === "CSS2|CSSStyle") {
			let source
			if ("function" === typeof CSS2Properties) {
				source = CSS2Properties
				title = "[CSS2Properties] moz"
			} else if ("function" === typeof CSSStyleProperties) {
				source = CSSStyleProperties
				title = "[CSSStyleProperties] moz"
			}
			if (undefined !== source) {
				oList[name] = [source.prototype,
					['MozAnimation','MozAnimationDelay','MozAnimationDirection','MozAnimationDuration','MozAnimationFillMode',
					'MozAnimationIterationCount','MozAnimationName','MozAnimationPlayState','MozAnimationTimingFunction',
					'MozAppearance','MozBackfaceVisibility','MozBorderEnd','MozBorderEndColor','MozBorderEndStyle',
					'MozBorderEndWidth','MozBorderImage','MozBorderStart','MozBorderStartColor','MozBorderStartStyle',
					'MozBorderStartWidth','MozBoxAlign','MozBoxDirection','MozBoxFlex','MozBoxOrdinalGroup','MozBoxOrient',
					'MozBoxPack','MozBoxSizing','MozFloatEdge','MozFontFeatureSettings','MozFontLanguageOverride',
					'MozForceBrokenImageIcon','MozHyphens','MozImageRegion','MozMarginEnd','MozMarginStart','MozOrient',
					'MozPaddingEnd','MozPaddingStart','MozPerspective','MozPerspectiveOrigin','MozTabSize','MozTextSizeAdjust',
					'MozTransform','MozTransformOrigin','MozTransformStyle','MozTransition','MozTransitionDelay',
					'MozTransitionDuration','MozTransitionProperty','MozTransitionTimingFunction','MozUserFocus','MozUserInput',
					'MozUserModify','MozUserSelect','MozWindowDragging',
					// aliases
					'-moz-animation','-moz-animation-delay','-moz-animation-direction','-moz-animation-duration',
					'-moz-animation-fill-mode','-moz-animation-iteration-count','-moz-animation-name','-moz-animation-play-state',
					'-moz-animation-timing-function','-moz-appearance','-moz-backface-visibility','-moz-border-end',
					'-moz-border-end-color','-moz-border-end-style','-moz-border-end-width','-moz-border-image','-moz-border-start',
					'-moz-border-start-color','-moz-border-start-style','-moz-border-start-width','-moz-box-align',
					'-moz-box-direction','-moz-box-flex','-moz-box-ordinal-group','-moz-box-orient','-moz-box-pack',
					'-moz-box-sizing','-moz-float-edge','-moz-font-feature-settings','-moz-font-language-override',
					'-moz-force-broken-image-icon','-moz-hyphens','-moz-image-region','-moz-margin-end','-moz-margin-start',
					'-moz-orient','-moz-padding-end','-moz-padding-start','-moz-perspective','-moz-perspective-origin',
					'-moz-tab-size','-moz-text-size-adjust','-moz-transform','-moz-transform-origin','-moz-transform-style',
					'-moz-transition','-moz-transition-delay','-moz-transition-duration','-moz-transition-property',
					'-moz-transition-timing-function','-moz-user-focus','-moz-user-input','-moz-user-modify','-moz-user-select',
					'-moz-window-dragging',
					]
				]
			}
		}
		// object: don't use, we can do this elsewhere
		if (name === "window" && "object" == typeof window) {
			isObj = true
			oList[name] = [window,["mozRTCPeerConnection","CSSMozDocumentRule"]]
		}

		// do it!
		if (oList[name] !== undefined) {
			let obj = oList[name][0]
			let props = oList[name][1]
			if (isObj) {
				props.forEach(function(element) {
					if (element in obj) {res.push(element)}
				})
			} else if (useHas) {
				props.forEach(function(element) {
					if (obj.hasOwnProperty(element)) {res.push(element)}
				})
			} else {
				props.forEach(function(element) {
					if ("object" === typeof Object.getOwnPropertyDescriptor(obj, element)) {
						res.push(element)
					}
				})
			}
			res.sort()
		}
		let hash = "none", bool = false
		if (res.length > 0) {
			if (res.join(", ").length < 48) {
				hash = res.join(", ")
			} else {
				sDetail["expected_"+ title] = res
				hash = mini(res) + buildButton(3, "expected_"+ title, res.length)
			}
			bool = true
		} else if (isFF) {
			// FF none exceptions
			if (isVer < 63 && name === "ShadowRoot") {bool = zNA, hash = zNA +": FF63+ required"}
			if (isVer < 71 && name === "MathMLElement") {bool = zNA, hash = zNA +": FF71+ required"}
			if (isVer > 141 && name === 'HTMLInputElement') {bool = zNA, hash = zNA +": FF141 or lower"}
			if (name === "OfflineResourceList") {bool = zNA, hash = zNA +": assuming Beta/Dev/Nightly pref"}
			if (name === "Navigator") {
				// TB/PM build without WebRTC: mozGetUserMedia
					// and because of that also disable gUM (or code on sites suffer)
				if (undefined == window.RTCPeerConnection) {
					bool = zNA
					hash = zNA +": --disable-webrtc"+ s3 +" ["+ hash +"]"+ sc
				} else if (isFF) {
					// behind prefs: both media.peerconnection.enabled + media.navigator.enabled
					bool = zNA
					hash = zNA + s3 +" ["+ hash +"]"+ sc + sb +" [not firefox default]"+ sc
				}
			}
			if (isVer > 112 && name === "CanvasRenderingContext2D") { // 1822955
				bool = zNA
				hash = zNA +": FF112 or lower"
			}
		} else {
			// non-FF
			if (name === "CanvasRenderingContext2D") {
				bool = zNA
				hash += " [FF112 or lower]"
			}
		}
		fnRecord(num, title, hash, bool, "skip", t0)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_nav_keys(num1, num2, title) {
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		let aNavKeys = Object.keys(Object.getOwnPropertyDescriptors(Navigator.prototype))
		// expected FF only
		let aExpected = ["buildID","oscpu","taintEnabled"]
		let resE = aNavKeys.filter(x => aExpected.includes(x))
		let boolE = resE.length == 3 ? true : false
		resE = resE.length > 0 ? resE.join(", ") : "none"
		fnRecord(num1, title, resE, boolE, "skip", t0)

		// not expected: blink items
		let aNot = ["canShare","clearAppBadge","deviceMemory","getBattery","getInstalledRelatedApps",
			"getUserMedia","globalPrivacyControl","hid","keyboard","locks","managed","presentation","scheduling",
			"serial","setAppBadge","unregisterProtocolHandler","usb","userActivation","userAgentData","wakeLock",
			"webkitGetUserMedia","webkitPersistentStorage","webkitTemporaryStorage","xr","SharedWorker","Worker"]
		// FYI: don't use requestMIDIAccess: FF60+ behind dom.webmidi.enabled... 1752906: FF99+ default enabled

		if (isVer > 121) { aNot = aNot.filter(x => !["wakeLock"].includes(x)) } // FF122+ dom.screenwakelock.enabled 1589554
		if (isVer > 119) { aNot = aNot.filter(x => !["userActivation"].includes(x)) } // 1791079: FF120+
		if (isVer > 95) {aNot = aNot.filter(x => !["canShare"].includes(x)) } // 1666203: FF96+ canShare
		if (isVer > 94 || isEngine == "goanna") { aNot = aNot.filter(x => !["globalPrivacyControl"].includes(x))} // 1670058: FF95+ globalPrivacyControl | PM 30
		if (isVer > 92) { aNot = aNot.filter(x => !["locks"].includes(x)) } // FF93+ dom.weblocks.enabled: 1739233: FF96+ locks

		let resN = aNavKeys.filter(x => aNot.includes(x))
		let boolN = resN.length == 0
		if (resN.length > 0) {
			sDetail["unexpected_"+ title] = resN
			resN = mini(resN) + buildButton(3, "unexpected_"+ title, resN.length)
		} else {
			resN = "none"
		}
		fnRecord(num2, title, resN, boolN, "skip", t0)
	} catch(e) {
		fnRecord(num1, title, e.name, zErr, e.message)
		fnRecord(num2, title, e.name, zErr, e.message)
	}
}

function get_nav_screen(num) {
	let strA = "[left] screen", boolA = false
	try {
		let t0A = performance.now()
		if (bBlock) {bB = 1}
		let resA = screen.left
		if (!isNaN(resA)) {boolA = true} else {resA = fnClean(resA)}
		fnRecord(num, strA, resA, boolA, "skip", t0A)
	} catch(e) {
		fnRecord(num, strA, e.name, zErr, e.message)
	}
	let strB = "[top] screen", boolB = false
	try {
		let t0B = performance.now()
		if (bBlock) {bB = 1}
		let resB = screen.top
		if (!isNaN(resB)) {boolB = true} else {resB = fnClean(resB)}
		fnRecord(num+1, strB, resB, boolB, "skip", t0B)
	} catch(e) {
		fnRecord(num+1, strB, e.name, zErr, e.message)
	}
}

function get_nav_values(num1, num2, num3) {
	// expected
	let strA = "[oscpu] navigator", boolA = false
	try {
		let t0A = performance.now()
		if (bBlock) {bB = 1}
		let resA = navigator.oscpu
		if (typeof resA !== "string") {
			//console.debug(typeof resA)
		} else {
			if (resA == "") {resA = "empty string"
			} else if (resA == undefined) {resA = zU
			} else if (resA == zU) {resA = zUQ
			} else {boolA = true}
		}
		fnRecord(num1, strA, resA, boolA, "skip", t0A)
	} catch(e) {
		fnRecord(num1, strA, e.name, zErr, e.message)
	}

	// not expected
	// bluetooth
	let strBT = "[bluetooth] navigator", boolBT = false, numBT = num2
	try {
		let t0BT = performance.now()
		if (bBlock) {bB = 1}
		let resBT = navigator.bluetooth
		if (resBT === undefined) {
			fnRecord(numBT, strBT, zU, true, "skip", t0BT)
		} else {
			try {
				navigator.bluetooth.getAvailability().then(available => {
					if (available) {
						fnRecord(numBT, strBT, "supported", boolBT)
					} else {
						fnRecord(numBT, strBT, "not supported", boolBT)
					}
				})
			} catch(e) {
				fnRecord(numBT, strBT, e.name, zErr)
			}
		}
	} catch(e) {
		fnRecord(numBT, strBT, e.name, zErr, e.message)
	}
	// deviceMemory
	let strDM = "[deviceMemory] navigator", boolDM = false, numDM = num2+2
	try {
		let t0DM = performance.now()
		if (bBlock) {bB = 1}
		let resDM = navigator.deviceMemory
		if (resDM == undefined) {boolDM = true}
		resDM = fnClean(resDM)
		fnRecord(numDM, strDM, resDM, boolDM, "skip", t0DM)
	} catch(e) {
		fnRecord(numDM, strDM, e.name, zErr, e.message)
	}

	// globalprivacycontrol
	let strG = "[gpc] navigator", boolG = false, numG = num2+6
	try {
		let t0G = performance.now()
		if (bBlock) {bB = 1}
		let resG = navigator.globalPrivacyControl
		resG = fnClean(resG)
		if (resG == "undefined") {boolG = true
		} else if (isEngine == "goanna" && resG == "empty string") {boolG = true; resG += s3 + " [goanna]"+ sc}

		// 1670058: FF95+ globalPrivacyControl
		if (isVer > 94) {
			resG = zNA +": FF94 or lower" + s3 +" ["+ resG +"]" + sc
			boolG = zNA
		} else if (!isFF) {
			resG += " [FF94 or lower]"
			boolG = zNA
		}
		fnRecord(numG, strG, resG, boolG, "skip", t0G)
	} catch(e) {
		fnRecord(numG, strG, e.name, zErr, e.message)
	}

	// keyboard
	let strK = "[keyboard] navigator", numK = num2+8
	let t0K = performance.now()
	try {
		if (bBlock) {bB = 1}
		let resK = navigator.keyboard
		if (resK == undefined) {
			fnRecord(numK, strK, "undefined", true, "skip", t0K)
		} else {
			let keys = []
			// https://wicg.github.io/keyboard-map/
			// https://www.w3.org/TR/uievents-code/#key-alphanumeric-writing-system
			let listK = ['Backquote','Backslash','Backspace','BracketLeft','BracketRight','Comma',
				'Digit0','Digit1','Digit2','Digit3','Digit4','Digit5','Digit6','Digit7','Digit8','Digit9',
				'Equal','IntlBackslash','IntlRo','IntlYen','KeyA','KeyB','KeyC','KeyD','KeyE','KeyF','KeyG',
				'KeyH','KeyI','KeyJ','KeyK','KeyL','KeyM','KeyN','KeyO','KeyP','KeyQ','KeyR','KeyS','KeyT',
				'KeyU','KeyV','KeyW','KeyX','KeyY','KeyZ','Minus','Period','Quote','Semicolon','Slash']
			resK.getLayoutMap().then(keyboardLayoutMap => {
				listK.forEach(function(key) {
					try {keys.push(key +": "+ keyboardLayoutMap.get(key))} catch(e) {keys.push(key +": e.name")}
				})
				sDetail["unexpected_"+ strK] = keys
				let hash = mini(keys) + buildButton(3, "unexpected_"+ strK , keys.length)
				fnRecord(numK, strK, hash, false, "skip", t0K)
			})
		}
	} catch(e) {
		fnRecord(numK, strK, e.name, zErr, e.message)
	}

	// vendor
	let strV = "[vendor] navigator", boolV = false, numV = num2+10
	try {
		let t0V = performance.now()
		if (bBlock) {bB = 1}
		let resV = navigator.vendor
		if (resV == "") {boolV = true}
		resV = fnClean(resV)
		fnRecord(numV, strV, resV, boolV, "skip", t0V)
	} catch(e) {
		fnRecord(numV, strV, e.name, zErr, e.message)
	}

	// specific
	let strX = "[buildID] navigator", boolX = false
	try {
		let t0X = performance.now()
		if (bBlock) {bB = 1}
		let resX = navigator.buildID
		if (isVer > 63) {
			// all FF64+
			if (resX == "20181001000000") {boolX = true}
		} else {
			resX = fnClean(resX)
			// FF52-63: 14 digit number starting with 2017
			let year = resX.slice(0,4) *1
			if (resX.length == 14) {
				let isCheck = false
				if (year > 2016 && year < 2020) {isCheck = true}
				if (isVer == 52) {if (year > 2016) {isCheck = true}} // FF52 waterfox basilisk palemoon
				if (isCheck) {
					if (!isNaN(resX * 1)) {boolX = true}
				}
			} else {
				// RFP FF56-63 = 20100101
					// note: not worth checking if RFP is enabled based on old-timey settings
				if (resX == "20100101") {boolX = true}				
			}
		}
		fnRecord(num3, strX, resX, boolX, "skip", t0X)
	} catch(e) {
		fnRecord(num3, strX, e.name, zErr, e.message)
	}
	// DNT: FF: 1, unspecified
	let strDNT = "[doNotTrack] navigator", boolDNT = false, numDNT = num3+2
	let t0DNT = performance.now()
	try {
		if (bBlock) {bB = 1}
		let testDNT = navigator.doNotTrack
		if (testDNT == 1 || testDNT == "unspecified") {
			boolDNT = true
		} else {
			testDNT = fnClean(testDNT)
		}
		if (isFF && !boolDNT) {
			// PM not supported: returns undefined
			if (isEngine == "goanna" && testDNT == "undefined") {
				fnRecord(numDNT, strDNT, testDNT, true, "skip", t0DNT)
			} else {
				fnRecord(numDNT, strDNT, testDNT, zErr, "skip", t0DNT)
			}
		} else {
			fnRecord(numDNT, strDNT, testDNT, boolDNT, "skip", t0DNT)
		}
	} catch(e) {
		fnRecord(numDNT, strDNT, e.name, zErr, e.message)
	}

	let strY = "[productSub] navigator", boolY = false, numY = num3+4
	try {
		let t0Y = performance.now()
		if (bBlock) {bB = 1}
		let resY = navigator.productSub
		if (resY == "20100101") {boolY = true} else {resY = fnClean(resY)}
		fnRecord(numY, strY, resY, boolY, "skip", t0Y)
	} catch(e) {
		fnRecord(numY, strY, e.name, zErr, e.message)
	}

	// not expected
	// getbattery
	let strB = "[getBattery] navigator", boolB = false, numB = num2+4
	let resB = []
	let t0B = performance.now()
	try {
		if (bBlock) {bB = 1}
		// not going to add eventlisteners
		navigator.getBattery().then(function(battery) {
			try {resB.push(battery.level * 100 + "%")} catch(e) {resB.push("error")}
			try {resB.push((battery.charging ? "": "not ") +"charging")} catch(e) {resB.push("error")}
			try {resB.push(battery.chargingTime)} catch(e) {resB.push("error")}
			try {resB.push(battery.dischargingTime)} catch(e) {resB.push("error")}
			fnRecord(numB, strB, resB.join(", "), false, "skip", t0B)
		})
	} catch(e) {
		if (e.name == "TypeError" && e.message.substring(0,38) == "navigator.getBattery is not a function") {
			if (e.message == "navigator.getBattery is not a function") {boolB = true} // webkit wil be false
			fnRecord(numB, strB, e.name, boolB, e.message, t0B)
		} else {
			fnRecord(numB, strB, e.name, zErr, e.message)
		}
	}
}

function get_obj_enumeration(num, title) {
	// 1762188
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		let t = ['a','b'], result = []
		for (let i in t) {
			for (let j in t) {
				result.push([i, j, t[i], t[j]])
				let v = t[i]
				delete t[i]
				t[i] = v
			}
		}
		let res = result.join(",") // nonFF = 0,0,a,a,0,1,a,b,1,0,b,a,1,1,b,b
		let bool = res == "0,0,a,a,0,1,a,b,1,0,b,a" ? true : false
		fnRecord(num, title, res, bool, "skip", t0)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_permission(num, title) {
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		let userVis = "userVisibleOnly" // non-FF
		navigator.permissions.query({name:"push"}).then(function(result) {
			let res = result.state
			let bool = (res == "prompt" || res == "denied" || res == "granted") ? true : false
			fnRecord(num, title, res, bool, "skip", t0)
		}).catch(error => {
			if ((error.message).includes(userVis)) {
				fnRecord(num, title, userVis, false, "skip", t0)
			} else {
				fnRecord(num, title, error.name, zErr, error.message)
			}
		})
	} catch(e) {
		// not supported in webkit: https://caniuse.com/?search=push%20permission
		if (isEngine == "webkit") {
			fnRecord(num, title, "not supported", false)
		} else {
			fnRecord(num, title, e.name, zErr, e.message)
		}
	}
}

function get_plugins(num, title) {
	try {
		let t0 = performance.now()
		if (bBlock) {bB = 1}
		if ("plugins" in navigator) {
			let res = [], bool = false
			let p = navigator.plugins
			if (p.length == 0) {
				fnRecord(num, title, "none", true, "skip", t0)
			} else {
				for (let i=0; i < p.length; i++) {
					res.push(p[i].name + (p[i].filename == "" ? ": * " : ": "+ p[i].filename)
						+ (p[i].description == "" ? ": *" : ": "+ p[i].description))
				}
				res.sort()
				// FF84 or lower allow just Flash
				if (isFF && isVer < 85 && res.length == 1) {
					if (res[0].split(":")[0] == "Shockwave Flash") {bool = true}
				}
				let hash = mini(res)
				if (isVer > 98 || !isFF) { // allow non-FF to have the same
					// FF99+: controlled by pdfjs.disabled
					// 1720353: hardcoded mimeTypes
					if (hash == "b46e6634") {
						bool = true
					}
				}
				sDetail["expected_"+ title] = res
				hash += buildButton(3, "expected_"+ title, res.length)
				fnRecord(num, title, hash, bool, "skip", t0)
			}
		} else {
			fnRecord(num, title, e.name, zErr)
		}
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_stacklength(num1, num2, num3) {
	let t0 = performance.now()
	let level = 0, test1 = 0
	function recurse() {
		level++
		recurse()
	}
	try {
		recurse()
	} catch(e) {
		test1 = level
	}
	level = 0
	try {
		recurse()
	} catch(e) {
		// timing an error property lookup is not the same as generating a alow recurse one
		// columnNumber
		let strCN = "[columnNumber] error", errCN = false
		try {
			let t0E = performance.now()
			if (bBlock) {bB = 1}
			let resCN = e.columnNumber
			let testCN = resCN == undefined? false : true
			fnRecord(num1, strCN, resCN, testCN, "skip", t0E)
		} catch(n) {
			fnRecord(num1, strCN, n.name, zErr, n.message)
		}
		// fileName
		let strFN = "[fileName] error", errFN = false
		try {
			let t0F = performance.now()
			if (bBlock) {bB = 1}
			let resFN = e.fileName
			if (resFN !== undefined) {resFN = resFN.slice(0,8) + "..."}
			let testFN = resFN == undefined? false : true
			fnRecord(num1+1, strFN, resFN, testFN, "skip", t0F)
		} catch(n) {
			fnRecord(num1+1, strFN, n.name, zErr, n.message)
		}
		// lineNumber
		let strLN = "[lineNumber] error", errLN = false
		try {
			let t0LN = performance.now()
			if (bBlock) {bB = 1}
			let resLN = e.lineNumber
			let testLN = resLN == undefined? false : true
			fnRecord(num1+2, strLN, resLN, testLN, "skip", t0LN)
		} catch(n) {
			fnRecord(num1+2, strLN, n.name, zErr, n.message)
		}

		// first error
		let perf = (t0- performance.now()) + performance.now()
		let strRE = "error", resRE = e.name +": "+ e.message
		if (resRE == "InternalError: too much recursion") {
			fnRecord(num3, strRE, resRE, true, "skip", perf)
		} else {
			fnRecord(num3, strRE, resRE, false, "skip", )
		}
		// stack length: only for FYI purposes
		let strSL = "stack length"
		try {
			if (bBlock) {bB = 1}
			let resSL = e.stack.toString().length
			resSL = zNA +": FYI: "+ s3 +"["+ resSL +"]"+sc
			fnRecord(num2, strSL, resSL, zNA, "skip", perf)
		} catch(n) {
			fnRecord(num2, strSL, n.name, zErr, n.message, perf)
		}
	}
}

function get_storage_estimate(num, title) {

	// Notes: Win10 VM is  52gb / 33gb spare | FF is always the same in PB mode
		//   2147483648 : FF57-96 Windows / Android / Win 10 VM FF60-96
	/*
	FF97+ is not stable enough: see https://bugzilla.mozilla.org/show_bug.cgi?id=1735713
   10737418240 : Windows, vannTenn's + bashonly's Linux, Android Fabrizio 100gb spare from 128gb
    5641604300 : Android Fabrizio 49gb spare from 64gb
    5512729395 : Android Thorin 44gb spare from 64gb
    5301081292 : Android bashonly 40gb spare from 64gb
    5256596684 : Win 10 VM 33gb spare from 52gb
    2934867968 : Debian XCFE 2glops 650gb spare from 1TB
    1521166745 : Ubuntu VM Fabrizio with 15GB of storage
    1177328025 : Android aleyvo 1.5gb spare from 16gb
	*/

	// other: who cares if they match
		// brave:     2147483648 (same in incognito and Tor window)
		// opera:      310418104 normal
		// opera:      521917312 private
		// chrome: 1200238045593 normal
		// chrome:   33076376370 normal android
		// chrome:     485041940 incognito
		// chrome:     204974075 incognito android

	// ToDo: check if FF97+ new storage quota is based on disk or free disk space size
	let t0 = performance.now()
	try {
		if (bBlock) {bB = 1}
		navigator.storage.estimate().then(estimate => {
			let quota = estimate.quota,
				bool = false
			if (isFF) {
				if (isVer > 96) {
					bool = zNA
					quota = zNA +": variable in FF97+ "+ s3 +"["+ quota +"]"+ sc
				} else {
					if (quota > 2147000000 && quota < 2148000000) {bool = true}
				}
			} else {
				bool = zNA
				quota += " [FF96 or lower]"
			}
			fnRecord(num, title, quota, bool, "skip", t0)
		})
	} catch(e) {
		if (isEngine == "webkit") {
			fnRecord(num, title, e.name, false, e.message) // not supported in webkit
		} else {
			// FF56 or lower
			let result = e.name
			let type = zErr
			let error = e.message
			if (isFF && isVer < 57 && e.message == "navigator.storage is undefined") {
				result = zNA +": FF57+ required"
				type = zNA
				error = undefined
			}
			fnRecord(num, title, result, type, error)
		}
	}
}

function get_window_moz(num) {

	let strC = "[CSSMozDocumentRule] window"
	try {
		let t0C = performance.now()
		if (bBlock) {bB = 1}
		let resC = typeof CSSMozDocumentRule
		let boolC = "function" === typeof CSSMozDocumentRule // FF53+
		if (!boolC && isVer == 52) {
			boolC = "object" === resC
		}
		fnRecord(num, strC, resC, boolC, "skip", t0C)
	} catch(e) {
		fnRecord(num, strC, e.name, zErr, e.message)
	}

	let strM = "[mozRTCPeerConnection] window"
	try {
		let t0M = performance.now()
		if (bBlock) {bB = 1}
		let resM = typeof mozRTCPeerConnection
		let boolM = "function" === typeof mozRTCPeerConnection
		if (!boolM && isFF && "undefined" === resM) {
			// TB/PM build without WebRTC
			if (undefined == window.RTCPeerConnection) {
				boolM = zNA
				resM = zNA +": --disable-webrtc"+ s3 +" ["+ resM +"]"+ sc
			} else if (isVer > 112) { // 1531812
				boolM = zNA
				resM = zNA +": FF112 or lower"+ s3 +" ["+ resM +"]"+ sc
			}
		} else if (!isFF) {
			boolM = zNA
			resM += " [FF112 or lower]"
		}
		fnRecord(num+1, strM, resM, boolM, "skip", t0M)
	} catch(e) {
		fnRecord(num+1, strM, e.name, zErr, e.message)
	}

	let strA = "[mozInnerScreenX] window", boolA = false
	try {
		let t0A = performance.now()
		if (bBlock) {bB = 1}
		let resA = window.mozInnerScreenX
		if (!isNaN(resA)) {boolA = true} else {resA = fnClean(resA)}
		fnRecord(num+2, strA, resA, boolA, "skip", t0A)
	} catch(e) {
		fnRecord(num+2, strA, e.name, zErr, e.message)
	}
	let strB = "[mozInnerScreenY] window", boolB = false
	try {
		let t0B = performance.now()
		if (bBlock) {bB = 1}
		let resB = window.mozInnerScreenY
		if (!isNaN(resB)) {boolB = true} else {resB = fnClean(resB)}
		fnRecord(num+3, strB, resB, boolB, "skip", t0B)
	} catch(e) {
		fnRecord(num+3, strB, e.name, zErr, e.message)
	}
}

function get_window_props(num1, num2, title) {
	// conservative small subset of items from engineprops PoC
	function rec(type, value, name) {
		if (value !== "undefined") {
			if (type == num1) {resE.push(name)} else {resU.push(name)}
		}
	}

	// expected
	let t0E = performance.now()
	let resE = []
	try {
		if (bBlock) {bB = 1}
		// enumerate
		rec(num1, typeof KeyEvent, "KeyEvent")
		rec(num1, typeof dump, "dump")
		rec(num1, typeof fullScreen, "fullScreen")
		rec(num1, typeof getDefaultComputedStyle, "getDefaultComputedStyle")
		rec(num1, typeof mozInnerScreenX, "mozInnerScreenX")
		rec(num1, typeof mozInnerScreenY, "mozInnerScreenY")
		rec(num1, typeof onabsolutedeviceorientation, "onabsolutedeviceorientation") // removed FF110 1689631
		//rec(num1, typeof onbeforeinput, "onbeforeinput")
		rec(num1, typeof onmozfullscreenchange, "onmozfullscreenchange")
		rec(num1, typeof onmozfullscreenerror, "onmozfullscreenerror")
		rec(num1, typeof scrollByLines, "scrollByLines")
		rec(num1, typeof scrollByPages, "scrollByPages")
		rec(num1, typeof scrollMaxX, "scrollMaxX")
		rec(num1, typeof scrollMaxY, "scrollMaxY")
		rec(num1, typeof setResizable, "setResizable")
		rec(num1, typeof sizeToContent, "sizeToContent") // removed nightly FF117+ 1832733 / 1600400
		rec(num1, typeof u2f, "u2f")
		rec(num1, typeof updateCommands, "updateCommands")
		// finish
		let boolE = resE.length > 0
		let hashE = boolE ? mini(resE) : "none"
		if (boolE) {
			if (resE.join(", ").length < 48) {
				hashE = resE.join(", ")
			} else {
				sDetail["expected_"+ title] = resE
				hashE += buildButton(3, "expected_"+ title, resE.length)
			}
		}
		fnRecord(num1, title, hashE, boolE, "skip", t0E)
	} catch(e) {
		fnRecord(num1, title, e.name, zErr, e.message)
	}

	// unexpected
	let t0U = performance.now()
	let resU = []
	try {
		if (bBlock) {bB = 1}
		// enumerate
			// webkit only
		rec(num2, typeof browser, "browser")
		rec(num2, typeof getMatchedCSSRules, "getMatchedCSSRules")
		rec(num2, typeof safari, "safari")
		rec(num2, typeof showModalDialog, "showModalDialog")
		rec(num2, typeof webkitCancelRequestAnimationFrame, "webkitCancelRequestAnimationFrame")
		rec(num2, typeof webkitConvertPointFromNodeToPage, "webkitConvertPointFromNodeToPage")
		rec(num2, typeof webkitConvertPointFromPageToNode, "webkitConvertPointFromPageToNode")
		rec(num2, typeof webkitIndexedDB, "webkitIndexedDB")
			// blink only
		rec(num2, typeof Keyboard, "Keyboard")
		rec(num2, typeof KeyboardLayoutMap, "KeyboardLayoutMap")
		rec(num2, typeof PERSISTENT, "PERSISTENT")
		rec(num2, typeof TEMPORARY, "TEMPORARY")
		rec(num2, typeof chrome, "chrome")
		rec(num2, typeof cookieStore, "cookieStore") // FF132 nightly 1918643
		rec(num2, typeof getScreenDetails, "getScreenDetails")
		rec(num2, typeof launchQueue, "launchQueue")
		rec(num2, typeof navigation, "navigation")
		rec(num2, typeof offscreenBuffering, "offscreenBuffering")
		rec(num2, typeof onappinstalled, "onappinstalled")
		rec(num2, typeof onbeforeinstallprompt, "onbeforeinstallprompt")
		rec(num2, typeof onbeforematch, "onbeforematch") // FF139 1761043 dom.hidden_until_found.enabled
		rec(num2, typeof onbeforexrselect, "onbeforexrselect")
		rec(num2, typeof oncontextlost, "oncontextlost")
		rec(num2, typeof oncontextrestored, "oncontextrestored")
		rec(num2, typeof ondeviceorientationabsolute, "ondeviceorientationabsolute") // FF110+ 1689631
		rec(num2, typeof onsearch, "onsearch")
		rec(num2, typeof openDatabase, "openDatabase")
		rec(num2, typeof opr, "opr") // OPERA desktop at least
		rec(num2, typeof originAgentCluster, "originAgentCluster") // FF138+ 1665474
		rec(num2, typeof queryLocalFonts, "queryLocalFonts")
		rec(num2, typeof showDirectoryPicker, "showDirectoryPicker")
		rec(num2, typeof showOpenFilePicker, "showOpenFilePicker")
		rec(num2, typeof showSaveFilePicker, "showSaveFilePicker")
		rec(num2, typeof trustedTypes, "trustedTypes") // FF145 nightly 1955251
		rec(num2, typeof webkitRequestFileSystem, "webkitRequestFileSystem")
		rec(num2, typeof webkitResolveLocalFileSystemURL, "webkitResolveLocalFileSystemURL")
		rec(num2, typeof webkitStorageInfo, "webkitStorageInfo")

		// finish
		if (isVer > 109) {
			// FF110+ 1689631
			resU = resU.filter(x => !["ondeviceorientationabsolute"].includes(x))
			if (isVer > 125) {
				// FF126: 1887729
				resU = resU.filter(x => !["oncontextlost"].includes(x))
				resU = resU.filter(x => !["oncontextrestored"].includes(x))
			}
			if (isVer > 131) {resU = resU.filter(x => !["cookieStore"].includes(x))} // FF132 nightly 1918643
			if (isVer > 137) {resU = resU.filter(x => !["originAgentCluster"].includes(x))}
			if (isVer > 138) {resU = resU.filter(x => !["onbeforematch"].includes(x))}
			if (isVer > 144) {resU = resU.filter(x => !["trustedTypes"].includes(x))} // FF145 nightly 1955251
		}

		let boolU = resU.length == 0
		let hashU = !boolU ? mini(resU) : "none"
		if (!boolU) {
			if (resU.join(", ").length < 48) {
				hashU = resU.join(", ")
			} else {
				sDetail["unexpected_"+ title] = resU
				hashU += buildButton(3, "unexpected_"+ title, resU.length)
			}
		}
		fnRecord(num2, title, hashU, boolU, "skip", t0U)
	} catch(e) {
		fnRecord(num2, title, e.name, zErr, e.message)
	}

}

function rerun() {
	// reset
	results = []
	itemnumbers = [],
	data = {},
	aPerf = [],
	count = 0,
	dom.perf = ""
	dom.results = ""
	// do it: delay for user to see visual change
	setTimeout(function() {
		run()
	}, 120)
}

function run() {
	// now get on with it
	fnRecord(0, "header", "expected")
	fnRecord(300, "header", "not expected")
	fnRecord(600, "header", "specific values")
	fnRecord(899, "hr")
	fnRecord(900, "header", "errors")
	// OK, let's kick some ass
	// stagger to get more accurate perf

	setTimeout(function() {
		gt0 = performance.now()
		aPerf.push(["START 1", gt0])
		get_installtrigger(50) // 50-52
		get_eval_length(630, "eval.toString().length")
		get_colorgamut(310, "[css] color-gamut")
		get_nav_screen(170)
		get_window_props(260, 450, "[properties] window")
		get_obj_enumeration(750, "object enumeration")
		get_last_prototype_keys(640, "[last x keys]") // 640+641
		get_math(720, "math")
		get_nav_values(150, 400, 740) // 100 expected, 400-410 not expected, 740.. specific
		get_dates(620)
		get_js_client_hints(320, "[js] client hints")
		get_mimetypes(730, "mimetypes")
		get_plugins(770, "plugins")
		get_media_constraints(725, "[constraints] mediaDevices")
	}, 1)

	setTimeout(function() {
		aPerf.push(["START 2", performance.now(), performance.now() - gt0])
		get_moz_objects(88, "CanvasRenderingContext2D")
		get_moz_objects(94, "CSS2|CSSStyle")
		get_moz_objects(96, "DataTransfer")
		get_moz_objects(98, "Document")
		get_moz_objects(100, "Element")
		get_moz_objects(106, "HTMLElement")
		get_moz_objects(108, "HTMLCanvasElement")
		get_moz_objects(110, "HTMLInputElement")
		get_moz_objects(112, "HTMLMediaElement")
		get_moz_objects(114, "HTMLVideoElement")
		get_moz_objects(116, "IDBIndex")
		get_moz_objects(118, "IDBObjectStore")
		get_moz_objects(120, "MathMLElement") // added in FF71
		get_moz_objects(122, "MouseEvent")
		get_moz_objects(126, "Navigator")
			// ^media.peerconnection.enabled + media.navigator.enabled = false negative
		get_moz_objects(128, "OfflineResourceList")
			// ^pref: browser.cache.offline.enable [pref exists since Jesus]
			// nightly/beta/dev default off - since when? FF71+ 1237782 ?
		get_moz_objects(130, "Screen")
		get_moz_objects(132, "ShadowRoot") // added in FF63
		get_moz_objects(134, "SVGElement")
		get_moz_objects(136, "XMLHttpRequest")
	}, 1)

	setTimeout(function() {
		aPerf.push(["START 3", performance.now(), performance.now() - gt0])
		get_window_moz(250) // 250-253
		get_nav_keys(85, 350, "[navigator] keys") // 85 expected, 350 not expected
		get_intl_supportedlocales(655) // +5's: C, DTF, DN, LF, NF, PR, RTF
		get_intl_canonical_locale(667, "Intl.getCanonicalLocales")
		get_locale_compare(710, "locale.compare")
		get_intl_supportedvaluesof(700, "Intl.supportedValuesOf") // timeZone
	}, 1)

	setTimeout(function() {
		aPerf.push(["START 4", performance.now(), performance.now() - gt0])
		get_moz_colors(90, "[colors] moz")
		get_moz_fonts(102, "[fonts] moz")
		get_errors(902)
		get_stacklength(30,850,901) // 30-32 error properties, 850 = stack length, 901 = first error message
	}, 1)

	setTimeout(function() {
		aPerf.push(["START THE END", performance.now(), performance.now() - gt0])
		get_iframe_props(40, 330, "[properties] iframe") // 40 expected, 330 not expected,
	}, 1)
	setTimeout(function() {
		get_permission(800, "[permissions] push")
		get_storage_estimate(870, "storage estimate")
	}, 1)

}

setTimeout(function() {
	Promise.all([
		get_globals()
	]).then(function(){
		Promise.all([
			get_is95(),
			get_isVer(),
		]).then(function(){
			run()
		})
	})
}, 50)

</script>
</body>
</html>
