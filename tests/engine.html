<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=620">
	<title>engine</title>
	<link rel="stylesheet" type="text/css" href="testindex.css">
	<script src="testglobals.js"></script>
	<script src="testgeneric.js"></script>
	<!-- custom -->
	<style>
		table {width: 700px;}
		#tb3 td:first-child { text-align: left; vertical-align: top;}
		hr {color: #dcc18c}
	</style>
</head>

<body>
	<div class="offscreen">
		<div id="mozFont"></div>
		<div id="test95a" style="width: min-content; hyphens: auto; border: 1px solid red">2020-1</div>
		<div id="test95b" style="width: min-content; hyphens: auto; border: 1px solid red">2020-12020-1</div>
	</div>
	<div class="hidden">
		<div><input type="time" min="14:00:00" max="12:00:00" value="15:00:00" id="test76"></div>
		<span id="mozColor"></span>
	</div>

	<table>
	<tr><td><h2>TorZillaPrint</h2></td></tr>
	<tr><td class="blurb"><a class="return" href="../index.html">return to TZP index</a></td></tr>
	</table>

	<table id="tb3">
		<col width="50%"><col width="50%">
		<thead><tr><th colspan="2">
			<div class="nav-title">engine
			<div class="nav-up"><span class="c perf" id="perf"></span></div>
			</div>
		</th></tr></thead>
		<tr><td colspan="2" class="intro">
			<span class="no_color">An itsy-bitsy, teeny-weeny, minuscule sample of the thousands of myriad ways engines differ.
			This test is tweaked for gecko [FF52+]: you want <span class="s9"><b> &#x2713 </b></span>'s. Anything different
			<span class="bad"><b> &#x2716 </b></span> or blocked <span class="s4"><b> &#x2715 </b></span> only makes you stand out.
			</span>
		</td></tr>
		<tr><td colspan="2"><hr></td></tr>
		<tr><td colspan="2"><span class="no_color c mono spaces" id="results"></span></td></tr>
	</table>
	<br>

<script>
'use strict';

s3 = s3.trim()
s14 = s14.trim()
s99 = s99.trim()
sb = sb.trim()
sg = sg.trim()

let results = [],
	itemnumbers = [],
	data = {},
	aPerf = [],
	count = 0,
	expected = 77,
	gt0, // global timer
	bBlock = false, // throw a test error
	bLog = false,
	bNum = false // display numbering instead of perf

let	topVer = 105,
	minVer = "",
	isWebkit = false

function fnTrim(str, len) {
	str = str.replace(/(\r\n|\n|\r)/gm,"")
	if (str.length > len) {str = str.slice(0,len-3) +"..."}
	return str
}

function fnClean(str) {
	if (str == "") {str = "empty string"
	} else if (str === undefined) {str = zU
	} else if (str == zU) {str = zUQ}
	return str
}

function logPerf() {
	if (aPerf.length) {
		console.log("PERF LOG\n", aPerf)
	}
}

function fnDisplay() {
	// perf
	if (canPerf) {
		let perf = Math.round(performance.now() - gt0) +" ms"
		// remove the first 6 items
		if (aPerf.length) {
			perf = "<span style='cursor: pointer;' onClick='logPerf()'>" + perf +"</span>"
			aPerf.splice(0, 6)
		}
		dom.perf.innerHTML = perf
	}
	// data -> ordered results
	const names = Object.keys(data).sort((a,b) => a-b)
	for (const k of names) {results.push(k +"~~~"+ data[k])}
	let display = [],
		errcount = 0
	let countTrue = 0, countFalse = 0, countBlock = 0, countNA = 0
	// check no numbers duplicated
	if (expected !== results.length) {
		display.push(sb+ "ERROR:"+ sc + " duplicate numbers detected<br>")
	}
	// parse for pretty output
	for (let i=0; i < results.length; i++) {
		let pad = 35
		let order = results[i].split("~~~")[0],
			desc = results[i].split("~~~")[1].trim(),
			result = results[i].split("~~~")[2],
			match = results[i].split("~~~")[3],
			perf = results[i].split("~~~")[4]
		if (perf == undefined || perf == "" || perf == "undefined") {perf = " - "
		} else if (perf !== "NaN") {
			perf = Math.round(perf)
			perf = perf.toString()
			perf = perf.padStart(2) +" "
		}

		if (desc == "header") {
			let note = ""
			if (result == "errors") {
				note = " [there are thousands of these]"
			}
			result = s14 + result.toUpperCase() + sc + note
			display.push("<span>"+ result + "</span><br>")
		} else if (desc == "hr") {
			display.push("<br><hr>")
		} else {
			if (match == zB0) {match = yellow_block; countBlock++
			} else if (match == "true") {match = green_tick; countTrue++
			} else if (match == "false") {match = red_cross; countFalse++
			} else {match = white_na; countNA++}
			match += " "
			if (desc == "error") {
				pad = 3; errcount++; desc = errcount.toString()
			}
			desc = s3 + desc.padStart(pad) + sc
			let sectionspace = ""
			if (i+1 < results.length) {
				let nextitem = results[i+1].split("~~~")[1].trim()
				if (nextitem == "header") {sectionspace = "<br>"}
			}
			desc += s99 +" "+ (bNum ? order : perf) + sc
			display.push(desc + match +" "+ result + sectionspace)
		}
	}
	// summary
	let countValid = countTrue + countFalse + countBlock // na tests ignored
	let countFail = countFalse + countBlock
	let percentPassed = Math.floor((countTrue/countValid)*100)
	let isPass = percentPassed == 100 ? true : false
	let percentFailed = Math.ceil((countFail/countValid)*100)
	let summary = s14 +"SUMMARY "+ sc
		+"PASSED: ".padStart(9) + countTrue + (isPass? sg : sb) +" ["+ percentPassed +"%]"+ sc
		+"FAILED: ".padStart(9) + countFail + (isPass? sg : sb) +" ["+ percentFailed +"%]"+ sc
	if (countNA > 0) {summary += "N/A: ".padStart(6) + countNA}
	if (isFF) {
		summary += s14+ "DEBUG".padStart(7) + sc +"RFP:".padStart(6) + (isRFP ? green_tick : red_cross)
		let strVer = isVer
		strVer += (isVer == topVer ? "+" : "")
		strVer += (isVer == minVer ? " or lower" : "")
		summary += "VER: ".padStart(6) + strVer
	}
	summary += " " + buildButton(3, "all", "all details")
	// output
	dom.results.innerHTML = summary + "<br><br>" + display.join("<br>")
}


function fnRecord(order, description, result, match, error, perf) {
	if (error !== undefined && error !== "skip") {
		//console.error(order, result, error)
		result += s3+ " ["+ mini(error) +"]"+ sc
	}
	aPerf.push([perf, order, description])
	order = (order+"").padStart(3,"0")
	data[order] = description +"~~~"+ result +"~~~"+ match + "~~~" + perf
	count ++
	itemnumbers.push(order +" "+ description)
	if (count == expected) {
		fnDisplay()
	}
	if (count > expected) {console.error(count, "expected count too low")}
}

function get_canvaskeys(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let res = []
		let list = [
			// 1765063: FF102+: Disable mozCurrentTransform on early beta and earlier
			// 'mozCurrentTransform', 'mozCurrentTransformInverse',
			'mozImageSmoothingEnabled', 'mozTextStyle',
		]
		for (const key in CanvasRenderingContext2D.prototype) {res.push(key)}
		res = res.filter(x => list.includes(x))
		res.sort()
		let bool = false

		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		if (res.length > 0) {
			sDetail["expected_"+ title] = res
			if (hash == "0fd2871814ac9179d6f5a5b4a0ffea0e0e20152c") {bool = true}
			hash += buildButton(3, "expected_"+ title, res.length)
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_colorgamut(num, title) {
	let q = "(color-gamut: ", res = "undefined", bolC = false
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		if (window.matchMedia(q +"srgb)").matches) {res = "srgb"}
		if (window.matchMedia(q +"p3)").matches) {res = "p3"}
		if (window.matchMedia(q +"rec2020)").matches) {res = "rec2020"}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, res, res == "undefined", "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_dates(num) {
	// 1274354: meta
	// 1557650
	let strA = "[5 digit year] new Date"
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = new Date("19999-11-11")
		let bolA = resA == "Invalid Date" ? true : false
		if (!bolA) {resA = fnTrim(resA.toString(), 40)}
		let perfA = canPerf ? performance.now() - t0A : ""
		fnRecord(num, strA, resA, bolA, "skip", perfA)
	} catch(e) {
		fnRecord(num, strA, e.name, zB0, e.message)
	}
	// 1515318
	let strB = "[hyphen] new Date"
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = new Date("31-Mar-2011").getFullYear()
		// FF: 63 and lower = NaN, 64+ = -2011
		let bolB = false
		if (resB == -2011) {bolB = true
		} else if (isVer < 64 && isNaN(resB)) {bolB = true}
		let perfB = canPerf ? performance.now() - t0B : ""
		fnRecord(num+1, strB, resB, bolB, "skip", perfB)
	} catch(e) {
		fnRecord(num+1, strB, e.name, zB0, e.message)
	}
	// 1439800
	let strC = "[string] new Data"
	try {
		let t0C; if (canPerf) {t0C = performance.now()}
		if (bBlock) {bB = 1}
		let resC = new Date("11-Nov-11")
		let bolC = resC.toString() == "Invalid Date" ? true : false
		if (!bolC) {resC = fnTrim(resC.toString(), 40)}
		let perfC = canPerf ? performance.now() - t0C : ""
		fnRecord(num+2, strC, resC, bolC, "skip", perfC)
	} catch(e) {
		fnRecord(num+2, strC, e.name, zB0, e.message)
	}
	// 1599375
	let strD = "[+0000 UTC] Date.parse"
	try {
		let t0D; if (canPerf) {t0D = performance.now()}
		if (bBlock) {bB = 1}
		let resD = Date.parse("2019-11-26 07:39:58.286157072 +0000 UTC")
		let bolD = isNaN(resD) ? true : false
		let perfD = canPerf ? performance.now() - t0D : ""
		fnRecord(num+3, strD, resD, bolD, "skip", perfD)
	} catch(e) {
		fnRecord(num+3, strD, e.name, zB0, e.message)
	}
	// 1730155
	let strE = "[localized] Date.parse"
	try {
		let t0E; if (canPerf) {t0E = performance.now()}
		if (bBlock) {bB = 1}
		let resE = Date.parse("Mercredi 8 Septembre 2021")
		let bolE = isNaN(resE) ? true : false
		let perfE = canPerf ? performance.now() - t0E : ""
		fnRecord(num+4, strE, resE, bolE, "skip", perfE)
	} catch(e) {
		fnRecord(num+4, strE, e.name, zB0, e.message)
	}
}

function get_doc_values(num, title) {
	let strFS = "[mozFullScreen] "+ title
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		// FF expected true/false
		let boolFS = false
		let testFS = document.mozFullScreenEnabled
		if (testFS == true || testFS == false) {boolFS = true} else {fnClean(testFS)}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, strFS, testFS, boolFS, "skip", perf)
	} catch(e) {
		fnRecord(num, strFS, e.name, zB0, e.message)
	}
}

function get_errors(num) {
	let tests = [
		["var a = {}; a.b = a; JSON.stringify(a)", "TypeError: cyclic object value"],
		["alert('A)","SyntaxError: '' string literal contains an unescaped line break"],
		["let a = 1_00_;","SyntaxError: underscore can appear only between digits, not after t...", // FF72+
			"SyntaxError: identifier starts immediately after numeric literal", // FF60-69
			"SyntaxError: missing digit after '_' numeric separator"], // FF70-71
		["const foo;foo.bar","SyntaxError: missing = in const declaration"],
		["null.bar","TypeError: can't access property \"bar\" of null","TypeError: null has no properties"],
		["(1).toString(1000)","RangeError: radix must be an integer at least 2 and no greater than 36"],
		["var x = new Array(-1)","RangeError: invalid array length"],
		["[...undefined].length","TypeError: can't access property Symbol.iterator of undefined","TypeError: undefined has no properties"],
		["const tzp=1; const tzp=2;","SyntaxError: redeclaration of const tzp"],
		["const foo;foo.bar","SyntaxError: missing = in const declaration"],
		["var x = @","SyntaxError: illegal character U+0040","SyntaxError: illegal character"],
	]
	tests.forEach(function(array) {
		let t0; if (canPerf) {t0 = performance.now()}
		try {
			newFn(array[0])
		} catch(e) {
			let bool = false
			let str = fnTrim(e.name +": "+ e.message, 70)
			if (isVer < 60 && array[0] == "alert('A)") {
				if (str == "SyntaxError: unterminated string literal") {bool = true}
			} else {
				if (str == array[1] || str == array[2] || str == array[3]) {bool = true}
			}
			let perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num, "error", str, bool, "skip", perf)
			num++
		}
	})
}

function get_eval_length(num, title) {
	let bool = false
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let test = eval.toString().length
		if (test == 37) {bool = true}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, test, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_iframe_props(num1, num2, title) {
	let t0; if (canPerf) {t0 = performance.now()}
	// just a small sample
	let listE = ['dump','fullScreen','getDefaultComputedStyle','mozInnerScreenX',
		'mozInnerScreenY','netscape','onmozfullscreenchange','onmozfullscreenerror']
	let listU = ['BatteryManager','HID','Keyboard','Lock','Serial',
		'USB','WakeLock','WebKitMutationObserver','XRAnchor','chrome','webkitCancelAnimationFrame',
		'webkitMediaStream','webkitRTCPeerConnection','webkitRequestAnimationFrame',
		'webkitRequestFileSystem','webkitResolveLocalFileSystemURL','webkitStorageInfo']
	// FYI: don't use MIDIAccess: FF60+ behind dom.webmidi.enabled... 1752906: FF99+ default enabled

	if (isVer > 92) {
		// FF93+ "dom.weblocks.enabled"
		// 1739233: FF96+ Lock
		listU = listU.filter(x => !["Lock"].includes(x))
	}
	try {
		if (bBlock) {bB = 1}
		// create & append iframe
		let id = "iframe-window-version"
		let el = document.createElement("iframe")
		el.setAttribute("id", id)
		el.setAttribute('style', 'display: none')
		document.body.appendChild(el)
		// get props
		let iframe = document.getElementById(id)
		let contentWindow = iframe.contentWindow
		let props = Object.getOwnPropertyNames(contentWindow)
		// remove iframe
		iframe.parentNode.removeChild(iframe)
		props.sort()
		// expected
		let arrayE = props.filter(x => listE.includes(x))
		let resE = "", boolE = false
		if (arrayE.length) {
			sDetail["expected_"+ title] = arrayE
			resE = mini_sha1(arrayE.join()) + buildButton(3, "expected_"+ title, arrayE.length)
			if (arrayE.length > 4) {boolE = true}
		} else {
			resE = "none"
		}
		// unexpected
		let arrayU = props.filter(x => listU.includes(x))
		// ignore BatteryManager FF72+
		if (isFF && isVer < 72) {arrayU = arrayU.filter(x => !["BatteryManager"].includes(x))}
		let resU = "", boolU = false
		if (arrayU.length) {
			sDetail["unexpected_"+ title] = arrayU
			resU = mini_sha1(arrayU.join()) + buildButton(3, "unexpected_"+ title, arrayU.length)
		} else {
			resU = "none"
			boolU = true
		}
		let perf = canPerf ? performance.now() - t0 : ""
		// record
		fnRecord(num1, title, resE, boolE, "skip", perf)
		fnRecord(num2, title, resU, boolU, "skip", perf)
	} catch(e) {
		fnRecord(num1, title, e.name, zB0, e.message)
		fnRecord(num2, title, e.name, zB0, e.message)
	}
}

function get_installtrigger(num) {
	// FF100+: 1754441 behind prefs slated for deprecation
	let strA = "[typeof] InstallTrigger", boolA = false
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = typeof InstallTrigger
		if (resA == "object") {boolA = true}
		let perfA = canPerf ? performance.now() - t0A : ""
		if (isVer > 99 && !boolA) {
			fnRecord(num, strA, zNA +": FF99 or lower" + s3 +" ["+ resA +"]"+ sc, zNA, "skip", perfA)
		} else {
			fnRecord(num, strA, resA, boolA, "skip", perfA)
		}
	} catch(e) {
		fnRecord(num, strA, e.name, zB0, e.message)
	}

	let strB = "[window] InstallTrigger", boolB = false
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = "InstallTrigger" in window
		let perfB = canPerf ? performance.now() - t0B : ""
		if (isVer > 99 && !resB) {
			fnRecord(num+1, strB, zNA +": FF99 or lower" + s3 +" ["+ resB +"]"+ sc, zNA, "skip", perfB)
		} else {
			fnRecord(num+1, strB, resB, resB, "skip", perfB)
		}
	} catch(e) {
		fnRecord(num+1, strB, e.name, zB0, e.message)
	}

	let strC = "[typeof] InstallTriggerImpl", boolC = false
	// FF60 or lower
	if (isFF && isVer < 61) {
		fnRecord(num+2, strC, zNA +": FF61+ required", zNA)
	} else {
		try {
			let t0C; if (canPerf) {t0C = performance.now()}
			if (bBlock) {bB = 1}
			let resC = typeof InstallTriggerImpl
			if (resC == "function") {boolC = true}
			let perfC = canPerf ? performance.now() - t0C : ""
			if (isVer > 99 && !boolC) {
				fnRecord(num+2, strC, zNA +": FF99 or lower" + s3 +" ["+ resC +"]"+ sc, zNA, "skip", perfC)
			} else {
				fnRecord(num+2, strC, resC, boolC, "skip", perfC)
			}
		} catch(e) {
			fnRecord(num+2, strC, e.name, zB0, e.message)
		}
	}
}

function get_intl_canonical_locale(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let list = ["bh","hye","no","tl","tw"], bool = false
		let res = []
		list.forEach(function(i) {
			res.push(i +": "+ Intl.getCanonicalLocales(i))
		})
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		if (hash == "3faffb36cf9adef10987c4e6cb5adc7562dac7ab") {bool = true // FF91+
		} else if (hash == "8d98821d21e515bc9bfa6660a744d74fc2df0de1") {bool = true // FF70-90
		} else if (hash == "db0b8b2137d972e0735df959d77dc67c2887404f") {bool = true // FF52-69
		}
		// FF60-69 : bh=bh,  hye=hye, no=no, tl=tl,  tw=tw
		// FF70-90 : bh=bho, hye=hy,  no=nb, tl=fil, tw=ak
		// FF91+   : bh=bho, hye=hy,  no=no, tl=fil, tw=ak
		// blink   : bh=bh,  hye=hy,  no=no, tl=fil, tw=tw
		// webkit  : bh=bh,  hye=hy,  no=no, tl=tl,  tw=tw
		if (res.length > 0) {
			sDetail["specific_"+ title] = res
			hash += buildButton(3, "specific_"+ title, "details")
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_intl_collator(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		// 22 FF60+ locales with unique collations not in chrome (lost my list vs webkit)
		// 24 chars: approx 40ms
		let list = ['az','cy','dsb','ee','eo','gl','ha','haw','hsb','ig',
			'ka','kk','ln','lo','mt','no','om','pa','se','sq','to','wo',]
		let	chars = ['c','C','ch','ez','n','ng','r','ts','tt','\u00E4','\u0107',
			'\u00E7\a','\u0109','\u00EB','\u00ED','\u00EE','\u0144','\u00F1','\u0649',
			'\u0453','\u10D0','\u0E9A','\u1D95','\u025B',]
		let res = [], unique = [], same = []
		// webkit has everything FF does for collation that can be detected
		// except in FF70+, no (same as fo), so swap that out
		if (isVer < 70 && isFF) {
			list.push("fo")
			list = list.filter(x => !["no"].includes(x))
		}
		list.sort()
		chars.sort() // reset
		let control = chars.sort(Intl.Collator(undefined).compare)
		control = mini(control.join(", "))
		let bool = false
		list.forEach(function(i) {
			chars.sort() // reset
			chars.sort(Intl.Collator(i).compare)
			let test = mini(chars.join(", "))
			unique.push(test)
			if (test == control) {same.push(test)}
			res.push(i +": "+ test + ": "+ chars.join(", "))
		})
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		if (bLog) {
			unique = unique.filter(function (item, position) {return unique.indexOf(item) === position})
			let counts = (unique.length == list.length) ? "100\u0025 unique" : "["+ unique.length + "/" + list.length +"]"
			counts += " ["+ same.length +" = control]"
			console.log(title +": "+ hash +", "+ counts +"\n", res)
		}
		if (isVer > 69) {
			if (hash == "d0f5826ab1779b1f489a3157d536240548fb7a82") {bool = true} // FF70+
		} else if (isVer > 58) {
			if (hash == "233b2298218fbe5661ca2381f1c1a0f100192a5a") {bool = true} // FF59-69
		} else {
			if (hash == "68b7a6e04692425631210ae21422edde04bbf094") {bool = true} // FF52-58
			if (hash == "233b2298218fbe5661ca2381f1c1a0f100192a5a") {bool = true} // WFClassic isVer = 58
		}
		if (res.length > 0) {
			sDetail["specific_"+ title] = res
			hash += buildButton(3, "specific_"+ title, "details")
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_intl_display_names(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let test = Intl.DisplayNames.supportedLocalesOf("en")
		// FF items not in chromium
			// remove: ig, om [same as en]
			// remove: sc (96), sa (91) [FF additions]
			// remove: ti, yo [CLDR data changes]
		let initialList = [
			'ak','as','ast','be','bm','bo','br','ce','ckb','cy','dsb','dz','ee','eo','eu',
			'ff','fo','fur','fy','ga','gd','gl','gv','ha','haw','hsb','hy','hye','ia',
			'ii','is','jv','ka','kab','ki','kk','kl','km','kok','ks','ku','kw','ky','lb',
			'lg','ln','lo','lu','mai','mg','mi','mk','mn','mt','my','nd','ne','nn','or',
			'os','ps','qu','rm','rn','rw','sat','sd','se','sg','si','sn','so','sq',
			'su','tg','tk','to','tt','ug','wo','xh','yi','zu',
		]
		// shrink size for perf: pending webkit results
		let list = [
			'bo','fo','gl','haw','hye','kl','mai','os','su','tt','ug','xh'
		]
		let options = {type: 'region'},
			testValue = "US",
			res = []
		let englishVersion = new Intl.DisplayNames('en', options).of(testValue)
		list.forEach(function(locale) {
			try {
				let value = new Intl.DisplayNames(locale, options).of(testValue)
				if (value !== englishVersion) {
					res.push(locale + ":"+ value)
				}
			} catch(e) {}
		})
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		// 86+ (85 not supprted)
		let bool = hash == "d02cec4400b8157766ef7913ecfde210ebcd0c72"
		if (res.length > 0) {
			sDetail["specific_"+ title] = res
			hash += buildButton(3, "specific_"+ title, res.length)
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		// FF85-: TypeError: Intl.DisplayNames is undefined
		if (isFF) {
			if (isVer > 85) {
				fnRecord(num, title, e.name, zB0, e.message)
			} else {
				let msg = e.message
				msg = msg.replace("can't access property \"supportedLocalesOf\", ", "") // trim *error_fix
				if (e.name == "TypeError" && msg == "Intl.DisplayNames is undefined") {
					fnRecord(num, title, zNA +": FF86+ required", zNA)
				} else {
					fnRecord(num, title, e.name, zB0, e.message)
				}
			}
		} else {
			fnRecord(num, title, zNA +": not supported", zNA)
		}
	}
}

function get_intl_dtf(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let list = [
			'ak','ast','be','bm','bo','ce','ckb','eo','no','to', // gecko not in blink
		]
		let bool = false
		let date = new Date("January 30, 2019 13:00:00"),
			options = {weekday: "long", month: "long", day: "numeric", year: "numeric", hour: "numeric",
				minute: "numeric", second: "numeric", hour12: true}
		let res = [], unique = [], same = []
		if (isVer < 70 && isFF) {
			list.push("fo")
			list = list.filter(x => !["no"].includes(x))
		}
		list.sort()
		let control = Intl.DateTimeFormat(undefined, options).format(date)
		list.forEach(function(locale) {
			let test = Intl.DateTimeFormat(locale, options).format(date)
			unique.push(test)
			if (test == control) {same.push(locale)}
			res.push(locale +": "+ test)
		})
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		if (bLog) {
			unique = unique.filter(function (item, position) {return unique.indexOf(item) === position})
			let counts = (unique.length == list.length) ? "100\u0025 unique" : "["+ unique.length + "/" + list.length +"]"
			counts += " ["+ same.length +" = control]"
			console.log(title +": "+ hash +", "+ counts +"\n", res)
		}
		if (isVer > 100) {
			if (hash == "b1a2b0aeee7676bcc5af6288a6a87a6e38297f9d") {bool = true} // FF101+
		} else if (isVer > 69) {
			if (hash == "585f6274d0c9ac34dc38fe6d8f3a097a4adb56eb") {bool = true} // FF70-100
		} else if (isVer > 58) {
			if (hash == "1ad9a85853870481a0474f468d987275eff41b58") {bool = true} // FF59-69
		} else {
			if (hash == "1d713eb38d8a7404e3706417452f86c1f1d54ad5") {bool = true} // FF55-57 RFP
			if (hash == "aad03d05ff68316a337321f88f88bae4d4577374") {bool = true} // FF52-58
			//if (hash == "5e50264aff470447e8c19c899061eada3528ed45") {bool = true} // WFClassic52 RFP // IDK + IDC what the new mini is
			if (hash == "1ad9a85853870481a0474f468d987275eff41b58") {bool = true} // WFClassic isVer = 58
		}
		if (res.length > 0) {
			sDetail["specific_"+ title] = res
			hash += buildButton(3, "specific_"+ title, "details")
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_intl_list_format(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let test = Intl.ListFormat.supportedLocalesOf("en")
		// FF items not in chromium
			// remove: ug [same as en]
			// remove: sc (96), sa (91), [FF additions]
			// remove: ga, ha, ks, my, rm, ti [CLDR data changes]
		let initialList = [
			'ak','as','ast','be','bm','bo','br','ce','ckb','cy','dsb','dz','ee','eo','eu',
			'ff','fo','fur','fy','gd','gl','gv','haw','hsb','hy','hye','ia','ig',
			'ii','is','jv','ka','kab','ki','kk','kl','km','kok','ku','kw','ky','lb',
			'lg','ln','lo','lu','mai','mg','mi','mk','mn','mt','nd','ne','nn','om','or',
			'os','ps','qu','rn','rw','sat','sd','se','sg','si','sn','so','sq',
			'su','tg','tk','to','tt','wo','xh','yi','yo','zu',
		]
		// shrink size for perf: pending webkit results
		let list = [
			'cy','dsb','dz','fur','jv','kab','kok','lu','mg','mk','qu','tk','wo','zu',
		]
		let options = {style: 'long', type: 'conjunction'},
			testValue = ['a','b','c'],
			res = []
		let englishValue = new Intl.ListFormat('en', options).format(testValue)
		list.forEach(function(locale) {
			try {
				let value = new Intl.ListFormat(locale, options).format(testValue)
				if (value !== englishValue) {
					res.push(locale + ":"+ value)
				}
			} catch(e) {}
		})
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		// 78+ (77 not supported)
		let bool = hash == "37904e6ef31c1ebad32315c45e444bdd8b50408b"
		if (res.length > 0) {
			sDetail["specific_"+ title] = res
			hash += buildButton(3, "specific_"+ title, res.length)
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		// FF77-: TypeError: Intl.ListFormat is undefined
		if (isFF) {
			if (isVer > 77) {
				fnRecord(num, title, e.name, zB0, e.message)
			} else {
				let msg = e.message
				msg = msg.replace("can't access property \"supportedLocalesOf\", ", "") // trim *error_fix
				if (e.name == "TypeError" && msg == "Intl.ListFormat is undefined") {
					fnRecord(num, title, zNA +": FF78+ required", zNA)
				} else {
					fnRecord(num, title, e.name, zB0, e.message)
				}
			}
		} else {
			fnRecord(num, title, zNA +": not supported", zNA)
		}
	}
}

function get_intl_number_format(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let list = [
			'tl','tw', // gecko not in webkit: also 'no', and also FF70+ 'mai','su'
			'bo','lb', // gecko not in blink: also 'se','to',
			'co','cv', // webkit only: also 'nso','oc','tig',
		]
		let res = []
		list.forEach(function(locale) {
			let test = Intl.NumberFormat.supportedLocalesOf(locale)
			if (test.length) {res.push(locale)}
		})
		res.sort()
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		let bool = false
		if (hash == "fe8eedb41e7748cc7126c8e8daca835eca1d00ec") {bool = true // FF70+
		} else if (hash == "73aa043db2c050c1d4ba06efe61678c1a1bb3ddc") {bool = true // FF52-69
		}
		if (res.length > 0) {
			sDetail["specific_"+ title] = res
			hash += buildButton(3, "specific_"+ title, res.length)
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_intl_pluralrules(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let list = [
			'mai','no','su','tl','tw', // gecko not in webkit: FF70/78
			'ki','qu', // some FF60+ gecko not in blink
			'an','lij','vo', // chrome only
			'ba','co','cv','gn','oc', // webkit only
		]
		let res = []
		list.forEach(function(locale) {
			let test = Intl.PluralRules.supportedLocalesOf(locale)
			if (test.length) {res.push(locale)}
		})
		res.sort()
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		let bool = false
		if (hash == "29e30922fde2245232cc2c4ab2cbb4f511fdf694") {bool = true // FF78+
		} else if (hash == "b80aaf574257b7b13b5f06ffdeb5f8612a3faf1d") {bool = true // FF70-77
		} else if (hash == "b9b71087a7b043ee6c0c0e383b0baf99aa92b83b") {bool = true // FF58-69
		}
		if (res.length > 0) {
			sDetail["specific_"+ title] = res
			hash += buildButton(3, "specific_"+ title, res.length)
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		// FF57 or lower
		let result = e.name
		let type = zB0
		let error = e.message
		if (isVer < 59 && e.message == "Intl.PluralRules is undefined") {
			result = zNA +": FF58+ required"
			type = zNA
			error = undefined
		}
		fnRecord(num, title, result, type, error)
	}
}

function get_intl_rtf(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let test = Intl.RelativeTimeFormat.supportedLocalesOf("en")
		// FF items not in chromium
			// remove: ckb, eo, gv, haw, kl, kw, om, rw, xh [same as en]
			// remove: hye, mai, ps, sa, sat, sc, su, tw [FF additions]
			// remove: ha, ig [CLDR data changes]
		let initialList = [
			'ak','as','ast','be','bm','bo','br','ce','cy','dsb','dz','ee','eu',
			'ff','fo','fur','fy','ga','gd','gl','hsb','hy','ia','ii','is','jv',
			'ka','kab','ki','kk','km','kok','ks','ku','ky','lb','lg','ln','lo','lu',
			'mg','mi','mk','mn','mt','my','nd','ne','nn','or','os','qu','rm','rn',
			'sd','se','sg','si','sn','so','sq','tg','ti','tk','to','tt',
			'ug','wo','yi','yo','zu',
		]
		// shrink size for perf: pending webkit results
		let list = [
			'cy','dsb','dz','fur','jv','kab','kok','lu','mg','mk','qu','tk','wo','zu',
		]
		let options = {style: 'long', numeric: 'auto'},
			testValue = ['a','b','c'],
			res = []
		let englishVersion = new Intl.RelativeTimeFormat('en', options).format(-1, "day")
		list.forEach(function(locale) {
			try {
				let value = new Intl.RelativeTimeFormat(locale, options).format(-1, "day")
				if (value !== englishVersion) {
					res.push(locale + ":"+ value)
				}
			} catch(e) {}
		})
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		// 65+ (64 not supported)
		let bool = hash == "5fa5d59b752a4e58127159c8b9d51ada8d84e238"
		if (res.length > 0) {
			sDetail["specific_"+ title] = res
			hash = hash+= buildButton(3, "specific_"+ title, res.length)
			//hash += s3 +" ["+ res.length +"]"+sc
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		// FF64-: TypeError: Intl.RelativeTimeFormat is undefined
		if (isFF) {
			if (isVer > 64) {
				fnRecord(num, title, e.name, zB0, e.message)
			} else {
				if (e.name == "TypeError" && e.message == "Intl.RelativeTimeFormat is undefined") {
					fnRecord(num, title, zNA +": FF65+ required", zNA)
				} else {
					fnRecord(num, title, e.name, zB0, e.message)
				}
			}
		} else {
			fnRecord(num, title, zNA +": not supported", zNA)
		}
	}
}

function get_js_client_hints(num, title) {
	// testing: https://web.dev/user-agent-client-hints/
	// https://user-agent-client-hints.glitch.me/javascript.html
	// TypeError can't access property "X", navigator.X is undefined
	function output() {
		let perf = canPerf ? performance.now() - t0 : ""
		if (res.length > 0) {
			res.sort()
			sDetail["unexpected_"+ title] = res
			let hash = mini_sha1(res.join()) + buildButton(3, "unexpected_"+ title , res.length)
			fnRecord(num, title, hash, false, "skip", perf)
		} else {
			fnRecord(num, title, "none", true, "skip", perf)
		}
	}
	let res = []
	let t0; if (canPerf) {t0 = performance.now()}

	try {
		let resB = navigator.userAgentData.brands
		resB.forEach(function(object) {
			let valueB = fnClean(object.version)
			res.push("brands: "+ object.brand +": "+ valueB)
		})
	} catch(e) {}
	try {
		res.push("mobile: " + navigator.userAgentData.mobile)
	} catch(e) {}
	try {
		res.push("platform: " + navigator.userAgentData.platform)
	} catch(e) {}
	try {
		navigator
			.userAgentData.getHighEntropyValues(
				["architecture","bitness","brands","mobile","model","platform","platformVersion","uaFullVersion"]
			).then(ua => {
				const names = Object.keys(ua)
				for (const k of names) {
					let valueU = fnClean(ua[k])
					res.push("high entropy: "+ k +": "+ valueU)
				}
				output()
			})
	} catch(e) {
		output()
	}
}

function get_last_prototype_keys(num1, title) {
	// HTMLAnchorElement
	let title1 = title +" HTMLAnchorElement"
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		Object.keys(HTMLAnchorElement.prototype)
		let props1 = Object.getOwnPropertyNames(HTMLAnchorElement.prototype) // includes the constructor
		let res1 = props1.slice(-3).join(", ")
		// search, hash, constructor
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num1, title1, res1, res1 == "search, hash, constructor", "skip", perf)
	} catch(e) {
		fnRecord(num1, title1, e.name, zB0, e.message)
	}

	// HTMLLinkElement
	let title2 = title +" HTMLLinkElement"
	let num2 = num1 + 1
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		Object.keys(HTMLLinkElement.prototype)
		let props2 = Object.getOwnPropertyNames(HTMLLinkElement.prototype) // includes the constructor
		let res2 = props2.slice(-3).join(", ")
		let bool2 = res2 == "as, sheet, constructor"
		// 52-55: integrity, sheet, constructor
		if (isVer <= 56 && res2 == "integrity, sheet, constructor") {bool2 = true}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num2, title2, res2, bool2, "skip", perf)
	} catch(e) {
		fnRecord(num2, title2, e.name, zB0, e.message)
	}
}

function get_locale_compare(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let bool = false
		let list = [
			["az","\u00F6","\u1EE3"],
			["cy","n","ng"],
			["dsb","\u0144","\u00F1"],
			["ee","ts","tt"],
			["eo","\u0109","\u00E7\a"],
			["gl","\u00F1","ng"],
			["ha","ts","tt"],
			["haw","\u00F0","\u00EB"],
			["hsb","\u0107","\u0109"],
			["ig","c","ch"],
			["ka","\u0107","\u10D0"],
			["kk","r","\u0453"],
			["ln","\u1D95","\u025B"],
			["lo","\u0107","\u0E9A"],
			["mt","c","C"],
			["no","\u00F6","\u1EE3"],
			["om","ch","\u00ED"],
			["pa","\u0107","\u0649"],
			["se","\u00F6","\u1EE3"],
			["sq","\u00EB","ez"],
			["to","\u00ED","\u00EE"],
			["wo","\u00EB","ez"],
		]
		let res = [], same = []
		// webkit: see intl.collator notes: swap "fo" with "no" FF70+
		list.forEach(function(item) {
			let code = item[0]
			if (isVer < 70 && isFF && code == "no") {code = "fo"} // isFF only
			let strA = item[1]
			let test = strA.localeCompare(item[2], code)
			if (test !== 1) {same.push(code)}
			res.push(code +": "+ test +": "+ strA +", "+ item[2])
		})
		res.sort()
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		if (bLog) {
			let counts = " ["+ same.length +" = control]"
			console.log(title +": "+ hash +", "+ counts +"\n", res)
		}
		if (isVer > 69) {
			if (hash == "393aaf6098964d36ba5226124e7d984ca9b8175c") {bool = true} // FF70+
		} else if (isVer > 58) {
			if (hash == "73c32218f24756075e3b0c79901a192a1d313f9c") {bool = true} // FF59-69
		} else {
			if (hash == "aa2310c50d847d996ca9b5cc3a58808c34c6af6a") {bool = true} // FF52-58
			if (hash == "73c32218f24756075e3b0c79901a192a1d313f9c") {bool = true} // WFClassic isVer = 58
		}
		if (res.length > 0) {
			sDetail["expected_"+ title] = res
			hash += buildButton(3, "expected_"+ title, "details")
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_math(num, title) {
	// polyfill
	function cbrt(x) {
		try {
			let y = Math.pow(Math.abs(x), 1 / 3)
			return x < 0 ? -y : y
		} catch(e) {
			return "error"
		}
	}
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let res = []
		for(let i=0; i < 6; i++) {
			try {
				let fnResult = "unknown"
				if (i == 0) {fnResult = cbrt(Math.PI) // polyfill
				} else if (i == 1) {fnResult = Math.log10(7*Math.LOG10E)
				} else if (i == 2) {fnResult = Math.log10(2*Math.SQRT1_2)
				} else if (i == 3) {fnResult = Math.acos(0.123)
				} else if (i == 4) {fnResult = Math.acosh(Math.SQRT2)
				} else if (i == 5) {fnResult = Math.atan(2)
				}
				res.push(fnResult)
			} catch(e) {
				res.push("error")
			}
		}
		// I have to use sha1 due to legacy data
		let hash = sha1(res.join()).substring(0,20)
		let engine = "unkown"
		if (hash == "ede9ca53efbb1902cc21") {engine = "blink"
		} else if (hash == "05513f36d87dd78af60a") {engine = "webkit"
		} else if (hash == "38172d9426d77af71baa") {engine = "edgeHTML"
		} else if (hash == "36f067c652c8cfd90725") {engine = "trident"
		} else if (hash == "225f4a612fdca4065043") {engine = "gecko"
		} else if (hash == "cb89002a8d6fabf859f6") {engine = "gecko"
		}
		let bool = engine == "gecko" ? true : false
		// now redo as mini_sha1
		sDetail["expected_"+ title] = res
		hash = mini_sha1(res.join()) + buildButton(3, "expected_"+ title, engine)
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_media_constraints(num, title) {
	// blink: 18c59e90bb3af0ce32be8efaa4457ead01fcacd8 [32]
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let data = navigator.mediaDevices.getSupportedConstraints()
		let res = Object.keys(data)
		res.sort()
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		let bool = false
		if (isVer > 69) {
			if (hash == "869109a73d3128c2eb4a8277aff0fec0cf8d0e47") {bool = true} // FF70+
		} else {
			if (hash == "499818d3e86b70bd61300a52f1429bb359365890") {bool = true} // FF56-69
			if (isVer < 57) {
				if (hash == "c536cceca9d2a679656c7d785e6ada5e5a9016cb") {bool = true} // FF55
			}
			if (isVer < 55) {
				if (hash == "846c4bd6379d808ac2d2890954e7f909ba2b9458") {bool = true} // FF52-54
			}
		}
		if (res.length > 0) {
			sDetail["expected_"+ title] = res
			hash += buildButton(3, "expected_"+ title, res.length)
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		// e.g. TB disables mediaDevices
		let error = mini(e.name +": "+ e.message), isNA = false
		if (error == "f2244861") {
			// TypeError: can't access property "getSupportedConstraints", navigator.mediaDevices is undefined
			isNA = true
		} else if (error == "9fc627cf") {
			// TypeError: navigator.mediaDevices is undefined
			isNA = true
		}
		if (isNA) {
			fnRecord(num, title, zNA +": disabled", zNA)
		} else {
			fnRecord(num, title, e.name, zB0, e.message)
		}
	}
}

function get_mimetypes(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		if ("mimeTypes" in navigator) {
			let res = [], bool = false
			let m = navigator.mimeTypes
			if (m.length == 0) {
				fnRecord(num, title, "none", true)
			} else {
				for (let i=0; i < m.length; i++) {
					res.push( m[i].type + (m[i].description == "" ? ": * " : ": "+ m[i].type)
						+ (m[i].suffixes == "" ? ": *" : ": "+ m[i].suffixes) )
				}
				res.sort()
				// FF84 or lower allow just Flash
				if (isFF && isVer < 85 && res.length == 2) {
					let mime1 = res[0].split(":")[0]
					let mime2 = res[1].split(":")[0]
					if (mime1 == "application/x-futuresplash" && mime2 == "application/x-shockwave-flash") {
						bool = true
					}
				}
				let hash = mini_sha1(res.join())
				if (isVer > 98 || !isFF) { // allow non-FF to have the same
					// FF99+: controlled by pdfjs.disabled
					// 1720353: hardcoded mimeTypes
					if (hash == "5b8b5b83ff5790df763d417ec6e2adbbf0570c47") {
						bool = true
					}
				}
				sDetail["expected_"+ title] = res
				hash += buildButton(3, "expected_"+ title, res.length)
				let perf = canPerf ? performance.now() - t0 : ""
				fnRecord(num, title, hash, bool, "skip", perf)
			}
		} else {
			fnRecord(num, title, e.name, zB0)
		}
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_moz_colors(num, title) {
	let aList = [
		// css4
		'-moz-activehyperlinktext','-moz-default-color','-moz-default-background-color','-moz-hyperlinktext','-moz-visitedhyperlinktext',
		// stand-ins
		'-moz-buttondefault','-moz-buttonhoverface','-moz-buttonhovertext','-moz-cellhighlight','-moz-cellhighlighttext','-moz-combobox','-moz-comboboxtext','-moz-dialog','-moz-dialogtext','-moz-dragtargetzone','-moz-eventreerow','-moz-field','-moz-fieldtext','-moz-html-cellhighlight','-moz-html-cellhighlighttext','-moz-mac-chrome-active','-moz-mac-chrome-inactive','-moz-mac-disabledtoolbartext','-moz-mac-focusring','-moz-mac-menuselect','-moz-mac-menushadow','-moz-mac-menutextdisable','-moz-mac-menutextselect','-moz-mac-secondaryhighlight','-moz-menubarhovertext','-moz-menubartext','-moz-menuhover','-moz-menuhovertext','-moz-nativehyperlinktext','-moz-oddtreerow','-moz-win-communicationstext','-moz-win-mediatext',
		// moz
		'-moz-accent-color','-moz-accent-color-foreground','-moz-appearance','-moz-colheaderhovertext','-moz-colheadertext','-moz-gtk-buttonactivetext','-moz-gtk-info-bar-text','-moz-mac-accentdarkestshadow','-moz-mac-accentdarkshadow','-moz-mac-accentface','-moz-mac-accentlightesthighlight','-moz-mac-accentlightshadow','-moz-mac-accentregularhighlight','-moz-mac-accentregularshadow','-moz-mac-active-menuitem','-moz-mac-active-source-list-selection','-moz-mac-buttonactivetext','-moz-mac-defaultbuttontext','-moz-mac-menuitem','-moz-mac-menupopup','-moz-mac-source-list','-moz-mac-source-list-selection','-moz-mac-tooltip','-moz-mac-vibrancy-dark','-moz-mac-vibrancy-light','-moz-mac-vibrant-titlebar-dark','-moz-mac-vibrant-titlebar-light','-moz-win-accentcolor','-moz-win-accentcolortext','-moz-win-communications-toolbox','-moz-win-media-toolbox',
	]
	aList.sort()
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let aRes = []
		let element = dom.mozColor
		let strColor = "rgba(1, 2, 3, 0.5)"
		aList.forEach(function(style) {
			element.style.backgroundColor = strColor // always reset
			element.style.backgroundColor = style
			let rgb = window.getComputedStyle(element, null).getPropertyValue("background-color")
			if (rgb !== strColor) {
				aRes.push(style +":"+ rgb) // only record those affected
			}
		})
		let bool = aRes.length > 0
		if (bool) {
			sDetail["expected_"+ title] = aRes
		}
		let hash = bool ? mini_sha1(aRes.join()) + buildButton(3, "expected_"+ title, aRes.length) : "none"
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_moz_computed_styles(num, title) {
	/* https://github.com/abrahamjuliot/creepjs */
	let t0; if (canPerf) {t0 = performance.now()}

	let styleVersion = type => {
		return new Promise(resolve => {
			// get CSSStyleDeclaration
			try {
				if (bBlock) {bB = 1}
				let cssStyleDeclaration = (
					type == 0 ? getComputedStyle(document.body) :
					type == 1 ? document.body.style :
					type == 2 ? document.styleSheets[0].cssRules[0].style :
					undefined
				)
				if (!cssStyleDeclaration) {
					throw new TypeError("invalid argument string")
				}
				// get properties
				let prototype = Object.getPrototypeOf(cssStyleDeclaration),
					prototypeProperties = Object.getOwnPropertyNames(prototype),
					ownEnumerablePropertyNames = [],
					cssVar = /^--.*$/
				Object.keys(cssStyleDeclaration).forEach(key => {
					let numericKey = !isNaN(key),
						value = cssStyleDeclaration[key],
						customPropKey = cssVar.test(key),
						customPropValue = cssVar.test(value)
					if (numericKey && !customPropValue) {
						return ownEnumerablePropertyNames.push(value)
					} else if (!numericKey && !customPropKey) {
						return ownEnumerablePropertyNames.push(key)
					}
					return
				})
				// get properties in prototype chain (required only in chrome)
				let propertiesInPrototypeChain = {}
				let capitalize = str => str.charAt(0).toUpperCase() + str.slice(1),
					uncapitalize = str => str.charAt(0).toLowerCase() + str.slice(1),
					removeFirstChar = str => str.slice(1),
					caps = /[A-Z]/g
				ownEnumerablePropertyNames.forEach(key => {
					if (propertiesInPrototypeChain[key]) {
						return
					}
					// determine attribute type
					let isNamedAttribute = key.indexOf('-') > -1,
						isAliasAttribute = caps.test(key)
					// reduce key for computation
					let firstChar = key.charAt(0),
						isPrefixedName = isNamedAttribute && firstChar == '-',
						isCapitalizedAlias = isAliasAttribute && firstChar == firstChar.toUpperCase()
					key = (
						isPrefixedName ? removeFirstChar(key) :
						isCapitalizedAlias ? uncapitalize(key) :
						key
					)
					// find counterpart in CSSStyleDeclaration object or its prototype chain
					if (isNamedAttribute) {
						let aliasAttribute = key.split('-').map((word, index) => index == 0 ? word : capitalize(word)).join('')
						if (aliasAttribute in cssStyleDeclaration) {
							propertiesInPrototypeChain[aliasAttribute] = true
						} else if (capitalize(aliasAttribute) in cssStyleDeclaration) {
							propertiesInPrototypeChain[capitalize(aliasAttribute)] = true
						}
					} else if (isAliasAttribute) {
						let namedAttribute = key.replace(caps, char => '-' + char.toLowerCase())
						if (namedAttribute in cssStyleDeclaration) {
							propertiesInPrototypeChain[namedAttribute] = true
						} else if (`-${namedAttribute}` in cssStyleDeclaration) {
							propertiesInPrototypeChain[`-${namedAttribute}`] = true
						}
					}
					return
				})
				// compile keys
				let keys = [
					...new Set([
						...prototypeProperties,
						...ownEnumerablePropertyNames,
						...Object.keys(propertiesInPrototypeChain)
					])
				]
				// checks
				let moz = keys.filter(key => (/moz/i).test(key)) //.length,
					//webkit = keys.filter(key => (/webkit/i).test(key)).length,
					//prototypeName = ('' + prototype).match(/\[object (.+)\]/)[1]
				// output
				return resolve({
					//keys,
					moz
					//webkit,
					//prototypeName
				})
			} catch(e) {
				fnRecord(num, title, e.name, zB0, e.message)
				return resolve("error")
			}
		})
	}

	// run
	Promise.all([
		styleVersion(0), // we only need one result
	]).then(res => {
		if (res == "error") {
			return
		}
		try {
			let aRes = res[0]["moz"]
			aRes.sort()
			let bool = aRes.length > 0
			if (bool) {
				sDetail["expected_"+ title] = aRes
			}
			let hash = bool ? mini_sha1(aRes.join()) + buildButton(3, "expected_"+ title, aRes.length) : "none"
			bool = aRes.length > 50 // just in case someone spoofs a couple, or older/other browsers have some
			let perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num, title, hash, bool, "skip", perf)
		} catch(err) {
			fnRecord(num, title, err.name, zB0, err.message)
		}
	}).catch(error => {
		fnRecord(num, title, error.name, zB0, error.message)
	})
}

function get_moz_fonts(num, title) {
	let aResults = [],
		m = "-moz-",
		aFonts = [m+"window",m+"desktop",m+"document",m+"workspace",m+"info",m+"pull-down-menu",m+"dialog",m+"button",m+"list",m+"field"]
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		let el = dom.mozFont
		if (bBlock) {bB = 1}
		aFonts.forEach(function(font){
			// catch blocked
			let test = getComputedStyle(el).getPropertyValue("font-family")
			el.style.font = "99px sans-serif"
			try {el.style.font = font} catch(err) {}
			let s = ""
			if (window.getComputedStyle) {
				try {
					s = getComputedStyle(el, null)
				} catch(e) {}
			}
			if (s !== "") {
				let f = s.fontSize != "99px" ? s.fontFamily : undefined
				if (f !== undefined) {aResults.push(f)}
			}
		})
		let bool = aResults.length > 0
		if (bool) {
			sDetail["expected_"+ title] = aResults
		}
		let hash = bool ? mini_sha1(aResults.join()) + buildButton(3, "expected_"+ title, aResults.length) : "none"
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_nav_keys(num1, num2, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let aNavKeys = Object.keys(Object.getOwnPropertyDescriptors(Navigator.prototype))
		// expected FF only
		let aExpected = ["buildID","oscpu","taintEnabled"]
		let resE = aNavKeys.filter(x => aExpected.includes(x))
		let boolE = resE.length == 3 ? true : false
		resE = resE.length > 0 ? resE.join(", ") : "none"
		let perfE = canPerf ? performance.now() - t0 : ""
		fnRecord(num1, title, resE, boolE, "skip", perfE)

		// not expected: blink items
		let aNot = ["canShare","clearAppBadge","deviceMemory","getBattery","getInstalledRelatedApps",
			"getUserMedia","globalPrivacyControl","hid","keyboard","locks","managed","presentation","scheduling",
			"serial","setAppBadge","unregisterProtocolHandler","usb","userActivation","userAgentData","wakeLock",
			"webkitGetUserMedia","webkitPersistentStorage","webkitTemporaryStorage","xr","SharedWorker","Worker"]
		// FYI: don't use requestMIDIAccess: FF60+ behind dom.webmidi.enabled... 1752906: FF99+ default enabled
		if (isVer > 95) {
			// 1666203: FF96+ canShare
			aNot = aNot.filter(x => !["canShare"].includes(x))
		}
		if (isVer > 94 || isEngine == "goanna") {
			// 1670058: FF95+ globalPrivacyControl
			// PM 30
			aNot = aNot.filter(x => !["globalPrivacyControl"].includes(x))
		}
		if (isVer > 92) {
			// FF93+ "dom.weblocks.enabled"
			// 1739233: FF96+ locks
			aNot = aNot.filter(x => !["locks"].includes(x))
		}
		let resN = aNavKeys.filter(x => aNot.includes(x))
		let boolN = resN.length == 0
		if (resN.length > 0) {
			sDetail["unexpected_"+ title] = resN
			resN = mini_sha1(resN.join()) + buildButton(3, "unexpected_"+ title, resN.length)
		} else {
			resN = "none"
		}
		let perfN = canPerf ? performance.now() - t0 : ""
		fnRecord(num2, title, resN, boolN, "skip", perfN)
	} catch(e) {
		fnRecord(num1, title, e.name, zB0, e.message)
		fnRecord(num2, title, e.name, zB0, e.message)
	}
}

function get_nav_screen(num) {
	let strA = "[left] screen", boolA = false
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = screen.left
		if (!isNaN(resA)) {boolA = true} else {resA = fnClean(resA)}
		let perfA = canPerf ? performance.now() - t0A : ""
		fnRecord(num, strA, resA, boolA, "skip", perfA)
	} catch(e) {
		fnRecord(num, strA, e.name, zB0, e.message)
	}
	let strB = "[top] screen", boolB = false
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = screen.top
		if (!isNaN(resB)) {boolB = true} else {resB = fnClean(resB)}
		let perfB = canPerf ? performance.now() - t0B : ""
		fnRecord(num+1, strB, resB, boolB, "skip", perfB)
	} catch(e) {
		fnRecord(num+1, strB, e.name, zB0, e.message)
	}
}

function get_nav_values(num1, num2, num3) {
	// expected
	let strA = "[oscpu] navigator", boolA = false
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = navigator.oscpu
		if (typeof resA !== "string") {
			//console.debug(typeof resA)
		} else {
			if (resA == "") {resA = "empty string"
			} else if (resA == undefined) {resA = zU
			} else if (resA == zU) {resA = zUQ
			} else {boolA = true}
		}
		let perfA = canPerf ? performance.now() - t0A : ""
		fnRecord(num1, strA, resA, boolA, "skip", perfA)
	} catch(e) {
		fnRecord(num1, strA, e.name, zB0, e.message)
	}

	// not expected
	// bluetooth
	let strBT = "[bluetooth] navigator", boolBT = false, numBT = num2
	try {
		let t0BT; if (canPerf) {t0BT = performance.now()}
		if (bBlock) {bB = 1}
		let resBT = navigator.bluetooth
		if (resBT === undefined) {
			let perfBT = canPerf ? performance.now() - t0BT : ""
			fnRecord(numBT, strBT, zU, true, "skip", perfBT)
		} else {
			try {
				navigator.bluetooth.getAvailability().then(available => {
					if (available) {
						fnRecord(numBT, strBT, "supported", boolBT)
					} else {
						fnRecord(numBT, strBT, "not supported", boolBT)
					}
				})
			} catch(e) {
				fnRecord(numBT, strBT, e.name, zB0)
			}
		}
	} catch(e) {
		fnRecord(numBT, strBT, e.name, zB0, e.message)
	}
	// deviceMemory
	let strDM = "[deviceMemory] navigator", boolDM = false, numDM = num2+2
	try {
		let t0DM; if (canPerf) {t0DM = performance.now()}
		if (bBlock) {bB = 1}
		let resDM = navigator.deviceMemory
		if (resDM == undefined) {boolDM = true}
		resDM = fnClean(resDM)
		let perfDM = canPerf ? performance.now() - t0DM : ""
		fnRecord(numDM, strDM, resDM, boolDM, "skip", perfDM)
	} catch(e) {
		fnRecord(numDM, strDM, e.name, zB0, e.message)
	}

	// globalprivacycontrol
	let strG = "[gpc] navigator", boolG = false, numG = num2+6
	try {
		let t0G; if (canPerf) {t0G = performance.now()}
		if (bBlock) {bB = 1}
		let resG = navigator.globalPrivacyControl
		resG = fnClean(resG)
		if (resG == "undefined") {boolG = true
		} else if (isEngine == "goanna" && resG == "empty string") {boolG = true; resG += s3 + " [goanna]"+ sc}

		// 1670058: FF95+ globalPrivacyControl
		if (isVer > 94) {
			resG = zNA +": FF94 or lower" + s3 +" ["+ resG +"]" + sc
			boolG = zNA
		}
		let perfG = canPerf ? performance.now() - t0G : ""
		fnRecord(numG, strG, resG, boolG, "skip", perfG)
	} catch(e) {
		fnRecord(numG, strG, e.name, zB0, e.message)
	}

	// keyboard
	let strK = "[keyboard] navigator", numK = num2+8
	let t0K, perfK; if (canPerf) {t0K = performance.now()}
	try {
		if (bBlock) {bB = 1}
		let resK = navigator.keyboard
		if (resK == undefined) {
			perfK = canPerf ? performance.now() - t0K : ""
			fnRecord(numK, strK, "undefined", true, "skip", perfK)
		} else {
			let keys = []
			// https://wicg.github.io/keyboard-map/
			// https://www.w3.org/TR/uievents-code/#key-alphanumeric-writing-system
			let listK = ['Backquote','Backslash','Backspace','BracketLeft','BracketRight','Comma',
				'Digit0','Digit1','Digit2','Digit3','Digit4','Digit5','Digit6','Digit7','Digit8','Digit9',
				'Equal','IntlBackslash','IntlRo','IntlYen','KeyA','KeyB','KeyC','KeyD','KeyE','KeyF','KeyG',
				'KeyH','KeyI','KeyJ','KeyK','KeyL','KeyM','KeyN','KeyO','KeyP','KeyQ','KeyR','KeyS','KeyT',
				'KeyU','KeyV','KeyW','KeyX','KeyY','KeyZ','Minus','Period','Quote','Semicolon','Slash']
			resK.getLayoutMap().then(keyboardLayoutMap => {
				listK.forEach(function(key) {
					try {keys.push(key +": "+ keyboardLayoutMap.get(key))} catch(e) {keys.push(key +": e.name")}
				})
				sDetail["unexpected_"+ strK] = keys
				let hash = mini_sha1(keys.join()) + buildButton(3, "unexpected_"+ strK , keys.length)
				perfK = canPerf ? performance.now() - t0K : ""
				fnRecord(numK, strK, hash, false, "skip", perfK)
			})
		}
	} catch(e) {
		fnRecord(numK, strK, e.name, zB0, e.message)
	}

	// vendor
	let strV = "[vendor] navigator", boolV = false, numV = num2+10
	try {
		let t0V; if (canPerf) {t0V = performance.now()}
		if (bBlock) {bB = 1}
		let resV = navigator.vendor
		if (resV == "") {boolV = true}
		resV = fnClean(resV)
		let perfV = canPerf ? performance.now() - t0V : ""
		fnRecord(numV, strV, resV, boolV, "skip", perfV)
	} catch(e) {
		fnRecord(numV, strV, e.name, zB0, e.message)
	}

	// navigator.webkitTemporaryStorage.queryUsageAndQuota
		// "TypeError: can't access property "queryUsageAndQuota", navigator.webkitTemporaryStorage is undefined"
	// navigator.webkitPersistentStorage.queryUsageAndQuota
		// "TypeError: can't access property "queryUsageAndQuota", navigator.webkitPersistentStorage is undefined"

	// specific
	let strX = "[buildID] navigator", boolX = false
	try {
		let t0X; if (canPerf) {t0X = performance.now()}
		if (bBlock) {bB = 1}
		let resX = navigator.buildID
		if (isVer > 63) {
			// all FF64+
			if (resX == "20181001000000") {boolX = true}
		} else {
			resX = fnClean(resX)
			// FF52-63: 14 digit number starting with 2017
			let year = resX.slice(0,4) *1
			if (resX.length == 14) {
				let isCheck = false
				if (year > 2016 && year < 2020) {isCheck = true}
				if (isVer < 59) {if (year > 2016) {isCheck = true}} // FF52 waterfox basilisk palemoon
				if (isCheck) {
					if (!isNaN(resX * 1)) {boolX = true}
				}
			} else if (isRFP) {
				// luckily RFP only alters buildID starting FF56
				// RFP FF56-63 = 20100101
				if (resX == "20100101") {boolX = true}
			}
		}
		let perfX = canPerf ? performance.now() - t0X : ""
		fnRecord(num3, strX, resX, boolX, "skip", perfX)
	} catch(e) {
		fnRecord(num3, strX, e.name, zB0, e.message)
	}
	// DNT: FF: 1, unspecified
	let strDNT = "[doNotTrack] navigator", boolDNT = false, numDNT = num3+2
	let t0DNT; if (canPerf) {t0DNT = performance.now()}
	try {
		if (bBlock) {bB = 1}
		let testDNT = navigator.doNotTrack
		if (testDNT == 1 || testDNT == "unspecified") {
			boolDNT = true
		} else {
			testDNT = fnClean(testDNT)
		}
		let perfDNT = canPerf ? performance.now() - t0DNT : ""
		if (isFF && !boolDNT) {
			// PM not supported: returns undefined
			if (isEngine == "goanna" && testDNT == "undefined") {
				fnRecord(numDNT, strDNT, testDNT, true, "skip", perfDNT)
			} else {
				fnRecord(numDNT, strDNT, testDNT, zB0, "skip", perfDNT)
			}
		} else {
			fnRecord(numDNT, strDNT, testDNT, boolDNT, "skip", perfDNT)
		}
	} catch(e) {
		fnRecord(numDNT, strDNT, e.name, zB0, e.message)
	}

	let strY = "[productSub] navigator", boolY = false, numY = num3+4
	try {
		let t0Y; if (canPerf) {t0Y = performance.now()}
		if (bBlock) {bB = 1}
		let resY = navigator.productSub
		if (resY == "20100101") {boolY = true} else {resY = fnClean(resY)}
		let perfY = canPerf ? performance.now() - t0Y : ""
		fnRecord(numY, strY, resY, boolY, "skip", perfY)
	} catch(e) {
		fnRecord(numY, strY, e.name, zB0, e.message)
	}

	// not expected
	// getbattery
	let strB = "[getBattery] navigator", boolB = false, numB = num2+4
	let resB = []
	let t0B, perfB; if (canPerf) {t0B = performance.now()}
	try {
		if (bBlock) {bB = 1}
		// not going to add eventlisteners
		navigator.getBattery().then(function(battery) {
			try {resB.push(battery.level * 100 + "%")} catch(e) {resB.push("error")}
			try {resB.push((battery.charging ? "": "not ") +"charging")} catch(e) {resB.push("error")}
			try {resB.push(battery.chargingTime)} catch(e) {resB.push("error")}
			try {resB.push(battery.dischargingTime)} catch(e) {resB.push("error")}
			perfB = canPerf ? performance.now() - t0B : ""
			fnRecord(numB, strB, resB.join(", "), false, "skip", perfB)
		})
	} catch(e) {
		if (e.name == "TypeError" && e.message.substring(0,38) == "navigator.getBattery is not a function") {
			if (e.message == "navigator.getBattery is not a function") {boolB = true} // webkit wil be false
			perfB = canPerf ? performance.now() - t0B : ""
			fnRecord(numB, strB, e.name, boolB, e.message, perfB)
		} else {
			fnRecord(numB, strB, e.name, zB0, e.message)
		}
	}

}

function get_obj_enumeration(num, title) {
	// 1762188
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		let t = ['a','b'], result = []
		for (let i in t) {
			for (let j in t) {
				result.push([i, j, t[i], t[j]])
				let v = t[i]
				delete t[i]
				t[i] = v
			}
		}
		let res = result.join(",") // nonFF = 0,0,a,a,0,1,a,b,1,0,b,a,1,1,b,b
		let bool = res == "0,0,a,a,0,1,a,b,1,0,b,a" ? true : false
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, res, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_permission(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let userVis = "userVisibleOnly"
		navigator.permissions.query({name:"push"}).then(function(result) {
			let res = result.state
			let bool = (res == "prompt" || res == "denied" || res == "granted") ? true : false
			let perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num, title, res, bool, "skip", perf)
		}).catch(error => {
			let perfErr = canPerf ? performance.now() - t0 : ""
			if ((error.message).includes(userVis)) {
				fnRecord(num, title, userVis, false, "skip", perfErr)
			} else {
				fnRecord(num, title, error.name, zB0, error.message)
			}
		})
	} catch(e) {
		// not supported in webkit: https://caniuse.com/?search=push%20permission
		if (isWebkit) {
			fnRecord(num, title, "not supported", false)
		} else {
			fnRecord(num, title, e.name, zB0, e.message)
		}
	}
}

function get_plugins(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		if ("plugins" in navigator) {
			let res = [], bool = false
			let p = navigator.plugins
			if (p.length == 0) {
				fnRecord(num, title, "none", true)
			} else {
				for (let i=0; i < p.length; i++) {
					res.push(p[i].name + (p[i].filename == "" ? ": * " : ": "+ p[i].filename)
						+ (p[i].description == "" ? ": *" : ": "+ p[i].description))
				}
				res.sort()
				// FF84 or lower allow just Flash
				if (isFF && isVer < 85 && res.length == 1) {
					if (res[0].split(":")[0] == "Shockwave Flash") {bool = true}
				}
				let hash = mini_sha1(res.join())
				if (isVer > 98 || !isFF) { // allow non-FF to have the same
					// FF99+: controlled by pdfjs.disabled
					// 1720353: hardcoded mimeTypes
					if (hash == "6232b915d6de71c787a36eb42b75d2b8e24aa4d3") {
						bool = true
					}
				}
				sDetail["expected_"+ title] = res
				hash += buildButton(3, "expected_"+ title, res.length)
				let perf = canPerf ? performance.now() - t0 : ""
				fnRecord(num, title, hash, bool, "skip", perf)
			}
		} else {
			fnRecord(num, title, e.name, zB0)
		}
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_stacklength(num1, num2, num3) {
	let t0; if (canPerf) {t0 = performance.now()}
	let level = 0, test1 = 0
	function recurse() {
		level++
		recurse()
	}
	try {
		recurse()
	} catch(e) {
		test1 = level
	}
	level = 0
	try {
		recurse()
	} catch(e) {
		// timing an error property lookup is not the same as generating a alow recurse one
		let t0E; if (canPerf) {t0E = performance.now()}
		// columnNumber
		let strCN = "[columnNumber] error", errCN = false
		try {
			if (bBlock) {bB = 1}
			let resCN = e.columnNumber
			let testCN = resCN == undefined? false : true
			let perfCN = canPerf ? performance.now() - t0E : ""
			fnRecord(num1, strCN, resCN, testCN, "skip", perfCN)
		} catch(n) {
			fnRecord(num1, strCN, n.name, zB0, n.message)
		}
		// fileName
		let strFN = "[fileName] error", errFN = false
		try {
			if (bBlock) {bB = 1}
			let resFN = e.fileName
			if (resFN !== undefined) {resFN = resFN.slice(0,8) + "..."}
			let testFN = resFN == undefined? false : true
			let perfFN = canPerf ? performance.now() - t0E : ""
			fnRecord(num1+1, strFN, resFN, testFN, "skip", perfFN)
		} catch(n) {
			fnRecord(num1+1, strFN, n.name, zB0, n.message)
		}
		// lineNumber
		let strLN = "[lineNumber] error", errLN = false
		try {
			if (bBlock) {bB = 1}
			let resLN = e.lineNumber
			let testLN = resLN == undefined? false : true
			let perfLN = canPerf ? performance.now() - t0E : ""
			fnRecord(num1+2, strLN, resLN, testLN, "skip", perfLN)
		} catch(n) {
			fnRecord(num1+2, strLN, n.name, zB0, n.message)
		}

		// first error
		let perf = canPerf ? performance.now() - t0 : ""
		let strRE = "error", resRE = e.name +": "+ e.message
		if (resRE == "InternalError: too much recursion") {
			fnRecord(num3, strRE, resRE, true, "skip", perf)
		} else {
			fnRecord(num3, strRE, resRE, false, "skip", perf)
		}
		// stack length
		let strSL = "stack length"
		try {
			if (bBlock) {bB = 1}
			let resSL = e.stack.toString().length
			let testSL = resSL == 8192 ? true : false
			if (isFile) {
				testSL = zNA
				resSL = zNA +": file://"
			}
			fnRecord(num2, strSL, resSL, testSL, "skip", perf)
		} catch(n) {
			fnRecord(num2, strSL, n.name, zB0, n.message, perf)
		}
	}
}

function get_storage_estimate(num, title) {

	// Notes: Win10 VM is  52gb / 33gb spare | FF is always the same in PB mode
		//   2147483648 : FF57-96 Windows / Android / Win 10 VM FF60-96
	/*
	FF97+ is not stable enough: see https://bugzilla.mozilla.org/show_bug.cgi?id=1735713
   10737418240 : Windows, vannTenn's + bashonly's Linux, Android Fabrizio 100gb spare from 128gb
    5641604300 : Android Fabrizio 49gb spare from 64gb
    5512729395 : Android Thorin 44gb spare from 64gb
    5301081292 : Android bashonly 40gb spare from 64gb
    5256596684 : Win 10 VM 33gb spare from 52gb
    2934867968 : Debian XCFE 2glops 650gb spare from 1TB
    1521166745 : Ubuntu VM Fabrizio with 15GB of storage
    1177328025 : Android aleyvo 1.5gb spare from 16gb
	*/

	// other: who cares if they match
		// brave:     2147483648 (same in incognito and Tor window)
		// opera:      310418104 normal
		// opera:      521917312 private
		// chrome: 1200238045593 normal
		// chrome:   33076376370 normal android
		// chrome:     485041940 incognito
		// chrome:     204974075 incognito android

	// ToDo: check if FF97+ new storage quota is based on disk or free disk space size
	let t0; if (canPerf) {t0 = performance.now()}
	try {
		if (bBlock) {bB = 1}
		navigator.storage.estimate().then(estimate => {
			let quota = estimate.quota,
				bool = false
			if (isVer > 96) {
				bool = zNA
				quota = zNA +": variable in FF97+ "+ s3 +"["+ quota +"]"+ sc
			} else {
				if (quota > 2147000000 && quota < 2148000000) {bool = true}
			}
			let perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num, title, quota, bool, "skip", perf)
		})
	} catch(e) {
		let msg = e.message.substring(0,26)
		if (isWebkit && e.name == "TypeError" && msg == "undefined is not an object") {
			fnRecord(num, title, e.name, false, e.message)
		} else {
			// FF56 or lower
			let result = e.name
			let type = zB0
			let error = e.message
			if (isFF && isVer < 59 && e.message == "navigator.storage is undefined") {
				result = zNA +": FF57+ required"
				type = zNA
				error = undefined
			}
			fnRecord(num, title, result, type, error)
		}
	}
}

function get_window_chrome(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let bool = "chrome" in window
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, bool, !bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_window_values(num) {
	//window.offscreenBuffering
	let strB = "[offscreenBuffering] window", boolB = false
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = window.offscreenBuffering
		if (resB == undefined) {boolB = true}
		resB = fnClean(resB)
		let perfB = canPerf ? performance.now() - t0B : ""
		fnRecord(num, strB, resB, boolB, "skip", perfB)
	} catch(e) {
		fnRecord(num, strB, e.name, zB0, e.message)
	}
	// window.openDatabase
	let strO = "[openDatabase] window", boolO = false
	let t0, perf = ""; if (canPerf) {t0 = performance.now()}
	try {
		if (bBlock) {bB = 1}
		window.openDatabase("test", "1.0", "test", 1024)
		perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num+2, strO, "success", boolO, "skip", perf)
	} catch(e) {
		if (e.name == "TypeError" && e.message == "window.openDatabase is not a function") {
			perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num+2, strO, e.name, true, e.message, perf)
		} else if (e.name == "UnknownError" && e.message == "Web SQL is deprecated") {
			fnRecord(num+2, strO, e.name, false, e.message) // webkit
		} else {
			fnRecord(num+2, strO, e.name, zB0, e.message)
		}
	}
}

function get_window_moz(num) {
	let strA = "[mozInnerScreenX] window", boolA = false
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = window.mozInnerScreenX
		if (!isNaN(resA)) {boolA = true} else {resA = fnClean(resA)}
		let perfA = canPerf ? performance.now() - t0A : ""
		fnRecord(num, strA, resA, boolA, "skip", perfA)
	} catch(e) {
		fnRecord(num, strA, e.name, zB0, e.message)
	}
	let strB = "[mozInnerScreenY] window", boolB = false
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = window.mozInnerScreenY
		if (!isNaN(resB)) {boolB = true} else {resB = fnClean(resB)}
		let perfB = canPerf ? performance.now() - t0B : ""
		fnRecord(num+1, strB, resB, boolB, "skip", perfB)
	} catch(e) {
		fnRecord(num+1, strB, e.name, zB0, e.message)
	}
}

function get_legacyVer() {
	return new Promise(resolve => {
		// set webkit
		if ("chrome" in window || isFF) {} else {isWebkit = true}
		if (!isFF) {
			return resolve()
		}
		// set goanna
		if (isEngine == "gecko") {
			// check for PM28+ : fails 55 (1351795) but passes 57 (1378342)
				// note: waterfox classic passes both
			if ("undefined" !== typeof console.timeline && "function" === typeof AbortSignal) {
				isEngine = "goanna"
				// exit and return isVer as 52
				isVer = 52
				return resolve()
			}
		}
		// is55
		let is55 = false
		try {
			let maxIndex = Math.pow(2, 31)
			let list55 = []
			list55[maxIndex - 1] = 'a'
			list55[maxIndex - 0] = 'b'
			if (list55[maxIndex] !== 'b') {
			} else if (list55.slice()[maxIndex] !== 'b') {
			} else if (list55.slice(maxIndex - 1).length !== 2) {
			} else {
				is55 = true
			}
		} catch(e) {}

		// FF52-59
		if ("function" !== typeof Animation.prototype.updatePlaybackRate) {
			if (!HTMLMediaElement.prototype.hasOwnProperty("mozAutoplayEnabled")) {
				isVer = 59
			} else if ("function" == typeof Intl.PluralRules) {isVer = 58
			} else if ("function" === typeof AbortSignal) {isVer = 57
			} else if (is55) {
				minVer = 56
				isVer = 56
			} else {
				minVer = 54
				isVer = 54
			}
		}
		return resolve()
	})
}

function rerun() {
	// reset
	results = []
	itemnumbers = [],
	data = {},
	aPerf = [],
	count = 0,
	dom.perf = ""
	dom.results = ""
	// do it: delay for user to see visual change
	setTimeout(function() {
		run()
	}, 120)
}

function run() {
	// now get on with it
	fnRecord(0, "header", "expected")
	fnRecord(300, "header", "not expected")
	fnRecord(600, "header", "specific values")
	fnRecord(899, "hr")
	fnRecord(900, "header", "errors")
	fnRecord(440, "the spanish inquisition", "no one expects the spanish inquisition", true)
	// OK, let's kick some ass
	// stagger to get more accurate perf

	setTimeout(function() {
		if (canPerf) {gt0 = performance.now()}
		aPerf.push(["START 1", gt0])
		get_installtrigger(50) // 50-52
		get_eval_length(630, "eval.toString().length")
		get_colorgamut(310, "[css] color-gamut"),
		get_nav_screen(150)
		get_window_chrome(450, "[chrome] window"),
		get_obj_enumeration(734, "object enumeration")
		get_last_prototype_keys(640, "[last x keys]") // 640+641
		get_doc_values(10, "document")
		get_math(695, "math")
		get_nav_values(100, 400, 720) // 100 expected, 400-410 not expected, 720.. specific
		get_window_values(460)
		get_dates(620)
		get_js_client_hints(320, "[js] client hints")
		get_intl_canonical_locale(662, "Intl.getCanonicalLocales")
		get_mimetypes(710, "mimetypes")
		get_plugins(740, "plugins")
		get_canvaskeys(80, "[2d canvas] keys")
		get_intl_number_format(666, "Intl.NumberFormat")
		get_media_constraints(700, "[constraints] mediaDevices")
	}, 1)

	setTimeout(function() {
		aPerf.push(["START 2", performance.now(), performance.now() - gt0])
		get_window_moz(250) // 250-251
		get_nav_keys(85, 350, "[navigator] keys") // 85 expected, 350 not expected
		get_intl_pluralrules(670, "Intl.PluralRules")
		get_locale_compare(690, "locale.compare")
		get_intl_display_names(660, "Intl.DislayNames")
	}, 1)

	setTimeout(function() {
		aPerf.push(["START 3", performance.now(), performance.now() - gt0])
		get_errors(902)
		get_stacklength(30,800,901) // 30-32 error properties, 800 = stack length, 901 = first error message
		get_intl_list_format(663, "Intl.ListFormat")
		get_intl_rtf(673, "Intl.RelativeTimeFormat")
	}, 1)

	setTimeout(function() {
		aPerf.push(["START THE END", performance.now(), performance.now() - gt0])
		get_intl_collator(650, "Intl.Collator")
	}, 1)

	setTimeout(function() { get_moz_fonts(95, "[fonts] moz") }, 1)
	setTimeout(function() { get_iframe_props(40, 330, "[properties] iframe") }, 1) // 40 expected, 330 not expected,
	setTimeout(function() { get_moz_colors(90, "[colors] moz") }, 1)
	setTimeout(function() { get_moz_computed_styles(92, "[computed styles] moz") }, 1)
	setTimeout(function() {	get_intl_dtf(656, "Intl.DateTimeFormat") }, 1)
	setTimeout(function() {
		get_permission(750, "[permissions] push")
		get_storage_estimate(820, "storage estimate")
	}, 1)

}

setTimeout(function() {
	Promise.all([
		get_isRFP(),
		get_is95(),
		get_legacyVer(),
	]).then(function(){
		if (isFF && isVer !== "") {
			run()
		} else {
			console.debug("isVer is emmpty")
			Promise.all([
				get_isVer(),
			]).then(function(){
				console.debug(isVer)
				run()
			})			
		}
	})
}, 50)

</script>
</body>
</html>
