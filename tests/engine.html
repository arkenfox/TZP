<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=620">
	<title>engine</title>
	<link rel="stylesheet" type="text/css" href="testindex.css">
	<script src="testglobals.js"></script>
	<script src="testgeneric.js"></script>
	<!-- custom -->
	<style>
		table {width: 700px;}
		#tb3 td:first-child { text-align: left; vertical-align: top;}
		hr {color: #dcc18c}
	</style>
</head>

<body>
	<div class="offscreen">
		<div id="mozFont"></div>
		<div id="test95a" style="width: min-content; hyphens: auto; border: 1px solid red">2020-1</div>
		<div id="test95b" style="width: min-content; hyphens: auto; border: 1px solid red">2020-12020-1</div>
	</div>
	<div class="hidden">
		<div><input type="time" min="14:00:00" max="12:00:00" value="15:00:00" id="test76"></div>
		<span id="mozColor"></span>
	</div>

	<table>
	<tr><td><h2>TorZillaPrint</h2></td></tr>
	<tr><td class="blurb"><a class="return" href="../index.html">return to TZP index</a></td></tr>
	</table>

	<table id="tb3">
		<col width="50%"><col width="50%">
		<thead><tr><th colspan="2">
			<div class="nav-title">engine
			<div class="nav-up"><span class="c perf" id="perf"></span></div>
			</div>
		</th></tr></thead>
		<tr><td colspan="2" class="intro">
			<span class="no_color">A tiny sample of the myriad ways engines differ. This test is tweaked
			for gecko [FF52+]: you want <span class="s9"><b> &#x2713 </b></span>'s. Anything different
			<span class="bad"><b> &#x2716 </b></span> or blocked <span class="s4"><b> &#x2715 </b></span>
			only makes you stand out. A single unspoofable property check can take as little as <span class="s3">0.01 ms</span>.
			</span>
		</td></tr>
		<tr><td colspan="2"><hr></td></tr>
		<tr><td colspan="2"><span class="no_color c mono spaces" id="results"></span></td></tr>
	</table>
	<br>

<script>
'use strict';

s3 = s3.trim()
s14 = s14.trim()
s99 = s99.trim()
sb = sb.trim()
sg = sg.trim()

let results = [],
	itemnumbers = [],
	data = {},
	aPerf = [],
	count = 0,
	expected = 96,
	gt0, // global timer
	bBlock = false, // throw a test error
	bNum = false // display numbering instead of perf

let	topVer = 105,
	minVer = "",
	isWebkit = false

function fnTrim(str, len) {
	str = str.replace(/(\r\n|\n|\r)/gm,"")
	if (str.length > len) {str = str.slice(0,len-3) +"..."}
	return str
}

function fnClean(str) {
	if (str == "") {str = "empty string"
	} else if (str === undefined) {str = zU
	} else if (str == zU) {str = zUQ}
	return str
}

function logPerf() {
	if (aPerf.length) {
		console.log("PERF LOG\n", aPerf)
	}
}

function fnDisplay() {
	// perf
	let perfValue = ""
	if (canPerf) {
		perfValue = Math.round(performance.now() - gt0) +" ms"
		let perfTop = perfValue
		// remove the first 5 items: section headers + hr
		if (aPerf.length) {
			perfTop = "<span style='cursor: pointer;' onClick='logPerf()'>" + perfTop +"</span>"
			aPerf.splice(0, 5)
		}
		dom.perf.innerHTML = perfTop
	}
	// data -> ordered results
	const names = Object.keys(data).sort((a,b) => a-b)
	for (const k of names) {results.push(k +"~~~"+ data[k])}
	let display = [],
		errcount = 0
	let countTrue = 0, countFalse = 0, countBlock = 0, countNA = 0
	// check no numbers duplicated
	if (expected !== results.length) {
		display.push(sb+ "ERROR:"+ sc + " duplicate numbers detected<br>")
	}
	// parse for pretty output
	for (let i=0; i < results.length; i++) {
		let pad = 35
		let order = results[i].split("~~~")[0],
			desc = results[i].split("~~~")[1].trim(),
			result = results[i].split("~~~")[2],
			match = results[i].split("~~~")[3],
			perf = results[i].split("~~~")[4]
		if (perf == undefined || perf == "" || perf == "undefined") {perf = " - "
		} else if (perf !== "NaN") {
			perf = Math.round(perf)
			perf = perf.toString()
			perf = perf.padStart(2) +" "
		}

		if (desc == "header") {
			let note = ""
			if (result == "errors") {
				note = " [there are thousands of these]"
			}
			result = s14 + result.toUpperCase() + sc + note
			display.push("<span>"+ result + "</span><br>")
		} else if (desc == "hr") {
			display.push("<br><hr>")
		} else {
			if (match == zB0) {match = yellow_block; countBlock++
			} else if (match == "true") {match = green_tick; countTrue++
			} else if (match == "false") {match = red_cross; countFalse++
			} else {match = white_na; countNA++}
			match += " "
			if (desc == "error") {
				pad = 3; errcount++; desc = errcount.toString()
			}
			desc = s3 + desc.padStart(pad) + sc
			let sectionspace = ""
			if (i+1 < results.length) {
				let nextitem = results[i+1].split("~~~")[1].trim()
				if (nextitem == "header") {sectionspace = "<br>"}
			}
			desc += s99 +" "+ (bNum ? order : perf) + sc
			display.push(desc + match +" "+ result + sectionspace)
		}
	}
	// summary
	let countValid = countTrue + countFalse + countBlock // na tests ignored
	let countFail = countFalse + countBlock
	let percentPassed = Math.floor((countTrue/countValid)*100)
	let isPass = percentPassed == 100 ? true : false
	let percentFailed = Math.ceil((countFail/countValid)*100)
	let summary = ""
	if (isFFvalid) {
		let needStr = "... who needs "+ s3+ (expected - 5) + " tests" + sc
			+ (canPerf ? " in "+ s3 + perfValue + sc : "")
			+ "? Here's a single test + nine more to make sure"
		summary += s14 +"MINI TEST "+ sc + needStr
			+"<br><br>"+ isFFpretty +" ... are you gecko? "+ (isFF ? sg +"YES" : sb +"NO") + sc
			+"<br><br><hr><br>"
	}
	summary += s14 +"SUMMARY "+ sc
		+"PASS: ".padStart(7) + countTrue + (isPass? sg : sb) +" ["+ percentPassed +"%]"+ sc
		+"FAIL: ".padStart(7) + countFail + (isPass? sg : sb) +" ["+ percentFailed +"%]"+ sc
	if (countNA > 0) {summary += "N/A: ".padStart(6) + countNA}
	if (isFF) {
		summary += s14+ "DEBUG".padStart(7) + sc +"RFP:".padStart(6) + (isRFP ? green_tick : red_cross)
		let strVer = isVer
		strVer += (isVer == topVer ? "+" : "")
		strVer += (isVer == minVer ? " or lower" : "")
		summary += "VER: ".padStart(6) + strVer
	}
	summary += " " + buildButton(3, "all", "all details")
	// output
	dom.results.innerHTML = summary + "<br><br>" + display.join("<br>")
}

function fnRecord(order, description, result, match, error, perf) {
	if (error !== undefined && error !== "skip") {
		let hash = mini(error)
		if (hash !== "d8281b3c") { // assignment to undeclared variable bB
			console.error(order, result, error)
			hash = s3+ " ["+ hash +"]"+ sc
		} else {
			result = "test error thrown"; hash = ""
		}
		result += hash
	}
	aPerf.push([perf, order, description])
	order = (order+"").padStart(3,"0")
	data[order] = description +"~~~"+ result +"~~~"+ match + "~~~" + perf
	count ++
	itemnumbers.push(order +" "+ description)
	if (count == expected) {
		fnDisplay()
	}
	if (count > expected) {console.error(count, "expected count too low")}
}

function get_colorgamut(num, title) {
	let q = "(color-gamut: ", res = "undefined", bolC = false
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		if (window.matchMedia(q +"srgb)").matches) {res = "srgb"}
		if (window.matchMedia(q +"p3)").matches) {res = "p3"}
		if (window.matchMedia(q +"rec2020)").matches) {res = "rec2020"}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, res, res == "undefined", "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_dates(num) {
	// 1274354: meta
	// 1557650
	let strA = "[5 digit year] new Date"
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = new Date("19999-11-11")
		let bolA = resA == "Invalid Date" ? true : false
		if (!bolA) {resA = fnTrim(resA.toString(), 40)}
		let perfA = canPerf ? performance.now() - t0A : ""
		fnRecord(num, strA, resA, bolA, "skip", perfA)
	} catch(e) {
		fnRecord(num, strA, e.name, zB0, e.message)
	}
	// 1515318
	let strB = "[hyphen] new Date"
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = new Date("31-Mar-2011").getFullYear()
		// FF: 63 and lower = NaN, 64+ = -2011
		let bolB = false
		if (resB == -2011) {bolB = true
		} else if (isVer < 64 && isNaN(resB)) {bolB = true}
		let perfB = canPerf ? performance.now() - t0B : ""
		fnRecord(num+1, strB, resB, bolB, "skip", perfB)
	} catch(e) {
		fnRecord(num+1, strB, e.name, zB0, e.message)
	}
	// 1439800
	let strC = "[string] new Data"
	try {
		let t0C; if (canPerf) {t0C = performance.now()}
		if (bBlock) {bB = 1}
		let resC = new Date("11-Nov-11")
		let bolC = resC.toString() == "Invalid Date" ? true : false
		if (!bolC) {resC = fnTrim(resC.toString(), 40)}
		let perfC = canPerf ? performance.now() - t0C : ""
		fnRecord(num+2, strC, resC, bolC, "skip", perfC)
	} catch(e) {
		fnRecord(num+2, strC, e.name, zB0, e.message)
	}
	// 1599375
	let strD = "[+0000 UTC] Date.parse"
	try {
		let t0D; if (canPerf) {t0D = performance.now()}
		if (bBlock) {bB = 1}
		let resD = Date.parse("2019-11-26 07:39:58.286157072 +0000 UTC")
		let bolD = isNaN(resD) ? true : false
		let perfD = canPerf ? performance.now() - t0D : ""
		fnRecord(num+3, strD, resD, bolD, "skip", perfD)
	} catch(e) {
		fnRecord(num+3, strD, e.name, zB0, e.message)
	}
	// 1730155
	let strE = "[localized] Date.parse"
	try {
		let t0E; if (canPerf) {t0E = performance.now()}
		if (bBlock) {bB = 1}
		let resE = Date.parse("Mercredi 8 Septembre 2021")
		let bolE = isNaN(resE) ? true : false
		let perfE = canPerf ? performance.now() - t0E : ""
		fnRecord(num+4, strE, resE, bolE, "skip", perfE)
	} catch(e) {
		fnRecord(num+4, strE, e.name, zB0, e.message)
	}
	// 1783731
	let strF = "[subtraction] Date.parse"
	try {
		let t0F; if (canPerf) {t0F = performance.now()}
		if (bBlock) {bB = 1}
		let resF = Date.parse('2022-08-08') - Date.parse('2022-08-8')
		let bolF = resF == 0
		let perfF = canPerf ? performance.now() - t0F : ""
		fnRecord(num+6, strF, resF, bolF, "skip", perfF)
	} catch(e) {
		fnRecord(num+6, strF, e.name, zB0, e.message)
	}
}

function get_errors(num) {
	let tests = [
		["var a = {}; a.b = a; JSON.stringify(a)", "TypeError: cyclic object value"],
		["alert('A)","SyntaxError: '' string literal contains an unescaped line break"],
		["let a = 1_00_;","SyntaxError: underscore can appear only between digits, not after t...", // FF72+
			"SyntaxError: identifier starts immediately after numeric literal", // FF60-69
			"SyntaxError: missing digit after '_' numeric separator"], // FF70-71
		["const foo;foo.bar","SyntaxError: missing = in const declaration"],
		["null.bar","TypeError: can't access property \"bar\" of null","TypeError: null has no properties"],
		["(1).toString(1000)","RangeError: radix must be an integer at least 2 and no greater than 36"],
		["var x = new Array(-1)","RangeError: invalid array length"],
		["[...undefined].length","TypeError: can't access property Symbol.iterator of undefined","TypeError: undefined has no properties"],
		["const tzp=1; const tzp=2;","SyntaxError: redeclaration of const tzp"],
		["const foo;foo.bar","SyntaxError: missing = in const declaration"],
		["var x = @","SyntaxError: illegal character U+0040","SyntaxError: illegal character"],
	]
	tests.forEach(function(array) {
		let t0; if (canPerf) {t0 = performance.now()}
		try {
			newFn(array[0])
		} catch(e) {
			let bool = false
			let str = fnTrim(e.name +": "+ e.message, 70)
			if (isVer < 60 && array[0] == "alert('A)") {
				if (str == "SyntaxError: unterminated string literal") {bool = true}
			} else {
				if (str == array[1] || str == array[2] || str == array[3]) {bool = true}
			}
			let perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num, "error", str, bool, "skip", perf)
			num++
		}
	})
}

function get_eval_length(num, title) {
	let bool = false
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let test = eval.toString().length
		if (test == 37) {bool = true}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, test, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_iframe_props(num1, num2, title) {
	let t0; if (canPerf) {t0 = performance.now()}
	// just a small sample
	let listE = ['dump','fullScreen','getDefaultComputedStyle','mozInnerScreenX',
		'mozInnerScreenY','netscape','onmozfullscreenchange','onmozfullscreenerror']
	let listU = ['BatteryManager','HID','Keyboard','Lock','Serial',
		'USB','WakeLock','WebKitMutationObserver','XRAnchor','chrome','webkitCancelAnimationFrame',
		'webkitMediaStream','webkitRTCPeerConnection','webkitRequestAnimationFrame',
		'webkitRequestFileSystem','webkitResolveLocalFileSystemURL','webkitStorageInfo']
	// FYI: don't use MIDIAccess: FF60+ behind dom.webmidi.enabled... 1752906: FF99+ default enabled

	if (isVer > 92) {
		// FF93+ "dom.weblocks.enabled"
		// 1739233: FF96+ Lock
		listU = listU.filter(x => !["Lock"].includes(x))
	}
	try {
		if (bBlock) {bB = 1}
		// create & append iframe
		let id = "iframe-window-version"
		let el = document.createElement("iframe")
		el.setAttribute("id", id)
		el.setAttribute('style', 'display: none')
		document.body.appendChild(el)
		// get props
		let iframe = document.getElementById(id)
		let contentWindow = iframe.contentWindow
		let props = Object.getOwnPropertyNames(contentWindow)
		// remove iframe
		iframe.parentNode.removeChild(iframe)
		props.sort()
		// expected
		let arrayE = props.filter(x => listE.includes(x))
		let resE = "", boolE = false
		if (arrayE.length) {
			sDetail["expected_"+ title] = arrayE
			resE = mini_sha1(arrayE.join()) + buildButton(3, "expected_"+ title, arrayE.length)
			if (arrayE.length > 4) {boolE = true}
		} else {
			resE = "none"
		}
		// unexpected
		let arrayU = props.filter(x => listU.includes(x))
		// ignore BatteryManager FF72+
		if (isFF && isVer < 72) {arrayU = arrayU.filter(x => !["BatteryManager"].includes(x))}
		let resU = "", boolU = false
		if (arrayU.length) {
			sDetail["unexpected_"+ title] = arrayU
			resU = mini_sha1(arrayU.join()) + buildButton(3, "unexpected_"+ title, arrayU.length)
		} else {
			resU = "none"
			boolU = true
		}
		let perf = canPerf ? performance.now() - t0 : ""
		// record
		fnRecord(num1, title, resE, boolE, "skip", perf)
		fnRecord(num2, title, resU, boolU, "skip", perf)
	} catch(e) {
		fnRecord(num1, title, e.name, zB0, e.message)
		fnRecord(num2, title, e.name, zB0, e.message)
	}
}

function get_installtrigger(num) {
	// FF100+: 1754441 behind prefs slated for deprecation
	let strA = "[typeof] InstallTrigger", boolA = false
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = typeof InstallTrigger
		if (resA == "object") {boolA = true}
		let perfA = canPerf ? performance.now() - t0A : ""
		if (isVer > 99 && !boolA) {
			fnRecord(num, strA, zNA +": FF99 or lower" + s3 +" ["+ resA +"]"+ sc, zNA, "skip", perfA)
		} else {
			fnRecord(num, strA, resA, boolA, "skip", perfA)
		}
	} catch(e) {
		fnRecord(num, strA, e.name, zB0, e.message)
	}

	let strB = "[window] InstallTrigger", boolB = false
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = "InstallTrigger" in window
		let perfB = canPerf ? performance.now() - t0B : ""
		if (isVer > 99 && !resB) {
			fnRecord(num+1, strB, zNA +": FF99 or lower" + s3 +" ["+ resB +"]"+ sc, zNA, "skip", perfB)
		} else {
			fnRecord(num+1, strB, resB, resB, "skip", perfB)
		}
	} catch(e) {
		fnRecord(num+1, strB, e.name, zB0, e.message)
	}

	let strC = "[typeof] InstallTriggerImpl", boolC = false
	// FF60 or lower
	if (isFF && isVer < 61) {
		fnRecord(num+2, strC, zNA +": FF61+ required", zNA)
	} else {
		try {
			let t0C; if (canPerf) {t0C = performance.now()}
			if (bBlock) {bB = 1}
			let resC = typeof InstallTriggerImpl
			if (resC == "function") {boolC = true}
			let perfC = canPerf ? performance.now() - t0C : ""
			if (isVer > 99 && !boolC) {
				fnRecord(num+2, strC, zNA +": FF99 or lower" + s3 +" ["+ resC +"]"+ sc, zNA, "skip", perfC)
			} else {
				fnRecord(num+2, strC, resC, boolC, "skip", perfC)
			}
		} catch(e) {
			fnRecord(num+2, strC, e.name, zB0, e.message)
		}
	}
}

function get_intl_canonical_locale(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let list = ['bh','hye','no','tl','tw'], bool = false
		let res = []
		list.forEach(function(i) {
			res.push(Intl.getCanonicalLocales(i))
		})
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		if (hash == "49ce6431a6b656b0cdce7fc8bff36cbf60f90558") {bool = true // FF91+
		} else if (hash == "ca3fd91866c1a46b8d08c4c1b406e3201fd7fcd7") {bool = true // FF70-90
		} else if (hash == "68cbf0ea5d3d3a6bc14f0d574341397d818ba886") {bool = true // FF52-69
		}
		// FF60-69 : bh=bh,  hye=hye, no=no, tl=tl,  tw=tw
		// FF70-90 : bh=bho, hye=hy,  no=nb, tl=fil, tw=ak
		// FF91+   : bh=bho, hye=hy,  no=no, tl=fil, tw=ak
		// blink   : bh=bh,  hye=hy,  no=no, tl=fil, tw=tw
		// webkit  : bh=bh,  hye=hy,  no=no, tl=tl,  tw=tw
		if (res.length > 0) {
			if (res.join(", ").length < 48) {
				hash = res.join(", ")
			} else {
				sDetail["specific_"+ title] = res
				hash += buildButton(3, "specific_"+ title, "details")
			}
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_intl_supportedlocales(num) {
	// DTF, NF, RTF, LF, DN
	/* NOTES
	// FF52+ common items (130) not in blink103 common (59) = 71 items
		// FF52: DTF + NF / FF65: RTF / FF78: LF / FF86: DN
		// remove if present: bh bho, hye hy, no nb, tl fil, tw ak [aliases/maps]
	geckoNotBlink = [
		// mix it up per test
		'eo','gl','ka','mt','om', // used in C
			// from collator list below that is in common with this list
			// ^ note mt only added if .compare works

		'ki','lu','qu','rn','rw', // used in PR (limited choices)
		'as','fo','ln','ne','to', // used in DTF
		'br','eu','ii','ks','ps', // used in DN
		'ee','gd','kk','lo','yi', // used in LF
		'bo','ha','lb','my','sq', // used in NF
		'cy','km','mg','os','sn', // used in RTF
		// 35 spare
		'ast','be','bm','ce','ckb','dsb','dz','ff','fur','fy',
		'ga','gv','haw','hsb','ig','is','kab','kl','kok','kw',
		'ky','lg','mk','mn','nd','nn','or','rm','se','sg','si',
		'so','ti','ug','yo','zu'
	]
	// webkit items not in FF105
		// note: older webkit only: make sure one in each: 'co','cv','oc','nso','tig'
	WKnotGecko = [
		'ba','co','cv','dv','gn','io','iu','nr','nso','nv','ny','oc','ss','st','tig','tn','ts','ve','wa'
	]
	*/
	// COLLATOR
	/*
	geckoNotBlink = [
		'as','az','be','bo','bs','cy','dsb','dz','ee','eo','fo','ga','gl',
		'ha','haw','hsb','ig','is','ka','kk','kl','km','kok','ky','lb',
		'ln','lo','mk','mn','mt','my','ne','nn','om','or','pa','ps','se',
		'si','sq','to','ug','uz','yi','yo','zu'
	]
	webkit = same as gecko 91+
	old_list = [
		'az','cy','dsb','ee','eo','gl','ha','haw','hsb','ig',
		'ka','kk','ln','lo','mt','om','pa','se','sq','to',
	]
	*/
	// PR
	/*
		 FF52+  geckoNotBlink = ['ki','kok','lu','qu','rn','rw']
		FF105-  blinkNotGecko = ['an','dv','io','iu','lij','nr','nso','ny','ss','st','tig','tn','ts','ve','vo','wa']
		FF105- webkitNotGecko = ['ba','co','cv','dv','gn','io','iu','nr','nso','nv','ny','oc','ss','st','tig','tn','ts','ve','wa']
		therefore
		blinkOnly = ['an','lij','vo']
		webkitOnly = ['ba',co','cv',''gn','ny','oc']
		let list = [
			'ki','lu','qu','rn','rw', // gecko: pick 5
			'ba','co','cv','gn','oc', // webkit only: pick 4
			'an','lij','vo', // chrome only: not needed
		]
	*/
	// MAC supportedlocales == FF91+
		// but .compare for mt is not hooked up (the other locales seem to be working)
	let aCollator = []
	let control = (["c","C"]).sort(Intl.Collator("mt").compare)
	if (control.join("") == "Cc") {aCollator = ['mt']} // so while Mac !== Cc then only FF will test and report mt

	let aList = [
		["0bea6b5efcc437aeea70b7f35af0711e6cec9814", 50, ['eo','gl','ka','om'], aCollator, "Collator"],
		["790e3b04199bd0b1b1132eccd6775d8fd22d8ea6", 50, ['as','fo','ln','ne','to'], ['co','nr','st','tig'], "DateTimeFormat"],
		["aef0c6da2478d759e406af5ede5c19b31384b02c", 86, ['br','eu','ii','ks','ps'], ['cv','iu','nv','tn' ], "DisplayNames"],
		["bb051f059f75b8d78c7c0554f7bee9a1bdf04c9f", 78, ['ee','gd','kk','lo','yi'], ['ba','io','oc','ve' ], "ListFormat"],
		["44b2aba18a3f36f76240cb73ad38c8bc3a66c062", 50, ['bo','ha','lb','my','sq'], ['dv','ny','oc','ts' ], "NumberFormat"],
		["8ef0a7f2554f893f131b36f05de01cdf5bb17620", 58, ['ki','lu','qu','rn','rw'], ['ba','co','gn','oc' ], "PluralRules"],
		["d0b4844a8b0561638d4f355bc68aaaf5c1e04149", 65, ['cy','km','mg','os','sn'], ['gn','nso','ss','wa'], "RelativeTimeFormat"],
	]

	num = (num - 5)
	aList.forEach(function(array) {
		num += 5
		let t0; if (canPerf) {t0 = performance.now()}
		let expected = array[0],
			minVer = array[1],
			list = array[2].concat(array[3]).sort(),
			type = array[4],
			res = []
		let title = "Intl."+ type
		if (bBlock) {bB = 1}
		try {
			if (type == "Collator") { res = Intl.Collator.supportedLocalesOf(list)
			} else if (type == "DateTimeFormat") { res = Intl.DateTimeFormat.supportedLocalesOf(list)
			} else if (type == "DisplayNames") { res = Intl.DisplayNames.supportedLocalesOf(list)
			} else if (type == "ListFormat") { res = Intl.ListFormat.supportedLocalesOf(list)
			} else if (type == "NumberFormat") { res = Intl.NumberFormat.supportedLocalesOf(list)
			} else if (type == "PluralRules") { res = Intl.PluralRules.supportedLocalesOf(list)
			} else if (type == "RelativeTimeFormat") { res = Intl.RelativeTimeFormat.supportedLocalesOf(list)
			}
			let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
			//console.log(title, hash)
			let bool = hash == expected
			if (res.length > 0) {
				if (res.join(", ").length < 48) {
					hash = res.join(", ")
				} else {
					sDetail["specific_"+ title] = res
					hash += buildButton(3, "specific_"+ title, res.length)
				}
			}
			let perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num, title, hash, bool, "skip", perf)
		} catch(e) {
			if (isFF) {
				if (isVer >= minVer) {
					fnRecord(num, title, e.name, zB0, e.message)
				} else {
					let msg = e.message
					msg = msg.replace("can't access property \"supportedLocalesOf\", ", "") // trim *error_fix
					if (e.name == "TypeError" && msg == "Intl." + type +" is undefined") {
						fnRecord(num, title, zNA +": FF" + minVer +"+ required", zNA)
					} else {
						fnRecord(num, title, e.name, zB0, e.message)
					}
				}
			} else {
				fnRecord(num, title, zNA +": not supported", zNA)
			}
		}
	})
}

function get_js_client_hints(num, title) {
	// testing: https://web.dev/user-agent-client-hints/
	// https://user-agent-client-hints.glitch.me/javascript.html
	// TypeError can't access property "X", navigator.X is undefined
	function output() {
		let perf = canPerf ? performance.now() - t0 : ""
		if (res.length > 0) {
			res.sort()
			sDetail["unexpected_"+ title] = res
			let hash = mini_sha1(res.join()) + buildButton(3, "unexpected_"+ title , res.length)
			fnRecord(num, title, hash, false, "skip", perf)
		} else {
			fnRecord(num, title, "none", true, "skip", perf)
		}
	}
	let res = []
	let t0; if (canPerf) {t0 = performance.now()}

	try {
		let resB = navigator.userAgentData.brands
		resB.forEach(function(object) {
			let valueB = fnClean(object.version)
			res.push("brands: "+ object.brand +": "+ valueB)
		})
	} catch(e) {}
	try {
		res.push("mobile: " + navigator.userAgentData.mobile)
	} catch(e) {}
	try {
		res.push("platform: " + navigator.userAgentData.platform)
	} catch(e) {}
	try {
		navigator
			.userAgentData.getHighEntropyValues(
				["architecture","bitness","brands","mobile","model","platform","platformVersion","uaFullVersion"]
			).then(ua => {
				const names = Object.keys(ua)
				for (const k of names) {
					let valueU = fnClean(ua[k])
					res.push("high entropy: "+ k +": "+ valueU)
				}
				output()
			})
	} catch(e) {
		output()
	}
}

function get_last_prototype_keys(num1, title) {
	// HTMLAnchorElement
	let title1 = title +" HTMLAnchorElement"
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		Object.keys(HTMLAnchorElement.prototype)
		let props1 = Object.getOwnPropertyNames(HTMLAnchorElement.prototype) // includes the constructor
		let res1 = props1.slice(-3).join(", ")
		// search, hash, constructor
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num1, title1, res1, res1 == "search, hash, constructor", "skip", perf)
	} catch(e) {
		fnRecord(num1, title1, e.name, zB0, e.message)
	}

	// HTMLLinkElement
	let title2 = title +" HTMLLinkElement"
	let num2 = num1 + 1
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		Object.keys(HTMLLinkElement.prototype)
		let props2 = Object.getOwnPropertyNames(HTMLLinkElement.prototype) // includes the constructor
		let res2 = props2.slice(-3).join(", ")
		let bool2 = res2 == "as, sheet, constructor"
		// 52-55: integrity, sheet, constructor
		if (isVer <= 56 && res2 == "integrity, sheet, constructor") {bool2 = true}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num2, title2, res2, bool2, "skip", perf)
	} catch(e) {
		fnRecord(num2, title2, e.name, zB0, e.message)
	}
}

function get_locale_compare(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let list = [
			["cy","n","ng"],
			["gl","\u00F1","ng"],
			["ha","ts","tt"],
			["hsb","\u0107","\u0109"],
			["ig","c","ch"],
			["ka","\u0107","\u10D0"],
			["mt","c","C"], // MAC: Intl.Collator supportedlocale but does not collate it
			["om","ch","\u00ED"],
			["sq","\u00EB","ez"],
			["to","\u00ED","\u00EE"],
			// removed: we don't need all of these
			/*["az","\u00F6","\u1EE3"],
			["dsb","\u0144","\u00F1"],
			["ee","ts","tt"],
			["eo","\u0109","\u00E7\a"],
			["haw","\u00F0","\u00EB"],
			["kk","r","\u0453"],
			["ln","\u1D95","\u025B"],
			["lo","\u0107","\u0E9A"],
			["pa","\u0107","\u0649"],
			["se","\u00F6","\u1EE3"],*/
			// removed for FF52+ stability
				//["no","\u00F6","\u1EE3"],
				//["wo","\u00EB","ez"],
		]
		let res = [], same = []
		list.forEach(function(item) {
			let code = item[0]
			let strA = item[1]
			let test = strA.localeCompare(item[2], code)
			if (test !== 1) {same.push(code)}
			//res.push(code +": "+ test +": "+ strA +", "+ item[2])
			res.push(test)
		})
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		//console.log(hash)
		let bool = hash == "d4ed607dd4781454263f3c3fc6d92b55b2980ad2"
		if (res.length > 0) {
			hash = res.join(", ")
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_math(num, title) {
	// polyfill
	function cbrt(x) {
		try {
			let y = Math.pow(Math.abs(x), 1 / 3)
			return x < 0 ? -y : y
		} catch(e) {
			return "error"
		}
	}
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let res = []
		for(let i=0; i < 6; i++) {
			try {
				let fnResult = "unknown"
				if (i == 0) {fnResult = cbrt(Math.PI) // polyfill
				} else if (i == 1) {fnResult = Math.log10(7*Math.LOG10E)
				} else if (i == 2) {fnResult = Math.log10(2*Math.SQRT1_2)
				} else if (i == 3) {fnResult = Math.acos(0.123)
				} else if (i == 4) {fnResult = Math.acosh(Math.SQRT2)
				} else if (i == 5) {fnResult = Math.atan(2)
				}
				res.push(fnResult)
			} catch(e) {
				res.push("error")
			}
		}
		// I have to use sha1 due to legacy data
		let hash = sha1(res.join()).substring(0,20)
		let engine = "unkown"
		if (hash == "ede9ca53efbb1902cc21") {engine = "blink"
		} else if (hash == "05513f36d87dd78af60a") {engine = "webkit"
		} else if (hash == "38172d9426d77af71baa") {engine = "edgeHTML"
		} else if (hash == "36f067c652c8cfd90725") {engine = "trident"
		} else if (hash == "225f4a612fdca4065043") {engine = "gecko"
		} else if (hash == "cb89002a8d6fabf859f6") {engine = "gecko"
		}
		let bool = engine == "gecko" ? true : false
		// now redo as mini_sha1
		sDetail["expected_"+ title] = res
		hash = mini_sha1(res.join()) + buildButton(3, "expected_"+ title, engine)
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_media_constraints(num, title) {
	// blink: 18c59e90bb3af0ce32be8efaa4457ead01fcacd8 [32]
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let data = navigator.mediaDevices.getSupportedConstraints()
		let res = Object.keys(data)
		res.sort()
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		let bool = false
		if (isVer > 69) {
			if (hash == "869109a73d3128c2eb4a8277aff0fec0cf8d0e47") {bool = true} // FF70+
		} else {
			if (hash == "499818d3e86b70bd61300a52f1429bb359365890") {bool = true} // FF56-69
			if (isVer < 57) {
				if (hash == "c536cceca9d2a679656c7d785e6ada5e5a9016cb") {bool = true} // FF55
			}
			if (isVer < 55) {
				if (hash == "846c4bd6379d808ac2d2890954e7f909ba2b9458") {bool = true} // FF52-54
			}
		}
		if (res.length > 0) {
			sDetail["expected_"+ title] = res
			hash += buildButton(3, "expected_"+ title, res.length)
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		// e.g. TB disables mediaDevices
		let error = mini(e.name +": "+ e.message), isNA = false
		if (error == "f2244861") {
			// TypeError: can't access property "getSupportedConstraints", navigator.mediaDevices is undefined
			isNA = true
		} else if (error == "9fc627cf") {
			// TypeError: navigator.mediaDevices is undefined
			isNA = true
		}
		if (isNA) {
			fnRecord(num, title, zNA +": disabled", zNA)
		} else {
			fnRecord(num, title, e.name, zB0, e.message)
		}
	}
}

function get_mimetypes(num, title) {
	try {
		let t0, perf; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		if ("mimeTypes" in navigator) {
			let res = [], bool = false
			let m = navigator.mimeTypes
			if (m.length == 0) {
				perf = canPerf ? performance.now() - t0 : ""
				fnRecord(num, title, "none", true, "skip", perf)
			} else {
				for (let i=0; i < m.length; i++) {
					res.push( m[i].type + (m[i].description == "" ? ": * " : ": "+ m[i].type)
						+ (m[i].suffixes == "" ? ": *" : ": "+ m[i].suffixes) )
				}
				res.sort()
				// FF84 or lower allow just Flash
				if (isFF && isVer < 85 && res.length == 2) {
					let mime1 = res[0].split(":")[0]
					let mime2 = res[1].split(":")[0]
					if (mime1 == "application/x-futuresplash" && mime2 == "application/x-shockwave-flash") {
						bool = true
					}
				}
				let hash = mini_sha1(res.join())
				if (isVer > 98 || !isFF) { // allow non-FF to have the same
					// FF99+: controlled by pdfjs.disabled
					// 1720353: hardcoded mimeTypes
					if (hash == "5b8b5b83ff5790df763d417ec6e2adbbf0570c47") {
						bool = true
					}
				}
				sDetail["expected_"+ title] = res
				hash += buildButton(3, "expected_"+ title, res.length)
				perf = canPerf ? performance.now() - t0 : ""
				fnRecord(num, title, hash, bool, "skip", perf)
			}
		} else {
			fnRecord(num, title, e.name, zB0)
		}
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_moz_colors(num, title) {
	let aList = [
		// css4
		'-moz-activehyperlinktext','-moz-default-color','-moz-default-background-color','-moz-hyperlinktext','-moz-visitedhyperlinktext',
		// stand-ins
		'-moz-buttondefault','-moz-buttonhoverface','-moz-buttonhovertext','-moz-cellhighlight','-moz-cellhighlighttext','-moz-combobox','-moz-comboboxtext','-moz-dialog','-moz-dialogtext','-moz-dragtargetzone','-moz-eventreerow','-moz-field','-moz-fieldtext','-moz-html-cellhighlight','-moz-html-cellhighlighttext','-moz-mac-chrome-active','-moz-mac-chrome-inactive','-moz-mac-disabledtoolbartext','-moz-mac-focusring','-moz-mac-menuselect','-moz-mac-menushadow','-moz-mac-menutextdisable','-moz-mac-menutextselect','-moz-mac-secondaryhighlight','-moz-menubarhovertext','-moz-menubartext','-moz-menuhover','-moz-menuhovertext','-moz-nativehyperlinktext','-moz-oddtreerow','-moz-win-communicationstext','-moz-win-mediatext',
		// moz
		'-moz-accent-color','-moz-accent-color-foreground','-moz-appearance','-moz-colheaderhovertext','-moz-colheadertext','-moz-gtk-buttonactivetext','-moz-gtk-info-bar-text','-moz-mac-accentdarkestshadow','-moz-mac-accentdarkshadow','-moz-mac-accentface','-moz-mac-accentlightesthighlight','-moz-mac-accentlightshadow','-moz-mac-accentregularhighlight','-moz-mac-accentregularshadow','-moz-mac-active-menuitem','-moz-mac-active-source-list-selection','-moz-mac-buttonactivetext','-moz-mac-defaultbuttontext','-moz-mac-menuitem','-moz-mac-menupopup','-moz-mac-source-list','-moz-mac-source-list-selection','-moz-mac-tooltip','-moz-mac-vibrancy-dark','-moz-mac-vibrancy-light','-moz-mac-vibrant-titlebar-dark','-moz-mac-vibrant-titlebar-light','-moz-win-accentcolor','-moz-win-accentcolortext','-moz-win-communications-toolbox','-moz-win-media-toolbox',
	]
	aList.sort()
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let aRes = []
		let element = dom.mozColor
		let strColor = "rgba(1, 2, 3, 0.5)"
		aList.forEach(function(style) {
			element.style.backgroundColor = strColor // always reset
			element.style.backgroundColor = style
			let rgb = window.getComputedStyle(element, null).getPropertyValue("background-color")
			if (rgb !== strColor) {
				aRes.push(style +":"+ rgb) // only record those affected
			}
		})
		let bool = aRes.length > 0
		if (bool) {
			sDetail["expected_"+ title] = aRes
		}
		let hash = bool ? mini_sha1(aRes.join()) + buildButton(3, "expected_"+ title, aRes.length) : "none"
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_moz_fonts(num, title) {
	let aResults = [],
		m = "-moz-",
		aFonts = [m+"window",m+"desktop",m+"document",m+"workspace",m+"info",m+"pull-down-menu",m+"dialog",m+"button",m+"list",m+"field"]
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		let el = dom.mozFont
		if (bBlock) {bB = 1}
		aFonts.forEach(function(font){
			// catch blocked
			let test = getComputedStyle(el).getPropertyValue("font-family")
			el.style.font = "99px sans-serif"
			try {el.style.font = font} catch(err) {}
			let s = ""
			if (window.getComputedStyle) {
				try {
					s = getComputedStyle(el, null)
				} catch(e) {}
			}
			if (s !== "") {
				let f = s.fontSize != "99px" ? s.fontFamily : undefined
				if (f !== undefined) {aResults.push(f)}
			}
		})
		let bool = aResults.length > 0
		if (bool) {
			sDetail["expected_"+ title] = aResults
		}
		let hash = bool ? mini_sha1(aResults.join()) + buildButton(3, "expected_"+ title, aResults.length) : "none"
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_moz_objects(num, name) {
	let title = "["+ name +"] moz"
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let res = []
		let oList = {}
		let isObj = false
		let useHas = false // use hasOwnProperty or default getOwnPropertyDescriptor

		if (name === "Document" && "function" === typeof Document) {
			oList[name] = [Document.prototype,
				["mozSetImageElement","mozCancelFullScreen","mozFullScreen","mozFullScreenEnabled",
					"mozFullScreenElement","onmozfullscreenchange","onmozfullscreenerror"]
				]
		}
		if (name === "HTMLElement" && "function" === typeof HTMLElement) {
			oList[name] = [HTMLElement.prototype, ["onmozfullscreenchange","onmozfullscreenerror"]]
		}
		if (name === "HTMLMediaElement" && "function" === typeof HTMLMediaElement) {
			oList[name] = [HTMLMediaElement.prototype, ["mozCaptureStream","mozCaptureStreamUntilEnded",
				"mozGetMetadata","mozPreservesPitch","mozAudioCaptured","mozFragmentEnd"]
			]
		}
		if (name === "HTMLVideoElement" && "function" === typeof HTMLVideoElement) {
			oList[name] = [HTMLVideoElement.prototype, ["mozParsedFrames","mozDecodedFrames",
				"mozPresentedFrames","mozPaintedFrames","mozFrameDelay","mozHasAudio"]
			]
		}
		if (name === "MouseEvent" && "function" === typeof MouseEvent) {
			oList[name] = [MouseEvent.prototype,
				["MOZ_SOURCE_UNKNOWN","MOZ_SOURCE_MOUSE","MOZ_SOURCE_PEN","MOZ_SOURCE_ERASER",
				"MOZ_SOURCE_CURSOR","MOZ_SOURCE_TOUCH","MOZ_SOURCE_KEYBOARD","mozPressure",
				"mozInputSource","MOZ_SOURCE_UNKNOWN","MOZ_SOURCE_MOUSE","MOZ_SOURCE_PEN",
				"MOZ_SOURCE_ERASER","MOZ_SOURCE_CURSOR","MOZ_SOURCE_TOUCH","MOZ_SOURCE_KEYBOARD"]
			]
		}
		if (name === "Screen" && "function" === typeof Screen) {
			oList[name] = [Screen.prototype,
				["mozLockOrientation","mozUnlockOrientation","mozOrientation","onmozorientationchange"]
			]
		}
		if (name === "SVGElement" && "function" === typeof SVGElement) {
			oList[name] = [SVGElement.prototype,["onmozfullscreenchange","onmozfullscreenerror"]]
		}
		if (name === "HTMLInputElement" && "function" === typeof HTMLInputElement) {
			oList[name] = [HTMLInputElement.prototype,["mozIsTextField"]]
		}
		if (name === "Navigator" && "function" === typeof Navigator) {
			oList[name] = [Navigator.prototype,["mozGetUserMedia"]]
		}
		if (name === "HTMLCanvasElement" && "function" === typeof HTMLCanvasElement) {
			oList[name] = [HTMLCanvasElement.prototype,["mozOpaque","mozPrintCallback"]]
		}
		if (name === "CanvasRenderingContext2D" && "function" === typeof CanvasRenderingContext2D) {
			oList[name] = [CanvasRenderingContext2D.prototype,
				["mozCurrentTransform","mozCurrentTransformInverse","mozTextStyle","mozImageSmoothingEnabled"]
			]
		}
		if (name === "MathMLElement" && "function" === typeof MathMLElement) {
			oList[name] = [MathMLElement.prototype,["onmozfullscreenchange","onmozfullscreenerror"]]
		}
		if (name === "DataTransfer" && "function" === typeof DataTransfer) {
			oList[name] = [DataTransfer.prototype,["mozCursor","mozUserCancelled","mozSourceNode"]]
		}
		if (name === "ShadowRoot" && "function" === typeof ShadowRoot) {
			oList[name] = [ShadowRoot.prototype,["mozFullScreenElement"]]
		}
		if (name === "XMLHttpRequest" && "function" === typeof XMLHttpRequest) {
			oList[name] = [XMLHttpRequest.prototype,["mozAnon","mozSystem"]]
		}
		if (name === "IDBObjectStore" && "function" === typeof IDBObjectStore) {
			oList[name] = [IDBObjectStore.prototype,["mozGetAll"]]
		}
		if (name === "IDBIndex" && "function" === typeof IDBIndex) {
			oList[name] = [IDBIndex.prototype,["mozGetAll","mozGetAllKeys"]]
		}
		if (name === "OfflineResourceList" && "function" === typeof OfflineResourceList) {
			oList[name] = [OfflineResourceList.prototype,
				["mozHasItem","mozItem","mozAdd","mozRemove","mozItems","mozLength"]
			]
		}
		if (name === "Element" && "function" === typeof Element) {
			useHas = true
			oList[name] = [Element.prototype,["mozMatchesSelector","â€‹mozRequestFullScreen"]]
		}
		if (name === "CSS2Properties" && "function" === typeof CSS2Properties) {
			oList[name] = [CSS2Properties.prototype,
				['MozAnimation','MozAnimationDelay','MozAnimationDirection','MozAnimationDuration','MozAnimationFillMode',
				'MozAnimationIterationCount','MozAnimationName','MozAnimationPlayState','MozAnimationTimingFunction',
				'MozAppearance','MozBackfaceVisibility','MozBorderEnd','MozBorderEndColor','MozBorderEndStyle',
				'MozBorderEndWidth','MozBorderImage','MozBorderStart','MozBorderStartColor','MozBorderStartStyle',
				'MozBorderStartWidth','MozBoxAlign','MozBoxDirection','MozBoxFlex','MozBoxOrdinalGroup','MozBoxOrient',
				'MozBoxPack','MozBoxSizing','MozFloatEdge','MozFontFeatureSettings','MozFontLanguageOverride',
				'MozForceBrokenImageIcon','MozHyphens','MozImageRegion','MozMarginEnd','MozMarginStart','MozOrient',
				'MozPaddingEnd','MozPaddingStart','MozPerspective','MozPerspectiveOrigin','MozTabSize','MozTextSizeAdjust',
				'MozTransform','MozTransformOrigin','MozTransformStyle','MozTransition','MozTransitionDelay',
				'MozTransitionDuration','MozTransitionProperty','MozTransitionTimingFunction','MozUserFocus','MozUserInput',
				'MozUserModify','MozUserSelect','MozWindowDragging',
				// aliases
				'-moz-animation','-moz-animation-delay','-moz-animation-direction','-moz-animation-duration',
				'-moz-animation-fill-mode','-moz-animation-iteration-count','-moz-animation-name','-moz-animation-play-state',
				'-moz-animation-timing-function','-moz-appearance','-moz-backface-visibility','-moz-border-end',
				'-moz-border-end-color','-moz-border-end-style','-moz-border-end-width','-moz-border-image','-moz-border-start',
				'-moz-border-start-color','-moz-border-start-style','-moz-border-start-width','-moz-box-align',
				'-moz-box-direction','-moz-box-flex','-moz-box-ordinal-group','-moz-box-orient','-moz-box-pack',
				'-moz-box-sizing','-moz-float-edge','-moz-font-feature-settings','-moz-font-language-override',
				'-moz-force-broken-image-icon','-moz-hyphens','-moz-image-region','-moz-margin-end','-moz-margin-start',
				'-moz-orient','-moz-padding-end','-moz-padding-start','-moz-perspective','-moz-perspective-origin',
				'-moz-tab-size','-moz-text-size-adjust','-moz-transform','-moz-transform-origin','-moz-transform-style',
				'-moz-transition','-moz-transition-delay','-moz-transition-duration','-moz-transition-property',
				'-moz-transition-timing-function','-moz-user-focus','-moz-user-input','-moz-user-modify','-moz-user-select',
				'-moz-window-dragging',
				]
			]
		}
		// object
		if (name === "window" && "object" == typeof window) {
			isObj = true
			oList[name] = [window,["mozRTCPeerConnection","CSSMozDocumentRule"]]
		}

		// do it!
		if (oList[name] !== undefined) {
			let obj = oList[name][0]
			let props = oList[name][1]
			if (isObj) {
				props.forEach(function(element) {
					if (element in obj) {res.push(element)}
				})
			} else if (useHas) {
				props.forEach(function(element) {
					if (obj.hasOwnProperty(element)) {res.push(element)}
				})
			} else {
				props.forEach(function(element) {
					if ("object" === typeof Object.getOwnPropertyDescriptor(obj, element)) {
						res.push(element)
					}
				})
			}
			res.sort()
		}
		let hash = "none", bool = false
		if (res.length > 0) {
			if (res.join(", ").length < 48) {
				hash = res.join(", ")
			} else {
				sDetail["expected_"+ title] = res
				hash = mini_sha1(res.join()) + buildButton(3, "expected_"+ title, res.length)
			}
			bool = true
		} else if (isFF) {
			// FF none exceptions
			if (isVer < 63 && name === "ShadowRoot") {bool = zNA, hash = zNA +": FF63+ required"}
			if (isVer < 71 && name === "MathMLElement") {bool = zNA, hash = zNA +": FF71+ required"}
			if (name === "OfflineResourceList") {bool = zNA, hash = zNA +": assuming Beta/Dev/Nightly pref"}
			if (isEngine === "goanna" && name === "Navigator") {bool = zNA, hash = zNA +": Palemoon"}
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_nav_keys(num1, num2, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let aNavKeys = Object.keys(Object.getOwnPropertyDescriptors(Navigator.prototype))
		// expected FF only
		let aExpected = ["buildID","oscpu","taintEnabled"]
		let resE = aNavKeys.filter(x => aExpected.includes(x))
		let boolE = resE.length == 3 ? true : false
		resE = resE.length > 0 ? resE.join(", ") : "none"
		let perfE = canPerf ? performance.now() - t0 : ""
		fnRecord(num1, title, resE, boolE, "skip", perfE)

		// not expected: blink items
		let aNot = ["canShare","clearAppBadge","deviceMemory","getBattery","getInstalledRelatedApps",
			"getUserMedia","globalPrivacyControl","hid","keyboard","locks","managed","presentation","scheduling",
			"serial","setAppBadge","unregisterProtocolHandler","usb","userActivation","userAgentData","wakeLock",
			"webkitGetUserMedia","webkitPersistentStorage","webkitTemporaryStorage","xr","SharedWorker","Worker"]
		// FYI: don't use requestMIDIAccess: FF60+ behind dom.webmidi.enabled... 1752906: FF99+ default enabled
		if (isVer > 95) {
			// 1666203: FF96+ canShare
			aNot = aNot.filter(x => !["canShare"].includes(x))
		}
		if (isVer > 94 || isEngine == "goanna") {
			// 1670058: FF95+ globalPrivacyControl
			// PM 30
			aNot = aNot.filter(x => !["globalPrivacyControl"].includes(x))
		}
		if (isVer > 92) {
			// FF93+ "dom.weblocks.enabled"
			// 1739233: FF96+ locks
			aNot = aNot.filter(x => !["locks"].includes(x))
		}
		let resN = aNavKeys.filter(x => aNot.includes(x))
		let boolN = resN.length == 0
		if (resN.length > 0) {
			sDetail["unexpected_"+ title] = resN
			resN = mini_sha1(resN.join()) + buildButton(3, "unexpected_"+ title, resN.length)
		} else {
			resN = "none"
		}
		let perfN = canPerf ? performance.now() - t0 : ""
		fnRecord(num2, title, resN, boolN, "skip", perfN)
	} catch(e) {
		fnRecord(num1, title, e.name, zB0, e.message)
		fnRecord(num2, title, e.name, zB0, e.message)
	}
}

function get_nav_screen(num) {
	let strA = "[left] screen", boolA = false
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = screen.left
		if (!isNaN(resA)) {boolA = true} else {resA = fnClean(resA)}
		let perfA = canPerf ? performance.now() - t0A : ""
		fnRecord(num, strA, resA, boolA, "skip", perfA)
	} catch(e) {
		fnRecord(num, strA, e.name, zB0, e.message)
	}
	let strB = "[top] screen", boolB = false
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = screen.top
		if (!isNaN(resB)) {boolB = true} else {resB = fnClean(resB)}
		let perfB = canPerf ? performance.now() - t0B : ""
		fnRecord(num+1, strB, resB, boolB, "skip", perfB)
	} catch(e) {
		fnRecord(num+1, strB, e.name, zB0, e.message)
	}
}

function get_nav_values(num1, num2, num3) {
	// expected
	let strA = "[oscpu] navigator", boolA = false
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = navigator.oscpu
		if (typeof resA !== "string") {
			//console.debug(typeof resA)
		} else {
			if (resA == "") {resA = "empty string"
			} else if (resA == undefined) {resA = zU
			} else if (resA == zU) {resA = zUQ
			} else {boolA = true}
		}
		let perfA = canPerf ? performance.now() - t0A : ""
		fnRecord(num1, strA, resA, boolA, "skip", perfA)
	} catch(e) {
		fnRecord(num1, strA, e.name, zB0, e.message)
	}

	// not expected
	// bluetooth
	let strBT = "[bluetooth] navigator", boolBT = false, numBT = num2
	try {
		let t0BT; if (canPerf) {t0BT = performance.now()}
		if (bBlock) {bB = 1}
		let resBT = navigator.bluetooth
		if (resBT === undefined) {
			let perfBT = canPerf ? performance.now() - t0BT : ""
			fnRecord(numBT, strBT, zU, true, "skip", perfBT)
		} else {
			try {
				navigator.bluetooth.getAvailability().then(available => {
					if (available) {
						fnRecord(numBT, strBT, "supported", boolBT)
					} else {
						fnRecord(numBT, strBT, "not supported", boolBT)
					}
				})
			} catch(e) {
				fnRecord(numBT, strBT, e.name, zB0)
			}
		}
	} catch(e) {
		fnRecord(numBT, strBT, e.name, zB0, e.message)
	}
	// deviceMemory
	let strDM = "[deviceMemory] navigator", boolDM = false, numDM = num2+2
	try {
		let t0DM; if (canPerf) {t0DM = performance.now()}
		if (bBlock) {bB = 1}
		let resDM = navigator.deviceMemory
		if (resDM == undefined) {boolDM = true}
		resDM = fnClean(resDM)
		let perfDM = canPerf ? performance.now() - t0DM : ""
		fnRecord(numDM, strDM, resDM, boolDM, "skip", perfDM)
	} catch(e) {
		fnRecord(numDM, strDM, e.name, zB0, e.message)
	}

	// globalprivacycontrol
	let strG = "[gpc] navigator", boolG = false, numG = num2+6
	try {
		let t0G; if (canPerf) {t0G = performance.now()}
		if (bBlock) {bB = 1}
		let resG = navigator.globalPrivacyControl
		resG = fnClean(resG)
		if (resG == "undefined") {boolG = true
		} else if (isEngine == "goanna" && resG == "empty string") {boolG = true; resG += s3 + " [goanna]"+ sc}

		// 1670058: FF95+ globalPrivacyControl
		if (isVer > 94) {
			resG = zNA +": FF94 or lower" + s3 +" ["+ resG +"]" + sc
			boolG = zNA
		}
		let perfG = canPerf ? performance.now() - t0G : ""
		fnRecord(numG, strG, resG, boolG, "skip", perfG)
	} catch(e) {
		fnRecord(numG, strG, e.name, zB0, e.message)
	}

	// keyboard
	let strK = "[keyboard] navigator", numK = num2+8
	let t0K, perfK; if (canPerf) {t0K = performance.now()}
	try {
		if (bBlock) {bB = 1}
		let resK = navigator.keyboard
		if (resK == undefined) {
			perfK = canPerf ? performance.now() - t0K : ""
			fnRecord(numK, strK, "undefined", true, "skip", perfK)
		} else {
			let keys = []
			// https://wicg.github.io/keyboard-map/
			// https://www.w3.org/TR/uievents-code/#key-alphanumeric-writing-system
			let listK = ['Backquote','Backslash','Backspace','BracketLeft','BracketRight','Comma',
				'Digit0','Digit1','Digit2','Digit3','Digit4','Digit5','Digit6','Digit7','Digit8','Digit9',
				'Equal','IntlBackslash','IntlRo','IntlYen','KeyA','KeyB','KeyC','KeyD','KeyE','KeyF','KeyG',
				'KeyH','KeyI','KeyJ','KeyK','KeyL','KeyM','KeyN','KeyO','KeyP','KeyQ','KeyR','KeyS','KeyT',
				'KeyU','KeyV','KeyW','KeyX','KeyY','KeyZ','Minus','Period','Quote','Semicolon','Slash']
			resK.getLayoutMap().then(keyboardLayoutMap => {
				listK.forEach(function(key) {
					try {keys.push(key +": "+ keyboardLayoutMap.get(key))} catch(e) {keys.push(key +": e.name")}
				})
				sDetail["unexpected_"+ strK] = keys
				let hash = mini_sha1(keys.join()) + buildButton(3, "unexpected_"+ strK , keys.length)
				perfK = canPerf ? performance.now() - t0K : ""
				fnRecord(numK, strK, hash, false, "skip", perfK)
			})
		}
	} catch(e) {
		fnRecord(numK, strK, e.name, zB0, e.message)
	}

	// vendor
	let strV = "[vendor] navigator", boolV = false, numV = num2+10
	try {
		let t0V; if (canPerf) {t0V = performance.now()}
		if (bBlock) {bB = 1}
		let resV = navigator.vendor
		if (resV == "") {boolV = true}
		resV = fnClean(resV)
		let perfV = canPerf ? performance.now() - t0V : ""
		fnRecord(numV, strV, resV, boolV, "skip", perfV)
	} catch(e) {
		fnRecord(numV, strV, e.name, zB0, e.message)
	}

	// navigator.webkitTemporaryStorage.queryUsageAndQuota
		// "TypeError: can't access property "queryUsageAndQuota", navigator.webkitTemporaryStorage is undefined"
	// navigator.webkitPersistentStorage.queryUsageAndQuota
		// "TypeError: can't access property "queryUsageAndQuota", navigator.webkitPersistentStorage is undefined"

	// specific
	let strX = "[buildID] navigator", boolX = false
	try {
		let t0X; if (canPerf) {t0X = performance.now()}
		if (bBlock) {bB = 1}
		let resX = navigator.buildID
		if (isVer > 63) {
			// all FF64+
			if (resX == "20181001000000") {boolX = true}
		} else {
			resX = fnClean(resX)
			// FF52-63: 14 digit number starting with 2017
			let year = resX.slice(0,4) *1
			if (resX.length == 14) {
				let isCheck = false
				if (year > 2016 && year < 2020) {isCheck = true}
				if (isVer < 59) {if (year > 2016) {isCheck = true}} // FF52 waterfox basilisk palemoon
				if (isCheck) {
					if (!isNaN(resX * 1)) {boolX = true}
				}
			} else if (isRFP) {
				// luckily RFP only alters buildID starting FF56
				// RFP FF56-63 = 20100101
				if (resX == "20100101") {boolX = true}
			}
		}
		let perfX = canPerf ? performance.now() - t0X : ""
		fnRecord(num3, strX, resX, boolX, "skip", perfX)
	} catch(e) {
		fnRecord(num3, strX, e.name, zB0, e.message)
	}
	// DNT: FF: 1, unspecified
	let strDNT = "[doNotTrack] navigator", boolDNT = false, numDNT = num3+2
	let t0DNT; if (canPerf) {t0DNT = performance.now()}
	try {
		if (bBlock) {bB = 1}
		let testDNT = navigator.doNotTrack
		if (testDNT == 1 || testDNT == "unspecified") {
			boolDNT = true
		} else {
			testDNT = fnClean(testDNT)
		}
		let perfDNT = canPerf ? performance.now() - t0DNT : ""
		if (isFF && !boolDNT) {
			// PM not supported: returns undefined
			if (isEngine == "goanna" && testDNT == "undefined") {
				fnRecord(numDNT, strDNT, testDNT, true, "skip", perfDNT)
			} else {
				fnRecord(numDNT, strDNT, testDNT, zB0, "skip", perfDNT)
			}
		} else {
			fnRecord(numDNT, strDNT, testDNT, boolDNT, "skip", perfDNT)
		}
	} catch(e) {
		fnRecord(numDNT, strDNT, e.name, zB0, e.message)
	}

	let strY = "[productSub] navigator", boolY = false, numY = num3+4
	try {
		let t0Y; if (canPerf) {t0Y = performance.now()}
		if (bBlock) {bB = 1}
		let resY = navigator.productSub
		if (resY == "20100101") {boolY = true} else {resY = fnClean(resY)}
		let perfY = canPerf ? performance.now() - t0Y : ""
		fnRecord(numY, strY, resY, boolY, "skip", perfY)
	} catch(e) {
		fnRecord(numY, strY, e.name, zB0, e.message)
	}

	// not expected
	// getbattery
	let strB = "[getBattery] navigator", boolB = false, numB = num2+4
	let resB = []
	let t0B, perfB; if (canPerf) {t0B = performance.now()}
	try {
		if (bBlock) {bB = 1}
		// not going to add eventlisteners
		navigator.getBattery().then(function(battery) {
			try {resB.push(battery.level * 100 + "%")} catch(e) {resB.push("error")}
			try {resB.push((battery.charging ? "": "not ") +"charging")} catch(e) {resB.push("error")}
			try {resB.push(battery.chargingTime)} catch(e) {resB.push("error")}
			try {resB.push(battery.dischargingTime)} catch(e) {resB.push("error")}
			perfB = canPerf ? performance.now() - t0B : ""
			fnRecord(numB, strB, resB.join(", "), false, "skip", perfB)
		})
	} catch(e) {
		if (e.name == "TypeError" && e.message.substring(0,38) == "navigator.getBattery is not a function") {
			if (e.message == "navigator.getBattery is not a function") {boolB = true} // webkit wil be false
			perfB = canPerf ? performance.now() - t0B : ""
			fnRecord(numB, strB, e.name, boolB, e.message, perfB)
		} else {
			fnRecord(numB, strB, e.name, zB0, e.message)
		}
	}

}

function get_obj_enumeration(num, title) {
	// 1762188
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let t = ['a','b'], result = []
		for (let i in t) {
			for (let j in t) {
				result.push([i, j, t[i], t[j]])
				let v = t[i]
				delete t[i]
				t[i] = v
			}
		}
		let res = result.join(",") // nonFF = 0,0,a,a,0,1,a,b,1,0,b,a,1,1,b,b
		let bool = res == "0,0,a,a,0,1,a,b,1,0,b,a" ? true : false
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, res, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_permission(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let userVis = "userVisibleOnly"
		navigator.permissions.query({name:"push"}).then(function(result) {
			let res = result.state
			let bool = (res == "prompt" || res == "denied" || res == "granted") ? true : false
			let perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num, title, res, bool, "skip", perf)
		}).catch(error => {
			let perfErr = canPerf ? performance.now() - t0 : ""
			if ((error.message).includes(userVis)) {
				fnRecord(num, title, userVis, false, "skip", perfErr)
			} else {
				fnRecord(num, title, error.name, zB0, error.message)
			}
		})
	} catch(e) {
		// not supported in webkit: https://caniuse.com/?search=push%20permission
		if (isWebkit) {
			fnRecord(num, title, "not supported", false)
		} else {
			fnRecord(num, title, e.name, zB0, e.message)
		}
	}
}

function get_plugins(num, title) {
	try {
		let t0, perf; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		if ("plugins" in navigator) {
			let res = [], bool = false
			let p = navigator.plugins
			if (p.length == 0) {
				perf = canPerf ? performance.now() - t0 : ""
				fnRecord(num, title, "none", true, "skip", perf)
			} else {
				for (let i=0; i < p.length; i++) {
					res.push(p[i].name + (p[i].filename == "" ? ": * " : ": "+ p[i].filename)
						+ (p[i].description == "" ? ": *" : ": "+ p[i].description))
				}
				res.sort()
				// FF84 or lower allow just Flash
				if (isFF && isVer < 85 && res.length == 1) {
					if (res[0].split(":")[0] == "Shockwave Flash") {bool = true}
				}
				let hash = mini_sha1(res.join())
				if (isVer > 98 || !isFF) { // allow non-FF to have the same
					// FF99+: controlled by pdfjs.disabled
					// 1720353: hardcoded mimeTypes
					if (hash == "6232b915d6de71c787a36eb42b75d2b8e24aa4d3") {
						bool = true
					}
				}
				sDetail["expected_"+ title] = res
				hash += buildButton(3, "expected_"+ title, res.length)
				perf = canPerf ? performance.now() - t0 : ""
				fnRecord(num, title, hash, bool, "skip", perf)
			}
		} else {
			fnRecord(num, title, e.name, zB0)
		}
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_stacklength(num1, num2, num3) {
	let t0; if (canPerf) {t0 = performance.now()}
	let level = 0, test1 = 0
	function recurse() {
		level++
		recurse()
	}
	try {
		recurse()
	} catch(e) {
		test1 = level
	}
	level = 0
	try {
		recurse()
	} catch(e) {
		// timing an error property lookup is not the same as generating a alow recurse one
		let t0E; if (canPerf) {t0E = performance.now()}
		// columnNumber
		let strCN = "[columnNumber] error", errCN = false
		try {
			if (bBlock) {bB = 1}
			let resCN = e.columnNumber
			let testCN = resCN == undefined? false : true
			let perfCN = canPerf ? performance.now() - t0E : ""
			fnRecord(num1, strCN, resCN, testCN, "skip", perfCN)
		} catch(n) {
			fnRecord(num1, strCN, n.name, zB0, n.message)
		}
		// fileName
		let strFN = "[fileName] error", errFN = false
		try {
			if (bBlock) {bB = 1}
			let resFN = e.fileName
			if (resFN !== undefined) {resFN = resFN.slice(0,8) + "..."}
			let testFN = resFN == undefined? false : true
			let perfFN = canPerf ? performance.now() - t0E : ""
			fnRecord(num1+1, strFN, resFN, testFN, "skip", perfFN)
		} catch(n) {
			fnRecord(num1+1, strFN, n.name, zB0, n.message)
		}
		// lineNumber
		let strLN = "[lineNumber] error", errLN = false
		try {
			if (bBlock) {bB = 1}
			let resLN = e.lineNumber
			let testLN = resLN == undefined? false : true
			let perfLN = canPerf ? performance.now() - t0E : ""
			fnRecord(num1+2, strLN, resLN, testLN, "skip", perfLN)
		} catch(n) {
			fnRecord(num1+2, strLN, n.name, zB0, n.message)
		}

		// first error
		let perf = canPerf ? performance.now() - t0 : ""
		let strRE = "error", resRE = e.name +": "+ e.message
		if (resRE == "InternalError: too much recursion") {
			fnRecord(num3, strRE, resRE, true, "skip", perf)
		} else {
			fnRecord(num3, strRE, resRE, false, "skip", perf)
		}
		// stack length
		let strSL = "stack length"
		try {
			if (bBlock) {bB = 1}
			let resSL = e.stack.toString().length
			let testSL = resSL == 8192 ? true : false
			if (isFile) {
				testSL = zNA
				resSL = zNA +": file://"
			}
			fnRecord(num2, strSL, resSL, testSL, "skip", perf)
		} catch(n) {
			fnRecord(num2, strSL, n.name, zB0, n.message, perf)
		}
	}
}

function get_storage_estimate(num, title) {

	// Notes: Win10 VM is  52gb / 33gb spare | FF is always the same in PB mode
		//   2147483648 : FF57-96 Windows / Android / Win 10 VM FF60-96
	/*
	FF97+ is not stable enough: see https://bugzilla.mozilla.org/show_bug.cgi?id=1735713
   10737418240 : Windows, vannTenn's + bashonly's Linux, Android Fabrizio 100gb spare from 128gb
    5641604300 : Android Fabrizio 49gb spare from 64gb
    5512729395 : Android Thorin 44gb spare from 64gb
    5301081292 : Android bashonly 40gb spare from 64gb
    5256596684 : Win 10 VM 33gb spare from 52gb
    2934867968 : Debian XCFE 2glops 650gb spare from 1TB
    1521166745 : Ubuntu VM Fabrizio with 15GB of storage
    1177328025 : Android aleyvo 1.5gb spare from 16gb
	*/

	// other: who cares if they match
		// brave:     2147483648 (same in incognito and Tor window)
		// opera:      310418104 normal
		// opera:      521917312 private
		// chrome: 1200238045593 normal
		// chrome:   33076376370 normal android
		// chrome:     485041940 incognito
		// chrome:     204974075 incognito android

	// ToDo: check if FF97+ new storage quota is based on disk or free disk space size
	let t0; if (canPerf) {t0 = performance.now()}
	try {
		if (bBlock) {bB = 1}
		navigator.storage.estimate().then(estimate => {
			let quota = estimate.quota,
				bool = false
			if (isVer > 96) {
				bool = zNA
				quota = zNA +": variable in FF97+ "+ s3 +"["+ quota +"]"+ sc
			} else {
				if (quota > 2147000000 && quota < 2148000000) {bool = true}
			}
			let perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num, title, quota, bool, "skip", perf)
		})
	} catch(e) {
		let msg = e.message.substring(0,26)
		if (isWebkit && e.name == "TypeError" && msg == "undefined is not an object") {
			fnRecord(num, title, e.name, false, e.message)
		} else {
			// FF56 or lower
			let result = e.name
			let type = zB0
			let error = e.message
			if (isFF && isVer < 59 && e.message == "navigator.storage is undefined") {
				result = zNA +": FF57+ required"
				type = zNA
				error = undefined
			}
			fnRecord(num, title, result, type, error)
		}
	}
}

function get_window_chrome(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let bool = "chrome" in window
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, bool, !bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zB0, e.message)
	}
}

function get_window_values(num) {
	//window.offscreenBuffering
	let strB = "[offscreenBuffering] window", boolB = false
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = window.offscreenBuffering
		if (resB == undefined) {boolB = true}
		resB = fnClean(resB)
		let perfB = canPerf ? performance.now() - t0B : ""
		fnRecord(num, strB, resB, boolB, "skip", perfB)
	} catch(e) {
		fnRecord(num, strB, e.name, zB0, e.message)
	}
	// window.openDatabase
	let strO = "[openDatabase] window", boolO = false
	let t0, perf = ""; if (canPerf) {t0 = performance.now()}
	try {
		if (bBlock) {bB = 1}
		window.openDatabase("test", "1.0", "test", 1024)
		perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num+2, strO, "success", boolO, "skip", perf)
	} catch(e) {
		if (e.name == "TypeError" && e.message == "window.openDatabase is not a function") {
			perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num+2, strO, e.name, true, e.message, perf)
		} else if (e.name == "UnknownError" && e.message == "Web SQL is deprecated") {
			fnRecord(num+2, strO, e.name, false, e.message) // webkit
		} else {
			fnRecord(num+2, strO, e.name, zB0, e.message)
		}
	}
}

function get_window_moz(num) {

	let strC = "[CSSMozDocumentRule] window"
	try {
		let t0C; if (canPerf) {t0C = performance.now()}
		if (bBlock) {bB = 1}
		let resC = typeof CSSMozDocumentRule
		let boolC = "function" === typeof CSSMozDocumentRule // FF53+
		if (!boolC && isFF) {
			// FF52 exception
			if (isVer < 55) {boolC = "object" === resC} // lowest ver test I have is 54
		}
		let perfC = canPerf ? performance.now() - t0C : ""
		fnRecord(num, strC, resC, boolC, "skip", perfC)
	} catch(e) {
		fnRecord(num, strC, e.name, zB0, e.message)
	}

	let strM = "[mozRTCPeerConnection] window"
	try {
		let t0M; if (canPerf) {t0M = performance.now()}
		if (bBlock) {bB = 1}
		let resM = typeof mozRTCPeerConnection
		let boolM = "function" === typeof mozRTCPeerConnection
		if (!boolM && isEngine == "goanna" & isVer == 52) {
			if ("undefined" === resM) {
				boolM = zNA
				resM = zNA +": Palemoon "+ s3 +"["+ resM +"]"+ sc
			}
		}
		let perfM = canPerf ? performance.now() - t0M : ""
		fnRecord(num+1, strM, resM, boolM, "skip", perfM)
	} catch(e) {
		fnRecord(num+1, strM, e.name, zB0, e.message)
	}

	let strA = "[mozInnerScreenX] window", boolA = false
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = window.mozInnerScreenX
		if (!isNaN(resA)) {boolA = true} else {resA = fnClean(resA)}
		let perfA = canPerf ? performance.now() - t0A : ""
		fnRecord(num+2, strA, resA, boolA, "skip", perfA)
	} catch(e) {
		fnRecord(num+2, strA, e.name, zB0, e.message)
	}
	let strB = "[mozInnerScreenY] window", boolB = false
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = window.mozInnerScreenY
		if (!isNaN(resB)) {boolB = true} else {resB = fnClean(resB)}
		let perfB = canPerf ? performance.now() - t0B : ""
		fnRecord(num+3, strB, resB, boolB, "skip", perfB)
	} catch(e) {
		fnRecord(num+3, strB, e.name, zB0, e.message)
	}
}

function get_legacyVer() {
	return new Promise(resolve => {
		// set webkit
		if ("chrome" in window || isFF) {} else {isWebkit = true}
		if (!isFF) {
			return resolve()
		}
		// set goanna
		if (isEngine == "gecko") {
			// check for PM28+ : fails 55 (1351795) but passes 57 (1378342)
				// note: waterfox classic passes both
			if ("undefined" !== typeof console.timeline && "function" === typeof AbortSignal) {
				isEngine = "goanna"
				// exit and return isVer as 52
				isVer = 52
				return resolve()
			}
		}
		// is55
		let is55 = false
		try {
			let maxIndex = Math.pow(2, 31)
			let list55 = []
			list55[maxIndex - 1] = 'a'
			list55[maxIndex - 0] = 'b'
			if (list55[maxIndex] !== 'b') {
			} else if (list55.slice()[maxIndex] !== 'b') {
			} else if (list55.slice(maxIndex - 1).length !== 2) {
			} else {
				is55 = true
			}
		} catch(e) {}

		// FF52-59
		if ("function" !== typeof Animation.prototype.updatePlaybackRate) {
			if (!HTMLMediaElement.prototype.hasOwnProperty("mozAutoplayEnabled")) {
				isVer = 59
			} else if ("function" == typeof Intl.PluralRules) {isVer = 58
			} else if ("function" === typeof AbortSignal) {isVer = 57
			} else if (is55) {
				minVer = 56
				isVer = 56
			} else {
				minVer = 54
				isVer = 54
			}
		}
		return resolve()
	})
}

function rerun() {
	// reset
	results = []
	itemnumbers = [],
	data = {},
	aPerf = [],
	count = 0,
	dom.perf = ""
	dom.results = ""
	// do it: delay for user to see visual change
	setTimeout(function() {
		run()
	}, 120)
}

function run() {
	// now get on with it
	fnRecord(0, "header", "expected")
	fnRecord(300, "header", "not expected")
	fnRecord(600, "header", "specific values")
	fnRecord(899, "hr")
	fnRecord(900, "header", "errors")
	// OK, let's kick some ass
	// stagger to get more accurate perf

	setTimeout(function() {
		if (canPerf) {gt0 = performance.now()}
		aPerf.push(["START 1", gt0])
		get_installtrigger(50) // 50-52
		get_eval_length(630, "eval.toString().length")
		get_colorgamut(310, "[css] color-gamut"),
		get_nav_screen(170)
		get_window_chrome(450, "[chrome] window"),
		get_obj_enumeration(734, "object enumeration")
		get_last_prototype_keys(640, "[last x keys]") // 640+641
		get_math(695, "math")
		get_nav_values(150, 400, 720) // 100 expected, 400-410 not expected, 720.. specific
		get_window_values(460)
		get_dates(620)
		get_js_client_hints(320, "[js] client hints")
		get_mimetypes(710, "mimetypes")
		get_plugins(740, "plugins")
		get_media_constraints(700, "[constraints] mediaDevices")
	}, 1)

	setTimeout(function() {
		aPerf.push(["START 2", performance.now(), performance.now() - gt0])
		get_moz_objects(88, "CanvasRenderingContext2D")
		get_moz_objects(94, "CSS2Properties")
		get_moz_objects(96, "DataTransfer")
		get_moz_objects(98, "Document")
		get_moz_objects(100, "Element")
		get_moz_objects(106, "HTMLElement")
		get_moz_objects(108, "HTMLCanvasElement")
		get_moz_objects(110, "HTMLInputElement")
		get_moz_objects(112, "HTMLMediaElement")
		get_moz_objects(114, "HTMLVideoElement")
		get_moz_objects(116, "IDBIndex")
		get_moz_objects(118, "IDBObjectStore")
		get_moz_objects(120, "MathMLElement") // added in FF71
		get_moz_objects(122, "MouseEvent")
		get_moz_objects(126, "Navigator")
			// ^media.peerconnection.enabled + media.navigator.enabled = false negative
		get_moz_objects(128, "OfflineResourceList")
			// ^pref: browser.cache.offline.enable [pref exists since Jesus]
			// nightly/beta/dev default off - since when? FF71+ 1237782 ?
		get_moz_objects(130, "Screen")
		get_moz_objects(132, "ShadowRoot") // added in FF63
		get_moz_objects(134, "SVGElement")
		get_moz_objects(136, "XMLHttpRequest")
	}, 1)

	setTimeout(function() {
		aPerf.push(["START 3", performance.now(), performance.now() - gt0])
		get_window_moz(250) // 250-255
		get_nav_keys(85, 350, "[navigator] keys") // 85 expected, 350 not expected
		get_intl_supportedlocales(655) // +5's: C, DTF, DN, LF, NF, PR, RTF
		get_intl_canonical_locale(667, "Intl.getCanonicalLocales")
		get_locale_compare(692, "locale.compare")
	}, 1)

	setTimeout(function() {
		aPerf.push(["START 4", performance.now(), performance.now() - gt0])
		get_moz_colors(90, "[colors] moz")
		get_moz_fonts(102, "[fonts] moz")
		get_errors(902)
		get_stacklength(30,800,901) // 30-32 error properties, 800 = stack length, 901 = first error message
	}, 1)

	setTimeout(function() {
		aPerf.push(["START THE END", performance.now(), performance.now() - gt0])
		get_iframe_props(40, 330, "[properties] iframe") // 40 expected, 330 not expected,
	}, 1)
	setTimeout(function() {
		get_permission(750, "[permissions] push")
		get_storage_estimate(820, "storage estimate")
	}, 1)

}

setTimeout(function() {
	Promise.all([
		get_globals()
	]).then(function(){
		Promise.all([
			get_isRFP(),
			get_is95(),
			get_legacyVer(),
		]).then(function(){
			if (isFF && isVer !== "") {
				run()
			} else {
				Promise.all([
					get_isVer(),
				]).then(function(){
					run()
				})			
			}
		})
	})
}, 50)

</script>
</body>
</html>
