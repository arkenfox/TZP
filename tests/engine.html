<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=620">
	<title>engine</title>
	<link rel="stylesheet" type="text/css" href="testindex.css">
	<script src="testglobals.js"></script>
	<script src="testgeneric.js"></script>
	<!-- custom -->
	<style>
		table {width: 700px;}
		#tb3 td:first-child { text-align: left; vertical-align: top;}
		hr {color: #dcc18c}
	</style>
</head>

<body>
	<div class="offscreen">
		<div id="mozFont"></div>
		<div id="test95a" style="width: min-content; hyphens: auto; border: 1px solid red">2020-1</div>
		<div id="test95b" style="width: min-content; hyphens: auto; border: 1px solid red">2020-12020-1</div>
	</div>
	<div class="hidden">
		<div><input type="time" min="14:00:00" max="12:00:00" value="15:00:00" id="test76"></div>
		<span id="mozColor"></span>
	</div>

	<table>
	<tr><td><h2>TorZillaPrint</h2></td></tr>
	<tr><td class="blurb"><a class="return" href="../index.html">return to TZP index</a></td></tr>
	</table>

	<table id="tb3">
		<col width="50%"><col width="50%">
		<thead><tr><th colspan="2">
			<div class="nav-title">engine
			<div class="nav-up"><span class="c perf" id="perf"></span></div>
			</div>
		</th></tr></thead>
		<tr><td colspan="2" class="intro">
			<span class="no_color">A tiny sample of the myriad ways engines differ. This test is tweaked
			for gecko [FF52+]: you want <span class="s9"><b> &#x2713 </b></span>'s. Anything different
			<span class="bad"><b> &#x2716 </b></span> or blocked <span class="s4"><b> &#x2715 </b></span>
			only makes you stand out. A single unspoofable property check can take as little as <span class="s3">0.01 ms</span>.
			</span>
		</td></tr>
		<tr><td colspan="2"><hr></td></tr>
		<tr><td colspan="2"><span class="no_color c mono spaces" id="results"></span></td></tr>
	</table>
	<br>

<script>
'use strict';

s3 = s3.trim()
s14 = s14.trim()
s99 = s99.trim()
sb = sb.trim()
sg = sg.trim()

let results = [],
	itemnumbers = [],
	data = {},
	aPerf = [],
	count = 0,
	expected = 95,
	gt0, // global timer
	bBlock = false, // throw a test error
	bNum = false // display numbering instead of perf

function fnTrim(str, len) {
	str = str.replace(/(\r\n|\n|\r)/gm,"")
	if (str.length > len) {str = str.slice(0,len-3) +"..."}
	return str
}

function fnClean(str) {
	if (str == "") {str = "empty string"
	} else if (str === undefined) {str = zU
	} else if (str == zU) {str = zUQ}
	return str
}

function logPerf() {
	if (aPerf.length) {
		console.log("PERF LOG\n", aPerf)
	}
}

function fnDisplay() {
	// perf
	let perfValue = ""
	if (canPerf) {
		perfValue = Math.round(performance.now() - gt0) +" ms"
		let perfTop = perfValue
		// remove the first 5 items: section headers + hr
		if (aPerf.length) {
			perfTop = "<span style='cursor: pointer;' onClick='logPerf()'>" + perfTop +"</span>"
			aPerf.splice(0, 5)
		}
		dom.perf.innerHTML = perfTop
	}
	// data -> ordered results
	const names = Object.keys(data).sort((a,b) => a-b)
	for (const k of names) {results.push(k +"~~~"+ data[k])}
	let display = [],
		errcount = 0
	let countTrue = 0, countFalse = 0, countBlock = 0, countNA = 0
	// check no numbers duplicated
	if (expected !== results.length) {
		display.push(sb+ "ERROR:"+ sc + " duplicate numbers detected<br>")
	}
	// parse for pretty output
	for (let i=0; i < results.length; i++) {
		let pad = 35
		let order = results[i].split("~~~")[0],
			desc = results[i].split("~~~")[1].trim(),
			result = results[i].split("~~~")[2],
			match = results[i].split("~~~")[3],
			perf = results[i].split("~~~")[4]
		if (perf == undefined || perf == "" || perf == "undefined") {perf = " - "
		} else if (perf !== "NaN") {
			perf = Math.round(perf)
			perf = perf.toString()
			perf = perf.padStart(2) +" "
		}

		if (desc == "header") {
			let note = ""
			if (result == "errors") {
				note = " [there are thousands of these]"
			}
			result = s14 + result.toUpperCase() + sc + note
			display.push("<span>"+ result + "</span><br>")
		} else if (desc == "hr") {
			display.push("<br><hr>")
		} else {
			if (match == zErr) {match = yellow_block; countBlock++
			} else if (match == "true") {match = green_tick; countTrue++
			} else if (match == "false") {match = red_cross; countFalse++
			} else {match = white_na; countNA++}
			match += " "
			if (desc == "error") {
				pad = 3; errcount++; desc = errcount.toString()
			}
			desc = s3 + desc.padStart(pad) + sc
			let sectionspace = ""
			if (i+1 < results.length) {
				let nextitem = results[i+1].split("~~~")[1].trim()
				if (nextitem == "header") {sectionspace = "<br>"}
			}
			desc += s99 +" "+ (bNum ? order : perf) + sc
			display.push(desc + match +" "+ result + sectionspace)
		}
	}
	// summary
	let countValid = countTrue + countFalse + countBlock // na tests ignored
	let countFail = countFalse + countBlock
	let percentPassed = Math.floor((countTrue/countValid)*100)
	let isPass = percentPassed == 100 ? true : false
	let percentFailed = Math.ceil((countFail/countValid)*100)
	let summary = ""
	if (isFFvalid) {
		let needStr = "... who needs "+ s3+ (expected - 5) + " tests" + sc
			+ " and "+ s3 + "several hundred metrics" + sc
			+ (canPerf ? " in "+ s3 + perfValue + sc : "") + "?"
		summary += s14 +"MINI TESTS "+ sc + needStr +"<br><br>"
			+ "engine: "+ isEnginePretty.trim() +"<br><br>"
			+ " gecko: "+ isFFpretty.trim() +"<br><br><hr><br>"
	}
	summary += s14 +"SUMMARY "+ sc
		+"PASS: ".padStart(7) + countTrue + (isPass? sg : sb) +" ["+ percentPassed +"%]"+ sc
		+"FAIL: ".padStart(7) + countFail + (isPass? sg : sb) +" ["+ percentFailed +"%]"+ sc
	if (countNA > 0) {summary += "N/A: ".padStart(6) + countNA}
	if (isFF) {
		summary += s14+ "DEBUG".padStart(7) + sc +"RFP:".padStart(6) + (isRFP ? green_tick : red_cross)
		let strVer = isVer
		strVer += (isVer == isVerMax ? "+" : "")
		strVer += (isVer == 52 ? " or lower" : "")
		summary += "VER: ".padStart(6) + strVer
	}
	summary += " " + buildButton(3, "all", "all details")
	// output
	dom.results.innerHTML = summary + "<br><br>" + display.join("<br>")
}

function fnRecord(order, description, result, match, error, perf) {
	if (error !== undefined && error !== "skip") {
		let hash = mini(error)
		if (hash !== "d8281b3c") { // assignment to undeclared variable bB
			console.error(order, result, error)
			hash = s3+ " ["+ hash +"]"+ sc
		} else {
			result = "test error thrown"; hash = ""
		}
		result += hash
	}
	aPerf.push([perf, order, description])
	order = (order+"").padStart(3,"0")
	data[order] = description +"~~~"+ result +"~~~"+ match + "~~~" + perf
	count ++
	itemnumbers.push(order +" "+ description)
	if (count == expected) {
		fnDisplay()
	}
	if (count > expected) {console.error(count, "expected count too low")}
}

function get_colorgamut(num, title) {
	let q = "(color-gamut: ", res = "undefined", bolC = false
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		if (window.matchMedia(q +"srgb)").matches) {res = "srgb"}
		if (window.matchMedia(q +"p3)").matches) {res = "p3"}
		if (window.matchMedia(q +"rec2020)").matches) {res = "rec2020"}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, res, res == "undefined", "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_dates(num) {
	// 1274354: meta
	// 1557650
	let strA = "[5 digit year] new Date"
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = new Date("19999-11-11")
		let bolA = resA == "Invalid Date" ? true : false
		if (!bolA) {resA = fnTrim(resA.toString(), 40)}
		let perfA = canPerf ? performance.now() - t0A : ""
		fnRecord(num, strA, resA, bolA, "skip", perfA)
	} catch(e) {
		fnRecord(num, strA, e.name, zErr, e.message)
	}
	// 1515318
	let strB = "[hyphen] new Date"
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = new Date("31-Mar-2011").getFullYear()
		// FF: 63 and lower = NaN, 64+ = -2011
		let bolB = false
		if (resB == -2011) {bolB = true
		} else if (isVer < 64 && isNaN(resB)) {bolB = true}
		let perfB = canPerf ? performance.now() - t0B : ""
		fnRecord(num+1, strB, resB, bolB, "skip", perfB)
	} catch(e) {
		fnRecord(num+1, strB, e.name, zErr, e.message)
	}
	// 1439800
	let strC = "[string] new Data"
	try {
		let t0C; if (canPerf) {t0C = performance.now()}
		if (bBlock) {bB = 1}
		let resC = new Date("11-Nov-11")
		let bolC = resC.toString() == "Invalid Date" ? true : false
		if (!bolC) {resC = fnTrim(resC.toString(), 40)}
		let perfC = canPerf ? performance.now() - t0C : ""
		fnRecord(num+2, strC, resC, bolC, "skip", perfC)
	} catch(e) {
		fnRecord(num+2, strC, e.name, zErr, e.message)
	}
	// 1599375
	let strD = "[+0000 UTC] Date.parse"
	try {
		let t0D; if (canPerf) {t0D = performance.now()}
		if (bBlock) {bB = 1}
		let resD = Date.parse("2019-11-26 07:39:58.286157072 +0000 UTC")
		let bolD = isNaN(resD) ? true : false
		let perfD = canPerf ? performance.now() - t0D : ""
		fnRecord(num+3, strD, resD, bolD, "skip", perfD)
	} catch(e) {
		fnRecord(num+3, strD, e.name, zErr, e.message)
	}
	// 1730155
	let strE = "[localized] Date.parse"
	try {
		let t0E; if (canPerf) {t0E = performance.now()}
		if (bBlock) {bB = 1}
		let resE = Date.parse("Mercredi 8 Septembre 2021")
		let bolE = isNaN(resE) ? true : false
		let perfE = canPerf ? performance.now() - t0E : ""
		fnRecord(num+4, strE, resE, bolE, "skip", perfE)
	} catch(e) {
		fnRecord(num+4, strE, e.name, zErr, e.message)
	}
	// 1783731
	let strF = "[subtraction] Date.parse"
	try {
		let t0F; if (canPerf) {t0F = performance.now()}
		if (bBlock) {bB = 1}
		let resF = Date.parse('2022-08-08') - Date.parse('2022-08-8')
		let bolF = resF == 0
		let perfF = canPerf ? performance.now() - t0F : ""
		fnRecord(num+6, strF, resF, bolF, "skip", perfF)
	} catch(e) {
		fnRecord(num+6, strF, e.name, zErr, e.message)
	}
}

function get_errors(num) {
	let tests = [
		["var a = {}; a.b = a; JSON.stringify(a)", "TypeError: cyclic object value"],
		["alert('A)","SyntaxError: '' string literal contains an unescaped line break"],
		["let a = 1_00_;","SyntaxError: underscore can appear only between digits, not after t...", // FF72+
			"SyntaxError: identifier starts immediately after numeric literal", // FF60-69
			"SyntaxError: missing digit after '_' numeric separator"], // FF70-71
		["const foo;foo.bar","SyntaxError: missing = in const declaration"],
		["null.bar","TypeError: can't access property \"bar\" of null","TypeError: null has no properties"],
		["(1).toString(1000)","RangeError: radix must be an integer at least 2 and no greater than 36"],
		["var x = new Array(-1)","RangeError: invalid array length"],
		["[...undefined].length","TypeError: can't access property Symbol.iterator of undefined","TypeError: undefined has no properties"],
		["const tzp=1; const tzp=2;","SyntaxError: redeclaration of const tzp"],
		["const foo;foo.bar","SyntaxError: missing = in const declaration"],
		["var x = @","SyntaxError: illegal character U+0040","SyntaxError: illegal character"],
	]
	tests.forEach(function(array) {
		let t0; if (canPerf) {t0 = performance.now()}
		try {
			newFn(array[0])
		} catch(e) {
			let bool = false
			let str = fnTrim(e.name +": "+ e.message, 70)
			if (isVer < 60 && array[0] == "alert('A)") {
				if (str == "SyntaxError: unterminated string literal") {bool = true}
			} else {
				if (str == array[1] || str == array[2] || str == array[3]) {bool = true}
			}
			let perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num, "error", str, bool, "skip", perf)
			num++
		}
	})
}

function get_eval_length(num, title) {
	let bool = false
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let test = eval.toString().length
		if (test == 37) {bool = true}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, test, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_iframe_props(num1, num2, title) {
	let t0; if (canPerf) {t0 = performance.now()}
	// just a small sample
	let listE = ['dump','fullScreen','getDefaultComputedStyle','mozInnerScreenX',
		'mozInnerScreenY','netscape','onmozfullscreenchange','onmozfullscreenerror']
	let listU = ['BatteryManager','HID','Keyboard','Lock','Serial',
		'USB','WakeLock','WebKitMutationObserver','XRAnchor','chrome','webkitCancelAnimationFrame',
		'webkitMediaStream','webkitRTCPeerConnection','webkitRequestAnimationFrame',
		'webkitRequestFileSystem','webkitResolveLocalFileSystemURL','webkitStorageInfo']
	// FYI: don't use MIDIAccess: FF60+ behind dom.webmidi.enabled... 1752906: FF99+ default enabled

	if (isVer > 92) {
		// FF93+ "dom.weblocks.enabled"
		// 1739233: FF96+ Lock
		listU = listU.filter(x => !["Lock"].includes(x))
	}
	try {
		if (bBlock) {bB = 1}
		// create & append iframe
		let id = "iframe-window-version"
		let el = document.createElement("iframe")
		el.setAttribute("id", id)
		el.setAttribute('style', 'display: none')
		document.body.appendChild(el)
		// get props
		let iframe = document.getElementById(id)
		let contentWindow = iframe.contentWindow
		let props = Object.getOwnPropertyNames(contentWindow)
		// remove iframe
		iframe.parentNode.removeChild(iframe)
		props.sort()
		// expected
		let arrayE = props.filter(x => listE.includes(x))
		let resE = "", boolE = false
		if (arrayE.length) {
			sDetail["expected_"+ title] = arrayE
			resE = mini_sha1(arrayE.join()) + buildButton(3, "expected_"+ title, arrayE.length)
			if (arrayE.length > 4) {boolE = true}
		} else {
			resE = "none"
		}
		// unexpected
		let arrayU = props.filter(x => listU.includes(x))
		// ignore BatteryManager FF72+
		if (isFF && isVer < 72) {arrayU = arrayU.filter(x => !["BatteryManager"].includes(x))}
		let resU = "", boolU = false
		if (arrayU.length) {
			sDetail["unexpected_"+ title] = arrayU
			resU = mini_sha1(arrayU.join()) + buildButton(3, "unexpected_"+ title, arrayU.length)
		} else {
			resU = "none"
			boolU = true
		}
		let perf = canPerf ? performance.now() - t0 : ""
		// record
		fnRecord(num1, title, resE, boolE, "skip", perf)
		fnRecord(num2, title, resU, boolU, "skip", perf)
	} catch(e) {
		fnRecord(num1, title, e.name, zErr, e.message)
		fnRecord(num2, title, e.name, zErr, e.message)
	}
}

function get_installtrigger(num) {
	// FF100+: 1754441 behind prefs slated for deprecation
	let strA = "[typeof] InstallTrigger", boolA = false
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = typeof InstallTrigger
		if (resA == "object") {boolA = true}
		let perfA = canPerf ? performance.now() - t0A : ""
		if (isVer > 99 && !boolA) {
			fnRecord(num, strA, zNA +": FF99 or lower" + s3 +" ["+ resA +"]"+ sc, zNA, "skip", perfA)
		} else {
			fnRecord(num, strA, resA, boolA, "skip", perfA)
		}
	} catch(e) {
		fnRecord(num, strA, e.name, zErr, e.message)
	}

	let strB = "[window] InstallTrigger", boolB = false
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = "InstallTrigger" in window
		let perfB = canPerf ? performance.now() - t0B : ""
		if (isVer > 99 && !resB) {
			fnRecord(num+1, strB, zNA +": FF99 or lower" + s3 +" ["+ resB +"]"+ sc, zNA, "skip", perfB)
		} else {
			fnRecord(num+1, strB, resB, resB, "skip", perfB)
		}
	} catch(e) {
		fnRecord(num+1, strB, e.name, zErr, e.message)
	}

	let strC = "[typeof] InstallTriggerImpl", boolC = false
	// FF60 or lower
	if (isFF && isVer < 61) {
		fnRecord(num+2, strC, zNA +": FF61+ required", zNA)
	} else {
		try {
			let t0C; if (canPerf) {t0C = performance.now()}
			if (bBlock) {bB = 1}
			let resC = typeof InstallTriggerImpl
			if (resC == "function") {boolC = true}
			let perfC = canPerf ? performance.now() - t0C : ""
			if (isVer > 99 && !boolC) {
				fnRecord(num+2, strC, zNA +": FF99 or lower" + s3 +" ["+ resC +"]"+ sc, zNA, "skip", perfC)
			} else {
				fnRecord(num+2, strC, resC, boolC, "skip", perfC)
			}
		} catch(e) {
			fnRecord(num+2, strC, e.name, zErr, e.message)
		}
	}
}

function get_intl_canonical_locale(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let list = ['bh','hye','no','tl','tw'], bool = false
		let res = []
		list.forEach(function(i) {
			res.push(Intl.getCanonicalLocales(i))
		})
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		if (hash == "49ce6431a6b656b0cdce7fc8bff36cbf60f90558") {bool = true // FF91+
		} else if (hash == "ca3fd91866c1a46b8d08c4c1b406e3201fd7fcd7") {bool = true // FF70-90
		} else if (hash == "68cbf0ea5d3d3a6bc14f0d574341397d818ba886") {bool = true // FF52-69
		}
		// FF60-69 : bh=bh,  hye=hye, no=no, tl=tl,  tw=tw
		// FF70-90 : bh=bho, hye=hy,  no=nb, tl=fil, tw=ak
		// FF91+   : bh=bho, hye=hy,  no=no, tl=fil, tw=ak // webkit now matches
		// blink   : bh=bh,  hye=hy,  no=no, tl=fil, tw=tw
		// webkit  : bh=bh,  hye=hy,  no=no, tl=tl,  tw=tw
		if (res.length > 0) {
			if (res.join(", ").length < 48) {
				hash = res.join(", ")
			} else {
				sDetail["specific_"+ title] = res
				hash += buildButton(3, "specific_"+ title, "details")
			}
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_intl_supportedlocales(num) {
	// DTF, NF, RTF, LF, DN
	/* NOTES
	// FF52+ common items (130) not in blink103 common (59) = 71 items
		// FF52: DTF + NF / FF65: RTF / FF78: LF / FF86: DN
		// remove if present: bh bho, hye hy, no nb, tl fil, tw ak [aliases/maps]
	geckoNotBlink = [
		// mix it up per test
		'eo','gl','ka','mt','om', // used in C
			// from collator list below that is in common with this list
			// ^ note mt only added if .compare works

		'ki','lu','qu','rn','rw', // used in PR (limited choices)
		'as','fo','ln','ne','to', // used in DTF
		'br','eu','ii','ks','ps', // used in DN
		'ee','gd','kk','lo','yi', // used in LF
		'bo','ha','lb','my','sq', // used in NF
		'cy','km','mg','os','sn', // used in RTF
		// 35 spare
		'ast','be','bm','ce','ckb','dsb','dz','ff','fur','fy',
		'ga','gv','haw','hsb','ig','is','kab','kl','kok','kw',
		'ky','lg','mk','mn','nd','nn','or','rm','se','sg','si',
		'so','ti','ug','yo','zu'
	]
	// webkit items not in FF105
		// note: older webkit only: make sure one in each: 'co','cv','oc','nso','tig'
	WKnotGecko = [
		'ba','co','cv','dv','gn','io','iu','nr','nso','nv','ny','oc','ss','st','tig','tn','ts','ve','wa'
	]
	*/
	// COLLATOR
	/*
	geckoNotBlink = [
		'as','az','be','bo','bs','cy','dsb','dz','ee','eo','fo','ga','gl',
		'ha','haw','hsb','ig','is','ka','kk','kl','km','kok','ky','lb',
		'ln','lo','mk','mn','mt','my','ne','nn','om','or','pa','ps','se',
		'si','sq','to','ug','uz','yi','yo','zu'
	]
	webkit = same as gecko 91+
	old_list = [
		'az','cy','dsb','ee','eo','gl','ha','haw','hsb','ig',
		'ka','kk','ln','lo','mt','om','pa','se','sq','to',
	]
	*/
	// PR
	/*
		 FF52+  geckoNotBlink = ['ki','kok','lu','qu','rn','rw']
		FF105-  blinkNotGecko = ['an','dv','io','iu','lij','nr','nso','ny','ss','st','tig','tn','ts','ve','vo','wa']
		FF105- webkitNotGecko = ['ba','co','cv','dv','gn','io','iu','nr','nso','nv','ny','oc','ss','st','tig','tn','ts','ve','wa']
		therefore
		blinkOnly = ['an','lij','vo']
		webkitOnly = ['ba',co','cv',''gn','ny','oc']
		let list = [
			'ki','lu','qu','rn','rw', // gecko: pick 5
			'ba','co','cv','gn','oc', // webkit only: pick 4
			'an','lij','vo', // chrome only: not needed
		]
	*/
	// MAC supportedlocales == FF91+
		// but .compare for mt is not hooked up (the other locales seem to be working)
	let aCollator = []
	let control = (["c","C"]).sort(Intl.Collator("mt").compare)
	if (control.join("") == "Cc") {aCollator = ['mt']} // so while Mac !== Cc then only FF will test and report mt

	let aList = [
		["0bea6b5efcc437aeea70b7f35af0711e6cec9814", 50, ['eo','gl','ka','om'], aCollator, "Collator"],
		["790e3b04199bd0b1b1132eccd6775d8fd22d8ea6", 50, ['as','fo','ln','ne','to'], ['co','nr','st','tig'], "DateTimeFormat"],
		["aef0c6da2478d759e406af5ede5c19b31384b02c", 86, ['br','eu','ii','ks','ps'], ['cv','iu','nv','tn' ], "DisplayNames"],
		["bb051f059f75b8d78c7c0554f7bee9a1bdf04c9f", 78, ['ee','gd','kk','lo','yi'], ['ba','io','oc','ve' ], "ListFormat"],
		["44b2aba18a3f36f76240cb73ad38c8bc3a66c062", 50, ['bo','ha','lb','my','sq'], ['dv','ny','oc','ts' ], "NumberFormat"],
		["8ef0a7f2554f893f131b36f05de01cdf5bb17620", 58, ['ki','lu','qu','rn','rw'], ['ba','co','gn','oc' ], "PluralRules"],
		["d0b4844a8b0561638d4f355bc68aaaf5c1e04149", 65, ['cy','km','mg','os','sn'], ['gn','nso','ss','wa'], "RelativeTimeFormat"],
	]

	num = (num - 5)
	aList.forEach(function(array) {
		num += 5
		let t0; if (canPerf) {t0 = performance.now()}
		let expected = array[0],
			errVer = array[1],
			list = array[2].concat(array[3]).sort(),
			type = array[4],
			res = []
		let title = "Intl."+ type
		try {
			if (bBlock) {bB = 1}
			if (type == "Collator") { res = Intl.Collator.supportedLocalesOf(list)
			} else if (type == "DateTimeFormat") { res = Intl.DateTimeFormat.supportedLocalesOf(list)
			} else if (type == "DisplayNames") { res = Intl.DisplayNames.supportedLocalesOf(list)
			} else if (type == "ListFormat") { res = Intl.ListFormat.supportedLocalesOf(list)
			} else if (type == "NumberFormat") { res = Intl.NumberFormat.supportedLocalesOf(list)
			} else if (type == "PluralRules") { res = Intl.PluralRules.supportedLocalesOf(list)
			} else if (type == "RelativeTimeFormat") { res = Intl.RelativeTimeFormat.supportedLocalesOf(list)
			}
			let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
			//console.log(title, hash)
			let bool = hash == expected
			if (res.length > 0) {
				if (res.join(", ").length < 48) {
					hash = res.join(", ")
				} else {
					sDetail["specific_"+ title] = res
					hash += buildButton(3, "specific_"+ title, res.length)
				}
			}
			let perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num, title, hash, bool, "skip", perf)
		} catch(e) {
			if (isFF) {
				if (isVer >= errVer) {
					fnRecord(num, title, e.name, zErr, e.message)
				} else {
					let msg = e.message
					msg = msg.replace("can't access property \"supportedLocalesOf\", ", "") // trim *error_fix
					if (e.name == "TypeError" && msg == "Intl." + type +" is undefined") {
						fnRecord(num, title, zNA +": FF" + errVer +"+ required", zNA)
					} else {
						fnRecord(num, title, e.name, zErr, e.message)
					}
				}
			} else {
				fnRecord(num, title, zNA +": not supported", zNA)
			}
		}
	})
}

function get_js_client_hints(num, title) {
	// testing: https://web.dev/user-agent-client-hints/
	// https://user-agent-client-hints.glitch.me/javascript.html
	// TypeError can't access property "X", navigator.X is undefined
	function output() {
		let perf = canPerf ? performance.now() - t0 : ""
		if (res.length > 0) {
			res.sort()
			sDetail["unexpected_"+ title] = res
			let hash = mini_sha1(res.join()) + buildButton(3, "unexpected_"+ title , res.length)
			fnRecord(num, title, hash, false, "skip", perf)
		} else {
			fnRecord(num, title, "none", true, "skip", perf)
		}
	}
	let res = []
	let t0; if (canPerf) {t0 = performance.now()}

	try {
		let resB = navigator.userAgentData.brands
		resB.forEach(function(object) {
			let valueB = fnClean(object.version)
			res.push("brands: "+ object.brand +": "+ valueB)
		})
	} catch(e) {}
	try {
		res.push("mobile: " + navigator.userAgentData.mobile)
	} catch(e) {}
	try {
		res.push("platform: " + navigator.userAgentData.platform)
	} catch(e) {}
	try {
		navigator
			.userAgentData.getHighEntropyValues(
				["architecture","bitness","brands","mobile","model","platform","platformVersion","uaFullVersion"]
			).then(ua => {
				const names = Object.keys(ua)
				for (const k of names) {
					let valueU = fnClean(ua[k])
					res.push("high entropy: "+ k +": "+ valueU)
				}
				output()
			})
	} catch(e) {
		output()
	}
}

function get_last_prototype_keys(num1, title) {
	// HTMLAnchorElement
	let title1 = title +" HTMLAnchorElement"
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		Object.keys(HTMLAnchorElement.prototype)
		let props1 = Object.getOwnPropertyNames(HTMLAnchorElement.prototype) // includes the constructor
		let res1 = props1.slice(-3).join(", ")
		// search, hash, constructor
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num1, title1, res1, res1 == "search, hash, constructor", "skip", perf)
	} catch(e) {
		fnRecord(num1, title1, e.name, zErr, e.message)
	}

	// HTMLLinkElement
	let title2 = title +" HTMLLinkElement"
	let num2 = num1 + 1
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		Object.keys(HTMLLinkElement.prototype)
		let props2 = Object.getOwnPropertyNames(HTMLLinkElement.prototype) // includes the constructor
		let res2 = props2.slice(-3).join(", ")
		let bool2 = res2 == "as, sheet, constructor"
		// 52-55: integrity, sheet, constructor
		if (isVer <= 56 && res2 == "integrity, sheet, constructor") {bool2 = true}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num2, title2, res2, bool2, "skip", perf)
	} catch(e) {
		fnRecord(num2, title2, e.name, zErr, e.message)
	}
}

function get_locale_compare(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let list = [
			["cy","n","ng"],
			["gl","\u00F1","ng"],
			["ha","ts","tt"],
			["hsb","\u0107","\u0109"],
			["ig","c","ch"],
			["ka","\u0107","\u10D0"],
			["mt","c","C"], // MAC: Intl.Collator supportedlocale but does not collate it
			["om","ch","\u00ED"],
			["sq","\u00EB","ez"],
			["to","\u00ED","\u00EE"],
		]
		let res = []
		list.forEach(function(item) {
			res.push(item[1].localeCompare(item[2], item[0]))
		})
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		let bool = hash == "d4ed607dd4781454263f3c3fc6d92b55b2980ad2"
		if (res.length > 0) {
			hash = res.join(", ")
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_math(num, title) {
	// polyfill
	function cbrt(x) {
		try {
			let y = Math.pow(Math.abs(x), 1 / 3)
			return x < 0 ? -y : y
		} catch(e) {
			return "error"
		}
	}
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let res = []
		for(let i=0; i < 6; i++) {
			try {
				let fnResult = "unknown"
				if (i == 0) {fnResult = cbrt(Math.PI) // polyfill
				} else if (i == 1) {fnResult = Math.log10(7*Math.LOG10E)
				} else if (i == 2) {fnResult = Math.log10(2*Math.SQRT1_2)
				} else if (i == 3) {fnResult = Math.acos(0.123)
				} else if (i == 4) {fnResult = Math.acosh(Math.SQRT2)
				} else if (i == 5) {fnResult = Math.atan(2)
				}
				res.push(fnResult)
			} catch(e) {
				res.push("error")
			}
		}
		// I have to use sha1 due to legacy data
		let hash = sha1(res.join()).substring(0,20)
		let engine = "unkown"
		if (hash == "ede9ca53efbb1902cc21") {engine = "blink"
		} else if (hash == "05513f36d87dd78af60a") {engine = "webkit"
		} else if (hash == "38172d9426d77af71baa") {engine = "edgeHTML"
		} else if (hash == "36f067c652c8cfd90725") {engine = "trident"
		} else if (hash == "225f4a612fdca4065043") {engine = "gecko"
		} else if (hash == "cb89002a8d6fabf859f6") {engine = "gecko"
		}
		let bool = engine == "gecko" ? true : false
		// now redo as mini_sha1
		sDetail["expected_"+ title] = res
		hash = mini_sha1(res.join()) + buildButton(3, "expected_"+ title, engine)
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_media_constraints(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let noiseFF = [
			'groupId', // FF70+
			'channelCount', // FF56+
			'autoGainControl','noiseSuppression', // FF55+
			'mozAutoGainControl','mozNoiseSuppression', // FF54-
		]
		let data = navigator.mediaDevices.getSupportedConstraints()
		let res = Object.keys(data)
		res = res.filter(x => !noiseFF.includes(x))
		res.sort()
		let hash = res.length > 0 ? mini_sha1(res.join()) : "none"
		let bool = hash == "a4dfaab7d54b96d9a4ed91d06a20b77fa0df2a45" // FF52+
		if (res.length > 0) {
			sDetail["expected_"+ title] = res
			hash += buildButton(3, "expected_"+ title, res.length)
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		// e.g. TB disables mediaDevices
		let error = mini(e.name +": "+ e.message), isNA = false
		if (error == "f2244861") {
			// TypeError: can't access property "getSupportedConstraints", navigator.mediaDevices is undefined
			isNA = true
		} else if (error == "9fc627cf") {
			// TypeError: navigator.mediaDevices is undefined
			isNA = true
		}
		if (isNA) {
			fnRecord(num, title, zNA +": disabled", zNA)
		} else {
			fnRecord(num, title, e.name, zErr, e.message)
		}
	}
}

function get_mimetypes(num, title) {
	try {
		let t0, perf; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		if ("mimeTypes" in navigator) {
			let res = [], bool = false
			let m = navigator.mimeTypes
			if (m.length == 0) {
				perf = canPerf ? performance.now() - t0 : ""
				fnRecord(num, title, "none", true, "skip", perf)
			} else {
				for (let i=0; i < m.length; i++) {
					res.push( m[i].type + (m[i].description == "" ? ": * " : ": "+ m[i].type)
						+ (m[i].suffixes == "" ? ": *" : ": "+ m[i].suffixes) )
				}
				res.sort()
				// FF84 or lower allow just Flash
				if (isFF && isVer < 85 && res.length == 2) {
					let mime1 = res[0].split(":")[0]
					let mime2 = res[1].split(":")[0]
					if (mime1 == "application/x-futuresplash" && mime2 == "application/x-shockwave-flash") {
						bool = true
					}
				}
				let hash = mini_sha1(res.join())
				if (isVer > 98 || !isFF) { // allow non-FF to have the same
					// FF99+: controlled by pdfjs.disabled
					// 1720353: hardcoded mimeTypes
					if (hash == "5b8b5b83ff5790df763d417ec6e2adbbf0570c47") {
						bool = true
					}
				}
				sDetail["expected_"+ title] = res
				hash += buildButton(3, "expected_"+ title, res.length)
				perf = canPerf ? performance.now() - t0 : ""
				fnRecord(num, title, hash, bool, "skip", perf)
			}
		} else {
			fnRecord(num, title, e.name, zErr)
		}
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_moz_colors(num, title) {
	let aList = [
		// css4
		'-moz-activehyperlinktext','-moz-default-color','-moz-default-background-color','-moz-hyperlinktext','-moz-visitedhyperlinktext',
		// stand-ins
		'-moz-buttondefault','-moz-buttonhoverface','-moz-buttonhovertext','-moz-cellhighlight','-moz-cellhighlighttext','-moz-combobox','-moz-comboboxtext','-moz-dialog','-moz-dialogtext','-moz-dragtargetzone','-moz-eventreerow','-moz-field','-moz-fieldtext','-moz-html-cellhighlight','-moz-html-cellhighlighttext','-moz-mac-chrome-active','-moz-mac-chrome-inactive','-moz-mac-disabledtoolbartext','-moz-mac-focusring','-moz-mac-menuselect','-moz-mac-menushadow','-moz-mac-menutextdisable','-moz-mac-menutextselect','-moz-mac-secondaryhighlight','-moz-menubarhovertext','-moz-menubartext','-moz-menuhover','-moz-menuhovertext','-moz-nativehyperlinktext','-moz-oddtreerow','-moz-win-communicationstext','-moz-win-mediatext',
		// moz
		'-moz-accent-color','-moz-accent-color-foreground','-moz-appearance','-moz-colheaderhovertext','-moz-colheadertext','-moz-gtk-buttonactivetext','-moz-gtk-info-bar-text','-moz-mac-accentdarkestshadow','-moz-mac-accentdarkshadow','-moz-mac-accentface','-moz-mac-accentlightesthighlight','-moz-mac-accentlightshadow','-moz-mac-accentregularhighlight','-moz-mac-accentregularshadow','-moz-mac-active-menuitem','-moz-mac-active-source-list-selection','-moz-mac-buttonactivetext','-moz-mac-defaultbuttontext','-moz-mac-menuitem','-moz-mac-menupopup','-moz-mac-source-list','-moz-mac-source-list-selection','-moz-mac-tooltip','-moz-mac-vibrancy-dark','-moz-mac-vibrancy-light','-moz-mac-vibrant-titlebar-dark','-moz-mac-vibrant-titlebar-light','-moz-win-accentcolor','-moz-win-accentcolortext','-moz-win-communications-toolbox','-moz-win-media-toolbox',
	]
	aList.sort()
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let aRes = []
		let element = dom.mozColor
		let strColor = "rgba(1, 2, 3, 0.5)"
		aList.forEach(function(style) {
			element.style.backgroundColor = strColor // always reset
			element.style.backgroundColor = style
			let rgb = window.getComputedStyle(element, null).getPropertyValue("background-color")
			if (rgb !== strColor) {
				aRes.push(style +":"+ rgb) // only record those affected
			}
		})
		let bool = aRes.length > 0
		if (bool) {
			sDetail["expected_"+ title] = aRes
		}
		let hash = bool ? mini_sha1(aRes.join()) + buildButton(3, "expected_"+ title, aRes.length) : "none"
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_moz_fonts(num, title) {
	let aResults = [],
		m = "-moz-",
		aFonts = [m+"window",m+"desktop",m+"document",m+"workspace",m+"info",m+"pull-down-menu",m+"dialog",m+"button",m+"list",m+"field"]
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		let el = dom.mozFont
		if (bBlock) {bB = 1}
		aFonts.forEach(function(font){
			// catch blocked
			let test = getComputedStyle(el).getPropertyValue("font-family")
			el.style.font = "99px sans-serif"
			try {el.style.font = font} catch(err) {}
			let s = ""
			if (window.getComputedStyle) {
				try {
					s = getComputedStyle(el, null)
				} catch(e) {}
			}
			if (s !== "") {
				let f = s.fontSize != "99px" ? s.fontFamily : undefined
				if (f !== undefined) {aResults.push(f)}
			}
		})
		let bool = aResults.length > 0
		if (bool) {
			sDetail["expected_"+ title] = aResults
		}
		let hash = bool ? mini_sha1(aResults.join()) + buildButton(3, "expected_"+ title, aResults.length) : "none"
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_moz_objects(num, name) {
	let title = "["+ name +"] moz"
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let res = []
		let oList = {}
		let isObj = false
		let useHas = false // use hasOwnProperty or default getOwnPropertyDescriptor

		if (name === "Document" && "function" === typeof Document) {
			oList[name] = [Document.prototype,
				["mozSetImageElement","mozCancelFullScreen","mozFullScreen","mozFullScreenEnabled",
					"mozFullScreenElement","onmozfullscreenchange","onmozfullscreenerror"]
				]
		}
		if (name === "HTMLElement" && "function" === typeof HTMLElement) {
			oList[name] = [HTMLElement.prototype, ["onmozfullscreenchange","onmozfullscreenerror"]]
		}
		if (name === "HTMLMediaElement" && "function" === typeof HTMLMediaElement) {
			oList[name] = [HTMLMediaElement.prototype, ["mozCaptureStream","mozCaptureStreamUntilEnded",
				"mozGetMetadata","mozPreservesPitch","mozAudioCaptured","mozFragmentEnd"]
			]
		}
		if (name === "HTMLVideoElement" && "function" === typeof HTMLVideoElement) {
			oList[name] = [HTMLVideoElement.prototype, ["mozParsedFrames","mozDecodedFrames",
				"mozPresentedFrames","mozPaintedFrames","mozFrameDelay","mozHasAudio"]
			]
		}
		if (name === "MouseEvent" && "function" === typeof MouseEvent) {
			oList[name] = [MouseEvent.prototype,
				["MOZ_SOURCE_UNKNOWN","MOZ_SOURCE_MOUSE","MOZ_SOURCE_PEN","MOZ_SOURCE_ERASER",
				"MOZ_SOURCE_CURSOR","MOZ_SOURCE_TOUCH","MOZ_SOURCE_KEYBOARD","mozPressure",
				"mozInputSource","MOZ_SOURCE_UNKNOWN","MOZ_SOURCE_MOUSE","MOZ_SOURCE_PEN",
				"MOZ_SOURCE_ERASER","MOZ_SOURCE_CURSOR","MOZ_SOURCE_TOUCH","MOZ_SOURCE_KEYBOARD"]
			]
		}
		if (name === "Screen" && "function" === typeof Screen) {
			oList[name] = [Screen.prototype,
				["mozLockOrientation","mozUnlockOrientation","mozOrientation","onmozorientationchange"]
			]
		}
		if (name === "SVGElement" && "function" === typeof SVGElement) {
			oList[name] = [SVGElement.prototype,["onmozfullscreenchange","onmozfullscreenerror"]]
		}
		if (name === "HTMLInputElement" && "function" === typeof HTMLInputElement) {
			oList[name] = [HTMLInputElement.prototype,["mozIsTextField"]]
		}
		if (name === "Navigator" && "function" === typeof Navigator) {
			oList[name] = [Navigator.prototype,["mozGetUserMedia"]]
		}
		if (name === "HTMLCanvasElement" && "function" === typeof HTMLCanvasElement) {
			oList[name] = [HTMLCanvasElement.prototype,["mozOpaque","mozPrintCallback"]]
		}
		if (name === "CanvasRenderingContext2D" && "function" === typeof CanvasRenderingContext2D) {
			oList[name] = [CanvasRenderingContext2D.prototype,
				["mozCurrentTransform","mozCurrentTransformInverse","mozTextStyle","mozImageSmoothingEnabled"]
			]
		}
		if (name === "MathMLElement" && "function" === typeof MathMLElement) {
			oList[name] = [MathMLElement.prototype,["onmozfullscreenchange","onmozfullscreenerror"]]
		}
		if (name === "DataTransfer" && "function" === typeof DataTransfer) {
			oList[name] = [DataTransfer.prototype,["mozCursor","mozUserCancelled","mozSourceNode"]]
		}
		if (name === "ShadowRoot" && "function" === typeof ShadowRoot) {
			oList[name] = [ShadowRoot.prototype,["mozFullScreenElement"]]
		}
		if (name === "XMLHttpRequest" && "function" === typeof XMLHttpRequest) {
			oList[name] = [XMLHttpRequest.prototype,["mozAnon","mozSystem"]]
		}
		if (name === "IDBObjectStore" && "function" === typeof IDBObjectStore) {
			oList[name] = [IDBObjectStore.prototype,["mozGetAll"]]
		}
		if (name === "IDBIndex" && "function" === typeof IDBIndex) {
			oList[name] = [IDBIndex.prototype,["mozGetAll","mozGetAllKeys"]]
		}
		if (name === "OfflineResourceList" && "function" === typeof OfflineResourceList) {
			oList[name] = [OfflineResourceList.prototype,
				["mozHasItem","mozItem","mozAdd","mozRemove","mozItems","mozLength"]
			]
		}
		if (name === "Element" && "function" === typeof Element) {
			useHas = true
			oList[name] = [Element.prototype,["mozMatchesSelector","​mozRequestFullScreen"]]
		}
		if (name === "CSS2Properties" && "function" === typeof CSS2Properties) {
			oList[name] = [CSS2Properties.prototype,
				['MozAnimation','MozAnimationDelay','MozAnimationDirection','MozAnimationDuration','MozAnimationFillMode',
				'MozAnimationIterationCount','MozAnimationName','MozAnimationPlayState','MozAnimationTimingFunction',
				'MozAppearance','MozBackfaceVisibility','MozBorderEnd','MozBorderEndColor','MozBorderEndStyle',
				'MozBorderEndWidth','MozBorderImage','MozBorderStart','MozBorderStartColor','MozBorderStartStyle',
				'MozBorderStartWidth','MozBoxAlign','MozBoxDirection','MozBoxFlex','MozBoxOrdinalGroup','MozBoxOrient',
				'MozBoxPack','MozBoxSizing','MozFloatEdge','MozFontFeatureSettings','MozFontLanguageOverride',
				'MozForceBrokenImageIcon','MozHyphens','MozImageRegion','MozMarginEnd','MozMarginStart','MozOrient',
				'MozPaddingEnd','MozPaddingStart','MozPerspective','MozPerspectiveOrigin','MozTabSize','MozTextSizeAdjust',
				'MozTransform','MozTransformOrigin','MozTransformStyle','MozTransition','MozTransitionDelay',
				'MozTransitionDuration','MozTransitionProperty','MozTransitionTimingFunction','MozUserFocus','MozUserInput',
				'MozUserModify','MozUserSelect','MozWindowDragging',
				// aliases
				'-moz-animation','-moz-animation-delay','-moz-animation-direction','-moz-animation-duration',
				'-moz-animation-fill-mode','-moz-animation-iteration-count','-moz-animation-name','-moz-animation-play-state',
				'-moz-animation-timing-function','-moz-appearance','-moz-backface-visibility','-moz-border-end',
				'-moz-border-end-color','-moz-border-end-style','-moz-border-end-width','-moz-border-image','-moz-border-start',
				'-moz-border-start-color','-moz-border-start-style','-moz-border-start-width','-moz-box-align',
				'-moz-box-direction','-moz-box-flex','-moz-box-ordinal-group','-moz-box-orient','-moz-box-pack',
				'-moz-box-sizing','-moz-float-edge','-moz-font-feature-settings','-moz-font-language-override',
				'-moz-force-broken-image-icon','-moz-hyphens','-moz-image-region','-moz-margin-end','-moz-margin-start',
				'-moz-orient','-moz-padding-end','-moz-padding-start','-moz-perspective','-moz-perspective-origin',
				'-moz-tab-size','-moz-text-size-adjust','-moz-transform','-moz-transform-origin','-moz-transform-style',
				'-moz-transition','-moz-transition-delay','-moz-transition-duration','-moz-transition-property',
				'-moz-transition-timing-function','-moz-user-focus','-moz-user-input','-moz-user-modify','-moz-user-select',
				'-moz-window-dragging',
				]
			]
		}
		// object: don't use, we can do this elsewhere
		if (name === "window" && "object" == typeof window) {
			isObj = true
			oList[name] = [window,["mozRTCPeerConnection","CSSMozDocumentRule"]]
		}

		// do it!
		if (oList[name] !== undefined) {
			let obj = oList[name][0]
			let props = oList[name][1]
			if (isObj) {
				props.forEach(function(element) {
					if (element in obj) {res.push(element)}
				})
			} else if (useHas) {
				props.forEach(function(element) {
					if (obj.hasOwnProperty(element)) {res.push(element)}
				})
			} else {
				props.forEach(function(element) {
					if ("object" === typeof Object.getOwnPropertyDescriptor(obj, element)) {
						res.push(element)
					}
				})
			}
			res.sort()
		}
		let hash = "none", bool = false
		if (res.length > 0) {
			if (res.join(", ").length < 48) {
				hash = res.join(", ")
			} else {
				sDetail["expected_"+ title] = res
				hash = mini_sha1(res.join()) + buildButton(3, "expected_"+ title, res.length)
			}
			bool = true
		} else if (isFF) {
			// FF none exceptions
			if (isVer < 63 && name === "ShadowRoot") {bool = zNA, hash = zNA +": FF63+ required"}
			if (isVer < 71 && name === "MathMLElement") {bool = zNA, hash = zNA +": FF71+ required"}
			if (name === "OfflineResourceList") {bool = zNA, hash = zNA +": assuming Beta/Dev/Nightly pref"}
			if (name === "Navigator") {
				// TB/PM build without WebRTC
				if (isEngine == "goanna" || isTB) {
					bool = zNA
					hash = zNA +": "+ (isTB ? "Tor Browser" : "Palemoon")
				} else if (isFF) {
					// behind prefs: both media.peerconnection.enabled + media.navigator.enabled
					bool = zNA
					hash = zNA + s3 +" ["+ hash +"]"+ sc + sb +" [not firefox default]"+ sc
				}
			}
		}
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, hash, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_nav_keys(num1, num2, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let aNavKeys = Object.keys(Object.getOwnPropertyDescriptors(Navigator.prototype))
		// expected FF only
		let aExpected = ["buildID","oscpu","taintEnabled"]
		let resE = aNavKeys.filter(x => aExpected.includes(x))
		let boolE = resE.length == 3 ? true : false
		resE = resE.length > 0 ? resE.join(", ") : "none"
		let perfE = canPerf ? performance.now() - t0 : ""
		fnRecord(num1, title, resE, boolE, "skip", perfE)

		// not expected: blink items
		let aNot = ["canShare","clearAppBadge","deviceMemory","getBattery","getInstalledRelatedApps",
			"getUserMedia","globalPrivacyControl","hid","keyboard","locks","managed","presentation","scheduling",
			"serial","setAppBadge","unregisterProtocolHandler","usb","userActivation","userAgentData","wakeLock",
			"webkitGetUserMedia","webkitPersistentStorage","webkitTemporaryStorage","xr","SharedWorker","Worker"]
		// FYI: don't use requestMIDIAccess: FF60+ behind dom.webmidi.enabled... 1752906: FF99+ default enabled
		if (isVer > 95) {
			// 1666203: FF96+ canShare
			aNot = aNot.filter(x => !["canShare"].includes(x))
		}
		if (isVer > 94 || isEngine == "goanna") {
			// 1670058: FF95+ globalPrivacyControl
			// PM 30
			aNot = aNot.filter(x => !["globalPrivacyControl"].includes(x))
		}
		if (isVer > 92) {
			// FF93+ "dom.weblocks.enabled"
			// 1739233: FF96+ locks
			aNot = aNot.filter(x => !["locks"].includes(x))
		}
		let resN = aNavKeys.filter(x => aNot.includes(x))
		let boolN = resN.length == 0
		if (resN.length > 0) {
			sDetail["unexpected_"+ title] = resN
			resN = mini_sha1(resN.join()) + buildButton(3, "unexpected_"+ title, resN.length)
		} else {
			resN = "none"
		}
		let perfN = canPerf ? performance.now() - t0 : ""
		fnRecord(num2, title, resN, boolN, "skip", perfN)
	} catch(e) {
		fnRecord(num1, title, e.name, zErr, e.message)
		fnRecord(num2, title, e.name, zErr, e.message)
	}
}

function get_nav_screen(num) {
	let strA = "[left] screen", boolA = false
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = screen.left
		if (!isNaN(resA)) {boolA = true} else {resA = fnClean(resA)}
		let perfA = canPerf ? performance.now() - t0A : ""
		fnRecord(num, strA, resA, boolA, "skip", perfA)
	} catch(e) {
		fnRecord(num, strA, e.name, zErr, e.message)
	}
	let strB = "[top] screen", boolB = false
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = screen.top
		if (!isNaN(resB)) {boolB = true} else {resB = fnClean(resB)}
		let perfB = canPerf ? performance.now() - t0B : ""
		fnRecord(num+1, strB, resB, boolB, "skip", perfB)
	} catch(e) {
		fnRecord(num+1, strB, e.name, zErr, e.message)
	}
}

function get_nav_values(num1, num2, num3) {
	// expected
	let strA = "[oscpu] navigator", boolA = false
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = navigator.oscpu
		if (typeof resA !== "string") {
			//console.debug(typeof resA)
		} else {
			if (resA == "") {resA = "empty string"
			} else if (resA == undefined) {resA = zU
			} else if (resA == zU) {resA = zUQ
			} else {boolA = true}
		}
		let perfA = canPerf ? performance.now() - t0A : ""
		fnRecord(num1, strA, resA, boolA, "skip", perfA)
	} catch(e) {
		fnRecord(num1, strA, e.name, zErr, e.message)
	}

	// not expected
	// bluetooth
	let strBT = "[bluetooth] navigator", boolBT = false, numBT = num2
	try {
		let t0BT; if (canPerf) {t0BT = performance.now()}
		if (bBlock) {bB = 1}
		let resBT = navigator.bluetooth
		if (resBT === undefined) {
			let perfBT = canPerf ? performance.now() - t0BT : ""
			fnRecord(numBT, strBT, zU, true, "skip", perfBT)
		} else {
			try {
				navigator.bluetooth.getAvailability().then(available => {
					if (available) {
						fnRecord(numBT, strBT, "supported", boolBT)
					} else {
						fnRecord(numBT, strBT, "not supported", boolBT)
					}
				})
			} catch(e) {
				fnRecord(numBT, strBT, e.name, zErr)
			}
		}
	} catch(e) {
		fnRecord(numBT, strBT, e.name, zErr, e.message)
	}
	// deviceMemory
	let strDM = "[deviceMemory] navigator", boolDM = false, numDM = num2+2
	try {
		let t0DM; if (canPerf) {t0DM = performance.now()}
		if (bBlock) {bB = 1}
		let resDM = navigator.deviceMemory
		if (resDM == undefined) {boolDM = true}
		resDM = fnClean(resDM)
		let perfDM = canPerf ? performance.now() - t0DM : ""
		fnRecord(numDM, strDM, resDM, boolDM, "skip", perfDM)
	} catch(e) {
		fnRecord(numDM, strDM, e.name, zErr, e.message)
	}

	// globalprivacycontrol
	let strG = "[gpc] navigator", boolG = false, numG = num2+6
	try {
		let t0G; if (canPerf) {t0G = performance.now()}
		if (bBlock) {bB = 1}
		let resG = navigator.globalPrivacyControl
		resG = fnClean(resG)
		if (resG == "undefined") {boolG = true
		} else if (isEngine == "goanna" && resG == "empty string") {boolG = true; resG += s3 + " [goanna]"+ sc}

		// 1670058: FF95+ globalPrivacyControl
		if (isVer > 94) {
			resG = zNA +": FF94 or lower" + s3 +" ["+ resG +"]" + sc
			boolG = zNA
		}
		let perfG = canPerf ? performance.now() - t0G : ""
		fnRecord(numG, strG, resG, boolG, "skip", perfG)
	} catch(e) {
		fnRecord(numG, strG, e.name, zErr, e.message)
	}

	// keyboard
	let strK = "[keyboard] navigator", numK = num2+8
	let t0K, perfK; if (canPerf) {t0K = performance.now()}
	try {
		if (bBlock) {bB = 1}
		let resK = navigator.keyboard
		if (resK == undefined) {
			perfK = canPerf ? performance.now() - t0K : ""
			fnRecord(numK, strK, "undefined", true, "skip", perfK)
		} else {
			let keys = []
			// https://wicg.github.io/keyboard-map/
			// https://www.w3.org/TR/uievents-code/#key-alphanumeric-writing-system
			let listK = ['Backquote','Backslash','Backspace','BracketLeft','BracketRight','Comma',
				'Digit0','Digit1','Digit2','Digit3','Digit4','Digit5','Digit6','Digit7','Digit8','Digit9',
				'Equal','IntlBackslash','IntlRo','IntlYen','KeyA','KeyB','KeyC','KeyD','KeyE','KeyF','KeyG',
				'KeyH','KeyI','KeyJ','KeyK','KeyL','KeyM','KeyN','KeyO','KeyP','KeyQ','KeyR','KeyS','KeyT',
				'KeyU','KeyV','KeyW','KeyX','KeyY','KeyZ','Minus','Period','Quote','Semicolon','Slash']
			resK.getLayoutMap().then(keyboardLayoutMap => {
				listK.forEach(function(key) {
					try {keys.push(key +": "+ keyboardLayoutMap.get(key))} catch(e) {keys.push(key +": e.name")}
				})
				sDetail["unexpected_"+ strK] = keys
				let hash = mini_sha1(keys.join()) + buildButton(3, "unexpected_"+ strK , keys.length)
				perfK = canPerf ? performance.now() - t0K : ""
				fnRecord(numK, strK, hash, false, "skip", perfK)
			})
		}
	} catch(e) {
		fnRecord(numK, strK, e.name, zErr, e.message)
	}

	// vendor
	let strV = "[vendor] navigator", boolV = false, numV = num2+10
	try {
		let t0V; if (canPerf) {t0V = performance.now()}
		if (bBlock) {bB = 1}
		let resV = navigator.vendor
		if (resV == "") {boolV = true}
		resV = fnClean(resV)
		let perfV = canPerf ? performance.now() - t0V : ""
		fnRecord(numV, strV, resV, boolV, "skip", perfV)
	} catch(e) {
		fnRecord(numV, strV, e.name, zErr, e.message)
	}

	// specific
	let strX = "[buildID] navigator", boolX = false
	try {
		let t0X; if (canPerf) {t0X = performance.now()}
		if (bBlock) {bB = 1}
		let resX = navigator.buildID
		if (isVer > 63) {
			// all FF64+
			if (resX == "20181001000000") {boolX = true}
		} else {
			resX = fnClean(resX)
			// FF52-63: 14 digit number starting with 2017
			let year = resX.slice(0,4) *1
			if (resX.length == 14) {
				let isCheck = false
				if (year > 2016 && year < 2020) {isCheck = true}
				if (isVer == 52) {if (year > 2016) {isCheck = true}} // FF52 waterfox basilisk palemoon
				if (isCheck) {
					if (!isNaN(resX * 1)) {boolX = true}
				}
			} else if (isRFP) {
				// luckily RFP only alters buildID starting FF56
				// RFP FF56-63 = 20100101
				if (resX == "20100101") {boolX = true}
			}
		}
		let perfX = canPerf ? performance.now() - t0X : ""
		fnRecord(num3, strX, resX, boolX, "skip", perfX)
	} catch(e) {
		fnRecord(num3, strX, e.name, zErr, e.message)
	}
	// DNT: FF: 1, unspecified
	let strDNT = "[doNotTrack] navigator", boolDNT = false, numDNT = num3+2
	let t0DNT; if (canPerf) {t0DNT = performance.now()}
	try {
		if (bBlock) {bB = 1}
		let testDNT = navigator.doNotTrack
		if (testDNT == 1 || testDNT == "unspecified") {
			boolDNT = true
		} else {
			testDNT = fnClean(testDNT)
		}
		let perfDNT = canPerf ? performance.now() - t0DNT : ""
		if (isFF && !boolDNT) {
			// PM not supported: returns undefined
			if (isEngine == "goanna" && testDNT == "undefined") {
				fnRecord(numDNT, strDNT, testDNT, true, "skip", perfDNT)
			} else {
				fnRecord(numDNT, strDNT, testDNT, zErr, "skip", perfDNT)
			}
		} else {
			fnRecord(numDNT, strDNT, testDNT, boolDNT, "skip", perfDNT)
		}
	} catch(e) {
		fnRecord(numDNT, strDNT, e.name, zErr, e.message)
	}

	let strY = "[productSub] navigator", boolY = false, numY = num3+4
	try {
		let t0Y; if (canPerf) {t0Y = performance.now()}
		if (bBlock) {bB = 1}
		let resY = navigator.productSub
		if (resY == "20100101") {boolY = true} else {resY = fnClean(resY)}
		let perfY = canPerf ? performance.now() - t0Y : ""
		fnRecord(numY, strY, resY, boolY, "skip", perfY)
	} catch(e) {
		fnRecord(numY, strY, e.name, zErr, e.message)
	}

	// not expected
	// getbattery
	let strB = "[getBattery] navigator", boolB = false, numB = num2+4
	let resB = []
	let t0B, perfB; if (canPerf) {t0B = performance.now()}
	try {
		if (bBlock) {bB = 1}
		// not going to add eventlisteners
		navigator.getBattery().then(function(battery) {
			try {resB.push(battery.level * 100 + "%")} catch(e) {resB.push("error")}
			try {resB.push((battery.charging ? "": "not ") +"charging")} catch(e) {resB.push("error")}
			try {resB.push(battery.chargingTime)} catch(e) {resB.push("error")}
			try {resB.push(battery.dischargingTime)} catch(e) {resB.push("error")}
			perfB = canPerf ? performance.now() - t0B : ""
			fnRecord(numB, strB, resB.join(", "), false, "skip", perfB)
		})
	} catch(e) {
		if (e.name == "TypeError" && e.message.substring(0,38) == "navigator.getBattery is not a function") {
			if (e.message == "navigator.getBattery is not a function") {boolB = true} // webkit wil be false
			perfB = canPerf ? performance.now() - t0B : ""
			fnRecord(numB, strB, e.name, boolB, e.message, perfB)
		} else {
			fnRecord(numB, strB, e.name, zErr, e.message)
		}
	}

}

function get_obj_enumeration(num, title) {
	// 1762188
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let t = ['a','b'], result = []
		for (let i in t) {
			for (let j in t) {
				result.push([i, j, t[i], t[j]])
				let v = t[i]
				delete t[i]
				t[i] = v
			}
		}
		let res = result.join(",") // nonFF = 0,0,a,a,0,1,a,b,1,0,b,a,1,1,b,b
		let bool = res == "0,0,a,a,0,1,a,b,1,0,b,a" ? true : false
		let perf = canPerf ? performance.now() - t0 : ""
		fnRecord(num, title, res, bool, "skip", perf)
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_permission(num, title) {
	try {
		let t0; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		let userVis = "userVisibleOnly"
		navigator.permissions.query({name:"push"}).then(function(result) {
			let res = result.state
			let bool = (res == "prompt" || res == "denied" || res == "granted") ? true : false
			let perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num, title, res, bool, "skip", perf)
		}).catch(error => {
			let perfErr = canPerf ? performance.now() - t0 : ""
			if ((error.message).includes(userVis)) {
				fnRecord(num, title, userVis, false, "skip", perfErr)
			} else {
				fnRecord(num, title, error.name, zErr, error.message)
			}
		})
	} catch(e) {
		// not supported in webkit: https://caniuse.com/?search=push%20permission
		if (isEngine == "webkit") {
			fnRecord(num, title, "not supported", false)
		} else {
			fnRecord(num, title, e.name, zErr, e.message)
		}
	}
}

function get_plugins(num, title) {
	try {
		let t0, perf; if (canPerf) {t0 = performance.now()}
		if (bBlock) {bB = 1}
		if ("plugins" in navigator) {
			let res = [], bool = false
			let p = navigator.plugins
			if (p.length == 0) {
				perf = canPerf ? performance.now() - t0 : ""
				fnRecord(num, title, "none", true, "skip", perf)
			} else {
				for (let i=0; i < p.length; i++) {
					res.push(p[i].name + (p[i].filename == "" ? ": * " : ": "+ p[i].filename)
						+ (p[i].description == "" ? ": *" : ": "+ p[i].description))
				}
				res.sort()
				// FF84 or lower allow just Flash
				if (isFF && isVer < 85 && res.length == 1) {
					if (res[0].split(":")[0] == "Shockwave Flash") {bool = true}
				}
				let hash = mini_sha1(res.join())
				if (isVer > 98 || !isFF) { // allow non-FF to have the same
					// FF99+: controlled by pdfjs.disabled
					// 1720353: hardcoded mimeTypes
					if (hash == "6232b915d6de71c787a36eb42b75d2b8e24aa4d3") {
						bool = true
					}
				}
				sDetail["expected_"+ title] = res
				hash += buildButton(3, "expected_"+ title, res.length)
				perf = canPerf ? performance.now() - t0 : ""
				fnRecord(num, title, hash, bool, "skip", perf)
			}
		} else {
			fnRecord(num, title, e.name, zErr)
		}
	} catch(e) {
		fnRecord(num, title, e.name, zErr, e.message)
	}
}

function get_stacklength(num1, num2, num3) {
	let t0; if (canPerf) {t0 = performance.now()}
	let level = 0, test1 = 0
	function recurse() {
		level++
		recurse()
	}
	try {
		recurse()
	} catch(e) {
		test1 = level
	}
	level = 0
	try {
		recurse()
	} catch(e) {
		// timing an error property lookup is not the same as generating a alow recurse one
		let t0E; if (canPerf) {t0E = performance.now()}
		// columnNumber
		let strCN = "[columnNumber] error", errCN = false
		try {
			if (bBlock) {bB = 1}
			let resCN = e.columnNumber
			let testCN = resCN == undefined? false : true
			let perfCN = canPerf ? performance.now() - t0E : ""
			fnRecord(num1, strCN, resCN, testCN, "skip", perfCN)
		} catch(n) {
			fnRecord(num1, strCN, n.name, zErr, n.message)
		}
		// fileName
		let strFN = "[fileName] error", errFN = false
		try {
			if (bBlock) {bB = 1}
			let resFN = e.fileName
			if (resFN !== undefined) {resFN = resFN.slice(0,8) + "..."}
			let testFN = resFN == undefined? false : true
			let perfFN = canPerf ? performance.now() - t0E : ""
			fnRecord(num1+1, strFN, resFN, testFN, "skip", perfFN)
		} catch(n) {
			fnRecord(num1+1, strFN, n.name, zErr, n.message)
		}
		// lineNumber
		let strLN = "[lineNumber] error", errLN = false
		try {
			if (bBlock) {bB = 1}
			let resLN = e.lineNumber
			let testLN = resLN == undefined? false : true
			let perfLN = canPerf ? performance.now() - t0E : ""
			fnRecord(num1+2, strLN, resLN, testLN, "skip", perfLN)
		} catch(n) {
			fnRecord(num1+2, strLN, n.name, zErr, n.message)
		}

		// first error
		let perf = canPerf ? performance.now() - t0 : ""
		let strRE = "error", resRE = e.name +": "+ e.message
		if (resRE == "InternalError: too much recursion") {
			fnRecord(num3, strRE, resRE, true, "skip", perf)
		} else {
			fnRecord(num3, strRE, resRE, false, "skip", perf)
		}
		// stack length
		let strSL = "stack length"
		try {
			if (bBlock) {bB = 1}
			let resSL = e.stack.toString().length
			let testSL = resSL == 8192 ? true : false
			if (isFile) {
				testSL = zNA
				resSL = zNA +": file://"
			}
			fnRecord(num2, strSL, resSL, testSL, "skip", perf)
		} catch(n) {
			fnRecord(num2, strSL, n.name, zErr, n.message, perf)
		}
	}
}

function get_storage_estimate(num, title) {

	// Notes: Win10 VM is  52gb / 33gb spare | FF is always the same in PB mode
		//   2147483648 : FF57-96 Windows / Android / Win 10 VM FF60-96
	/*
	FF97+ is not stable enough: see https://bugzilla.mozilla.org/show_bug.cgi?id=1735713
   10737418240 : Windows, vannTenn's + bashonly's Linux, Android Fabrizio 100gb spare from 128gb
    5641604300 : Android Fabrizio 49gb spare from 64gb
    5512729395 : Android Thorin 44gb spare from 64gb
    5301081292 : Android bashonly 40gb spare from 64gb
    5256596684 : Win 10 VM 33gb spare from 52gb
    2934867968 : Debian XCFE 2glops 650gb spare from 1TB
    1521166745 : Ubuntu VM Fabrizio with 15GB of storage
    1177328025 : Android aleyvo 1.5gb spare from 16gb
	*/

	// other: who cares if they match
		// brave:     2147483648 (same in incognito and Tor window)
		// opera:      310418104 normal
		// opera:      521917312 private
		// chrome: 1200238045593 normal
		// chrome:   33076376370 normal android
		// chrome:     485041940 incognito
		// chrome:     204974075 incognito android

	// ToDo: check if FF97+ new storage quota is based on disk or free disk space size
	let t0; if (canPerf) {t0 = performance.now()}
	try {
		if (bBlock) {bB = 1}
		navigator.storage.estimate().then(estimate => {
			let quota = estimate.quota,
				bool = false
			if (isVer > 96) {
				bool = zNA
				quota = zNA +": variable in FF97+ "+ s3 +"["+ quota +"]"+ sc
			} else {
				if (quota > 2147000000 && quota < 2148000000) {bool = true}
			}
			let perf = canPerf ? performance.now() - t0 : ""
			fnRecord(num, title, quota, bool, "skip", perf)
		})
	} catch(e) {
		if (isEngine == "webkit") {
			fnRecord(num, title, e.name, false, e.message) // not supported in webkit
		} else {
			// FF56 or lower
			let result = e.name
			let type = zErr
			let error = e.message
			if (isFF && isVer < 57 && e.message == "navigator.storage is undefined") {
				result = zNA +": FF57+ required"
				type = zNA
				error = undefined
			}
			fnRecord(num, title, result, type, error)
		}
	}
}

function get_window_moz(num) {

	let strC = "[CSSMozDocumentRule] window"
	try {
		let t0C; if (canPerf) {t0C = performance.now()}
		if (bBlock) {bB = 1}
		let resC = typeof CSSMozDocumentRule
		let boolC = "function" === typeof CSSMozDocumentRule // FF53+
		if (!boolC && isVer == 52) {
			boolC = "object" === resC
		}
		let perfC = canPerf ? performance.now() - t0C : ""
		fnRecord(num, strC, resC, boolC, "skip", perfC)
	} catch(e) {
		fnRecord(num, strC, e.name, zErr, e.message)
	}

	let strM = "[mozRTCPeerConnection] window"
	try {
		let t0M; if (canPerf) {t0M = performance.now()}
		if (bBlock) {bB = 1}
		let resM = typeof mozRTCPeerConnection
		let boolM = "function" === typeof mozRTCPeerConnection
		if (!boolM && isFF && "undefined" === resM) {
			// TB/PM build without WebRTC
			if (isEngine == "goanna" || isTB) {
				boolM = zNA
				resM = zNA +": "+ (isTB ? "Tor Browser" : "Palemoon") + s3 +" ["+ resM +"]"+ sc
			} else {
				// behind a pref: media.peerconnection.enabled
				boolM = zNA
				resM = zNA + s3 +" ["+ resM +"]"+ sc + sb +" [not firefox default]"+ sc
			}
		}
		let perfM = canPerf ? performance.now() - t0M : ""
		fnRecord(num+1, strM, resM, boolM, "skip", perfM)
	} catch(e) {
		fnRecord(num+1, strM, e.name, zErr, e.message)
	}

	let strA = "[mozInnerScreenX] window", boolA = false
	try {
		let t0A; if (canPerf) {t0A = performance.now()}
		if (bBlock) {bB = 1}
		let resA = window.mozInnerScreenX
		if (!isNaN(resA)) {boolA = true} else {resA = fnClean(resA)}
		let perfA = canPerf ? performance.now() - t0A : ""
		fnRecord(num+2, strA, resA, boolA, "skip", perfA)
	} catch(e) {
		fnRecord(num+2, strA, e.name, zErr, e.message)
	}
	let strB = "[mozInnerScreenY] window", boolB = false
	try {
		let t0B; if (canPerf) {t0B = performance.now()}
		if (bBlock) {bB = 1}
		let resB = window.mozInnerScreenY
		if (!isNaN(resB)) {boolB = true} else {resB = fnClean(resB)}
		let perfB = canPerf ? performance.now() - t0B : ""
		fnRecord(num+3, strB, resB, boolB, "skip", perfB)
	} catch(e) {
		fnRecord(num+3, strB, e.name, zErr, e.message)
	}
}

function get_window_props(num1, num2, title) {
	// conservative small subset of items from engineprops PoC
	function rec(type, value, name) {
		if (value !== "undefined") {
			if (type == num1) {resE.push(name)} else {resU.push(name)}
		}
	}

	// expected
	let t0E; if (canPerf) {t0E = performance.now()}
	let resE = []
	try {
		if (bBlock) {bB = 1}
		// enuemrate
		rec(num1, typeof KeyEvent, "KeyEvent")
		rec(num1, typeof dump, "dump")
		rec(num1, typeof fullScreen, "fullScreen")
		rec(num1, typeof getDefaultComputedStyle, "getDefaultComputedStyle")
		rec(num1, typeof mozInnerScreenX, "mozInnerScreenX")
		rec(num1, typeof mozInnerScreenY, "mozInnerScreenY")
		rec(num1, typeof onabsolutedeviceorientation, "onabsolutedeviceorientation")
		rec(num1, typeof onbeforeinput, "onbeforeinput")
		//rec(num1, typeof ongamepadconnected, "ongamepadconnected") // risky? IDHave any gamepads
		//rec(num1, typeof ongamepaddisconnected, "ongamepaddisconnected")
		//rec(num1, typeof onloadend, "onloadend") // risky?
		rec(num1, typeof onmozfullscreenchange, "onmozfullscreenchange")
		rec(num1, typeof onmozfullscreenerror, "onmozfullscreenerror")
		rec(num1, typeof scrollByLines, "scrollByLines")
		rec(num1, typeof scrollByPages, "scrollByPages")
		rec(num1, typeof scrollMaxX, "scrollMaxX")
		rec(num1, typeof scrollMaxY, "scrollMaxY")
		rec(num1, typeof setResizable, "setResizable")
		rec(num1, typeof sizeToContent, "sizeToContent")
		rec(num1, typeof u2f, "u2f")
		rec(num1, typeof updateCommands, "updateCommands")
		// finish
		let boolE = resE.length > 0
		let hashE = boolE ? mini_sha1(resE.join()) : "none"
		if (boolE) {
			if (resE.join(", ").length < 48) {
				hashE = resE.join(", ")
			} else {
				sDetail["expected_"+ title] = resE
				hashE += buildButton(3, "expected_"+ title, resE.length)
			}
		}
		let perfE = canPerf ? performance.now() - t0E : ""
		fnRecord(num1, title, hashE, boolE, "skip", perfE)
	} catch(e) {
		fnRecord(num1, title, e.name, zErr, e.message)
	}

	// unexpected
	let t0U; if (canPerf) {t0U = performance.now()}
	let resU = []
	try {
		if (bBlock) {bB = 1}
		// enumerate
			// webkit only
		rec(num2, typeof browser, "browser")
		rec(num2, typeof getMatchedCSSRules, "getMatchedCSSRules")
		rec(num2, typeof safari, "safari")
		rec(num2, typeof showModalDialog, "showModalDialog")
		rec(num2, typeof webkitCancelRequestAnimationFrame, "webkitCancelRequestAnimationFrame")
		rec(num2, typeof webkitConvertPointFromNodeToPage, "webkitConvertPointFromNodeToPage")
		rec(num2, typeof webkitConvertPointFromPageToNode, "webkitConvertPointFromPageToNode")
		rec(num2, typeof webkitIndexedDB, "webkitIndexedDB")
			// gecko only
		rec(num2, typeof Keyboard, "Keyboard")
		rec(num2, typeof KeyboardLayoutMap, "KeyboardLayoutMap")
		rec(num2, typeof PERSISTENT, "PERSISTENT")
		rec(num2, typeof TEMPORARY, "TEMPORARY")
		rec(num2, typeof chrome, "chrome")
		rec(num2, typeof cookieStore, "cookieStore")
		rec(num2, typeof getScreenDetails, "getScreenDetails")
		rec(num2, typeof launchQueue, "launchQueue")
		rec(num2, typeof navigation, "navigation")
		rec(num2, typeof offscreenBuffering, "offscreenBuffering")
		rec(num2, typeof onappinstalled, "onappinstalled")
		rec(num2, typeof onbeforeinstallprompt, "onbeforeinstallprompt")
		rec(num2, typeof onbeforematch, "onbeforematch")
		rec(num2, typeof onbeforexrselect, "onbeforexrselect")
		rec(num2, typeof oncontextlost, "oncontextlost")
		rec(num2, typeof oncontextrestored, "oncontextrestored")
		rec(num2, typeof ondeviceorientationabsolute, "ondeviceorientationabsolute")
		rec(num2, typeof onsearch, "onsearch")
		rec(num2, typeof openDatabase, "openDatabase")
		rec(num2, typeof opr, "opr") // OPERA desktop at least
		rec(num2, typeof originAgentCluster, "originAgentCluster")
		rec(num2, typeof queryLocalFonts, "queryLocalFonts")
		rec(num2, typeof showDirectoryPicker, "showDirectoryPicker")
		rec(num2, typeof showOpenFilePicker, "showOpenFilePicker")
		rec(num2, typeof showSaveFilePicker, "showSaveFilePicker")
		rec(num2, typeof trustedTypes, "trustedTypes")
		rec(num2, typeof webkitRequestFileSystem, "webkitRequestFileSystem")
		rec(num2, typeof webkitResolveLocalFileSystemURL, "webkitResolveLocalFileSystemURL")
		rec(num2, typeof webkitStorageInfo, "webkitStorageInfo")

		// finish
		let boolU = resU.length == 0
		let hashU = !boolU ? mini_sha1(resU.join()) : "none"
		if (!boolU) {
			if (resU.join(", ").length < 48) {
				hashU = resU.join(", ")
			} else {
				sDetail["unexpected_"+ title] = resU
				hashU += buildButton(3, "unexpected_"+ title, resU.length)
			}
		}
		let perfU = canPerf ? performance.now() - t0U : ""
		fnRecord(num2, title, hashU, boolU, "skip", perfU)
	} catch(e) {
		fnRecord(num2, title, e.name, zErr, e.message)
	}

}

function rerun() {
	// reset
	results = []
	itemnumbers = [],
	data = {},
	aPerf = [],
	count = 0,
	dom.perf = ""
	dom.results = ""
	// do it: delay for user to see visual change
	setTimeout(function() {
		run()
	}, 120)
}

function run() {
	// now get on with it
	fnRecord(0, "header", "expected")
	fnRecord(300, "header", "not expected")
	fnRecord(600, "header", "specific values")
	fnRecord(899, "hr")
	fnRecord(900, "header", "errors")
	// OK, let's kick some ass
	// stagger to get more accurate perf

	setTimeout(function() {
		if (canPerf) {gt0 = performance.now()}
		aPerf.push(["START 1", gt0])
		get_installtrigger(50) // 50-52
		get_eval_length(630, "eval.toString().length")
		get_colorgamut(310, "[css] color-gamut")
		get_nav_screen(170)
		get_window_props(260, 450, "[properties] window")
		get_obj_enumeration(734, "object enumeration")
		get_last_prototype_keys(640, "[last x keys]") // 640+641
		get_math(695, "math")
		get_nav_values(150, 400, 720) // 100 expected, 400-410 not expected, 720.. specific
		get_dates(620)
		get_js_client_hints(320, "[js] client hints")
		get_mimetypes(710, "mimetypes")
		get_plugins(740, "plugins")
		get_media_constraints(700, "[constraints] mediaDevices")
	}, 1)

	setTimeout(function() {
		aPerf.push(["START 2", performance.now(), performance.now() - gt0])
		get_moz_objects(88, "CanvasRenderingContext2D")
		get_moz_objects(94, "CSS2Properties")
		get_moz_objects(96, "DataTransfer")
		get_moz_objects(98, "Document")
		get_moz_objects(100, "Element")
		get_moz_objects(106, "HTMLElement")
		get_moz_objects(108, "HTMLCanvasElement")
		get_moz_objects(110, "HTMLInputElement")
		get_moz_objects(112, "HTMLMediaElement")
		get_moz_objects(114, "HTMLVideoElement")
		get_moz_objects(116, "IDBIndex")
		get_moz_objects(118, "IDBObjectStore")
		get_moz_objects(120, "MathMLElement") // added in FF71
		get_moz_objects(122, "MouseEvent")
		get_moz_objects(126, "Navigator")
			// ^media.peerconnection.enabled + media.navigator.enabled = false negative
		get_moz_objects(128, "OfflineResourceList")
			// ^pref: browser.cache.offline.enable [pref exists since Jesus]
			// nightly/beta/dev default off - since when? FF71+ 1237782 ?
		get_moz_objects(130, "Screen")
		get_moz_objects(132, "ShadowRoot") // added in FF63
		get_moz_objects(134, "SVGElement")
		get_moz_objects(136, "XMLHttpRequest")
	}, 1)

	setTimeout(function() {
		aPerf.push(["START 3", performance.now(), performance.now() - gt0])
		get_window_moz(250) // 250-253
		get_nav_keys(85, 350, "[navigator] keys") // 85 expected, 350 not expected
		get_intl_supportedlocales(655) // +5's: C, DTF, DN, LF, NF, PR, RTF
		get_intl_canonical_locale(667, "Intl.getCanonicalLocales")
		get_locale_compare(692, "locale.compare")
	}, 1)

	setTimeout(function() {
		aPerf.push(["START 4", performance.now(), performance.now() - gt0])
		get_moz_colors(90, "[colors] moz")
		get_moz_fonts(102, "[fonts] moz")
		get_errors(902)
		get_stacklength(30,800,901) // 30-32 error properties, 800 = stack length, 901 = first error message
	}, 1)

	setTimeout(function() {
		aPerf.push(["START THE END", performance.now(), performance.now() - gt0])
		get_iframe_props(40, 330, "[properties] iframe") // 40 expected, 330 not expected,
	}, 1)
	setTimeout(function() {
		get_permission(750, "[permissions] push")
		get_storage_estimate(820, "storage estimate")
	}, 1)

}

setTimeout(function() {
	Promise.all([
		get_globals()
	]).then(function(){
		Promise.all([
			get_isRFP(),
			get_is95(),
			get_isTB(),
			get_isVer(),
		]).then(function(){
			run()
		})
	})
}, 50)

</script>
</body>
</html>
