<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>pluralrules</title>
<style>
</style>
</head>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=800">
	<title>pluralrules</title>
	<link rel="stylesheet" type="text/css" href="testindex.css">
	<script src="testglobals.js"></script>
	<script src="testgeneric.js"></script>
	<!-- custom -->
	<style>
		table {width: 780px;}
		hr {color: #dcdc8c}
	</style>
</head>
<body>

	<table>
	<tr><td><h2>TorZillaPrint</h2></td></tr>
	<tr><td class="blurb"><a class="return" href="../index.html">return to TZP index</a></td></tr>
	</table>

	<table id="tb4">
		<col width="30%"><col width="70%">
		<thead><tr><th colspan="2">pluralrules</th></tr></thead>
		<tr><td colspan="2" class="intro">
			<span class="no_color">A proof to confirm the minimum set of numbers to return maximum entropy in Intl.pluralRules</span>
		</td></tr>
		<tr>
			<td class="mono spaces" id="legend" style="text-align: left; vertical-align: top; color: #b3b3b3; font-size: 11px"></td>
			<td class="mono" style="text-align: left; vertical-align: top;">
				<div id="button" class="btn"><span class="btn4 btn" onClick="run()">[ run ]</span></div>
				<span class="spaces" id="perf0"></span><span id="perf2"></span><span id="perf1"></span>
				<br><span class="spaces" id="numbers1"></span>
				<br><span class="spaces" id="results1"></span>
				<br><span class="spaces" id="numbers2"></span>
				<br><span class="spaces" id="results2"></span>
				<br><span class="spaces" id="numbers0"></span>
				<br><span class="spaces" id="results0"></span>
			</td></tr>
	</table>
	<br>

<script>
var locales = [],
	list = [],
	list_one = [], // first change of each result
	list_all = [], // all numbers that changed
	main_count = 0,
	main_result = "",
	main_code = ""

function start() {
	// builds locales array and outputs a legend
let detailed = [
"aa,afar",
"ab,abkhazian",
"ach,acholi",
"ae,avestan",
"af,afrikaans",
"ak,akan",
"am,amharic",
"an,aragonese",
"ar,arabic",
"as,assamese",
"ast,asturian",
"av,avaric",
"ay,aymara",
"az,azerbaijani",
"ba,bashkir",
"be,belarusian",
"bg,bulgarian",
"bh,bihari",
"bi,bislama",
"bm,bambara",
"bn,bengali",
"bo,tibetan",
"br,breton",
"bs,bosnian",
"ca,catalan",
"cak,kaqchikel",
"ce,chechen",
"ch,chamorro",
"ckb,central kurdish", // ? dropped
"co,corsican",
"cr,cree",
"crh,crimean tatar",
"cs,czech",
"csb,kashubian",
"cu,church slavic",
"cv,chuvash",
"cy,welsh",
"da,danish",
"de,german",
"dsb,lower sorbian",
"dv,divehi",
"dz,dzongkha",
"ee,ewe",
"el,greek",
"en,english",
"eo,esperanto",
"es,spanish",
"et,estonian",
"eu,basque",
"fa,persian",
"ff,fulah",
"fi,finnish",
"fj,fijian",
"fo,faroese",
"fr,french",
"fur,friulian",
"fy,frisian",
"ga,irish",
"gd,scottish gaelic",
"gl,galician",
"gn,guarani",
"gu,gujarati",
"gv,manx",
"ha,hausa",
"haw,hawaiian",
"he,hebrew",
"hi,hindi",
"hil,hiligaynon",
"ho,hiri motu",
"hr,croatian",
"hsb,upper sorbian",
"ht,haitian",
"hu,hungarian",
"hy,armenian",
"hye,eastern armenian", // ? dropped
"hz,herero",
"ia,interlingua",
"id,indonesian",
"ie,interlingue",
"ig,igbo",
"ii,sichuan yi",
"ik,inupiaq",
"io,ido",
"is,icelandic",
"it,italian",
"iu,inuktitut",
"ja,japanese",
"jv,javanese",
"ka,georgian",
"kab,kabyle",
"kg,kongo",
"ki,kikuyu",
"kj,kuanyama",
"kk,kazakh",
"kl,greenlandic",
"km,khmer",
"kn,kannada",
"ko,korean",
"kok,konkani",
"kr,kanuri",
"ks,kashmiri",
"ku,kurdish",
"kv,komi",
"kw,cornish",
"ky,kirghiz",
"la,latin",
"lb,luxembourgish",
"lg,ganda",
"li,limburgan",
"lij,ligurian",
"ln,lingala",
"lo,lao",
"lt,lithuanian",
"ltg,latgalian",
"lu,luba-katanga",
"lv,latvian",
"mai,maithili",
"meh,sw tlaxiaco mixtec",
"mg,malagasy",
"mh,marshallese",
"mi,maori",
"mix,mixtepec mixtec",
"mk,macedonian",
"ml,malayalam",
"mn,mongolian",
"mr,marathi",
"ms,malay",
"mt,maltese",
"my,burmese",
"na,nauru",
"nb,norwegian bokmål",
"nd,ndebele north",
"ne,nepali",
"ng,ndonga",
"nl,dutch",
"nn,norwegian nynorsk",
"no,norwegian",
"nr,ndebele south",
"nso,sotho northern",
"nv,navajo",
"ny,chichewa",
"oc,occitan",
"oj,ojibwa",
"om,oromo",
"or,odia",
"os,ossetian",
"pa,punjabi",
"pi,pali",
"pl,polish",
"ps,pashto",
"pt,portuguese",
"qu,quechua",
"rm,rhaeto-romanic",
"rn,kirundi",
"ro,romanian",
"ru,russian",
"rw,kinyarwanda",
"sa,sanskrit",
"sc,sardinian",
"sco,scots", // 1714293
"sd,sindhi",
"se,northern sami",
"sg,sango",
"si,singhalese",
"sk,slovak",
"sl,slovenian",
"sm,samoan",
"sn,shona",
"so,somali",
"son,songhay",
"sq,albanian",
"sr,serbian",
"ss,siswati",
"st,sotho southern",
"su,sundanese",
"sv,swedish",
"sw,swahili",
"szl,silesian", // 1691695
"ta,tamil",
"te,telugu",
"tg,tajik",
"th,thai",
"ti,tigrinya",
"tig,tigre",
"tk,turkmen",
"tl,tagalog",
"tlh,klingon",
"tn,tswana",
"to,tonga",
"tr,turkish",
"trs,triqui", // 1583177
"ts,tsonga",
"tt,tatar",
"tw,twi",
"ty,tahitian",
"ug,uighur",
"uk,ukrainian",
"ur,urdu",
"uz,uzbek",
"ve,venda",
"vi,vietnamese",
"vo,volapük",
"wa,walloon",
"wen,sorbian",
"wo,wolof",
"xh,xhosa",
"yi,yiddish",
"yo,yoruba",
"za,zhuang",
"zam,miahuatlán zapotec",
"zh,chinese",
"zh-cn,chinese china",
"zh-Hans,chinese simple",
"zh-Hant,chinese traditional",
"zh-hk,chinese hong kong",
"zh-sg,chinese singapore",
"zh-tw,chinese taiwan",
"zu,zulu",
]
detailed.sort()

	try {
		let legend = []
		for (let i = 0 ; i < detailed.length; i++) {
			// split: A (code), B (name)
			let listA = detailed[i].split(",")[0]
			let listB = detailed[i].split(",")[1]
			locales.push(listA)
			legend.push(listA.padStart(7) +": "+ listB)
		}
		dom.legend.innerHTML = s4 +"   LEGEND ("+ locales.length +")"+ sc +"<br><br>"+ legend.join("<br>")
	} catch(e) {}
}

function run_test(type) {
	// vars
	let t0 = performance.now()
	let test_array = [],
		tmp_res = [], // result per locale
		test_all = [], // result hash + locale code + result
		go = true,
		perfname = "all"
		str = "",
		sColor = s12.trim()

	let	element = document.getElementById("results" + type)
	let	elperf = document.getElementById("perf" + type)

	// main test
	if (type == "0") {
		// reset
		list = []
		list_one = []
		list_all = []
		main_count = 0,
		main_reshash = "",
		main_codehash = ""
		// build
		for (let i=0; i < 101; i++) {list.push(i)}

		// temp smaller tests
		//list = [0,1,2,3,4,6,7,11,20,21,100]
		//list = [1,2,3,4,5,25,134,910293019,12,1412,15,2931,31231,3123,13231,91,0,231,33,728,2,291,24,479,291,778,919,93]
		//locales = ['ar','br','bs','cs','cy','en','fr','ga','gd','gv','he','is','kw','lt','lv','mt','pl','ro','ru','sl','zh',]
		//locales = ['ar','bo','bn','dz','en','fa','fi','gd','he','kw','ku','lv','sl','ss',]

		test_array = list
	}
	// subsequent tests
	if (list.length == 0) {
		go = false
		console.debug("ABORTED: run the main test first")
	}

	if (go) {
		// always sort the array
		test_array.sort((a,b) => a-b)

		// subsequent tests
		if (type == "1") {
			test_array = list_one
			perfname = "first changes only"
		} else if (type == "2") {
			test_array = list_all
			perfname = "changes only"
		}

		// for each locale
	for (let j=0; j < locales.length; j++) {
			// reset
			let prev = "", current = "", tmp_result = []
			f0 = true, f1 = true, f2 = true, f3 = true, f4 = true, f5 = true
			let code = locales[j]

			// list
			for (let k=0; k < test_array.length; k++) {
				let n = test_array[k]
				try {
					current = new Intl.PluralRules(code).select(n)
					if (type == "0") {
						// catch first
						if (f0 && current == "zero") {f0 = false; list_one.push(n);}
						if (f1 && current == "one") {f1 = false; list_one.push(n);}
						if (f2 && current == "two") {f2 = false; list_one.push(n);}
						if (f3 && current == "few") {f3 = false; list_one.push(n);}
						if (f4 && current == "many") {f4 = false; list_one.push(n);}
						if (f5 && current == "other") {f5 = false; list_one.push(n);}
					}
				} catch(e) {
					current = "error"
				}
				// record all changes
				if (prev !== current) {
					tmp_result.push(n +": "+ current)
					// main test, record all numbers that change
					if (type == "0") {
						list_all.push(n)
					}
				}
				prev = current
			}
			// array: hash + code + result
			let tmpR = tmp_result.join(", ")
			let tmpH = sha1(tmpR)
			test_all.push(sha1(tmp_result.join()) +"~"+ code +"~"+ tmpR)
		}

		// set things in main test for subsequent tests
		if (type == "0") {
			// first changes
			list_one = list_one.filter(function(item, position) {return list_one.indexOf(item) === position})
			list_one.sort((a,b) => a-b)
			// all changes
			list_all = list_all.filter(function(item, position) {return list_all.indexOf(item) === position})
			list_all.sort((a,b) => a-b)
		} else if ( type == "1") {
			dom.numbers1.innerHTML = "<hr><br>" + s4.trim() + perfname.toUpperCase() +" ("
				+ list_one.length +")"+ sc +"<br><br>"+ list_one.join(", ")
		} else {
			dom.numbers2.innerHTML = "<hr><br>" + s4.trim() + perfname.toUpperCase() +" ("
				+ list_all.length +")"+ sc +"<br><br>"+ list_all.join(", ")
		}
		// perf
		let perf = perfname +" "+ s4.trim() + Math.round(performance.now()-t0) + sc +" ms"
		elperf.innerHTML = (type == "0" ? s4.trim() +"PERF: "+ sc : " | ") + perf
			+ (type == "1" ? "<br>" : "")

		// sort array & loop: get hash + code + result buckets, and code_total
		test_all.sort()
		let bucket_hash = [], bucket_code = [], bucket_res = []
		let tmp_code = [], nextHash = "", code_total = 0

		for (let i=0; i < test_all.length; i++) {
			let part1 = test_all[i].split("~")[0],
				part2 = test_all[i].split("~")[1],
				part3 = test_all[i].split("~")[2]
			// build code string
			tmp_code.push(part2)
			// grab next item
			if (i < test_all.length - 1) {
				nextHash = test_all[(i+1)].split("~")[0]
			} else {
				nextHash = "end"
			}
			// next hash is diff: write data
			if (nextHash !== part1) {
				bucket_hash.push(part1 + s4 +"("+ tmp_code.length +")"+ sc)
				bucket_res.push(part3)
				bucket_code.push(tmp_code.join(", "))
				code_total += tmp_code.length
				tmp_code = [] // reset tmp_code
			}
		}

		// main
		if (type == "0") {
			// build pretty BEFORE sorting
			let pretty = []
			for (let i=0; i < bucket_hash.length; i++) {
				let part1 = s4 +"hash: "+ sc + bucket_hash[i]
				let part2 = "<ul><li>" + sColor +"result: "+ sc + bucket_res[i] +"</li>"
				let part3 = "<li>" + sColor +"locale: "+ sc + bucket_code[i] +"</li></ul>"
				pretty.push(part1 + part2 + part3)
			}
			// sort and set globals
			main_count = bucket_hash.length
			bucket_res.sort()
			main_result = sha1(bucket_res.join())
			bucket_code.sort()
			main_code = sha1(bucket_code.join())
			// output
			str = code_total + (code_total == locales.length ? sg : sb) +"[match]"+ sc
			str = "<hr><br>"+ s4.trim() +"ALL NUMBERS ("+ list.length +")"+ sc +"<br>"
				+"<ul><li>"+ sColor +"unique hashes: "+ sc + main_count +"</li>"
				+"<li>"+ sColor +" results hash: "+ sc + main_result +"</li>"
				+"<li>"+ sColor +" locales hash: "+ sc + main_code +"</li>"
				+"<li>"+ sColor +" locale check: "+ sc + str +"</li></ul>"
			dom.numbers0.innerHTML = str
			element.innerHTML = pretty.join("")

		} else {
			// set vars to compare to main
			let check_count = bucket_hash.length
			bucket_res.sort()
			let check_result = sha1(bucket_res.join())
			bucket_code.sort()
			let check_code = sha1(bucket_code.join())
			// append results
			let matchbad = sb +"[match]"+ sc, matchgood = sg +"[match]"+ sc
			str = "<ul><li>" + sColor +"unique hashes:"+ sc
			str += " "+ check_count + (check_count == main_count ? matchgood : matchbad)
			if (type == "2") {
				str += "</li><li>"+ sColor +" results hash: "+ sc + check_result + (check_result == main_result ? matchgood : matchbad)
			} else {
				// we know the results hash changes: that's not what we testing for
				str += "</li><li>"+ sColor +" results hash: "+ sc + check_result
			}
			str += "</li><li>"+ sColor +" locales hash: "+ sc + check_code + (check_code == main_code ? matchgood : matchbad)
			str += "</li></ul>"
			element.innerHTML = str
		}
	}
}

function run() {
	dom.button.remove()
	run_test("0") // main test
	run_test("1")
	run_test("2")
}

start()

</script>
</body>
</html>
