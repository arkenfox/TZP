<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>pluralrules</title>
<style>
</style>
</head>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=800">
	<title>pluralrules</title>
	<link rel="stylesheet" type="text/css" href="testindex.css">
	<script src="testglobals.js"></script>
	<script src="testgeneric.js"></script>
	<!-- custom -->
	<style>
		table {width: 780px;}
		hr {color: #dcdc8c}
	</style>
</head>
<body>

	<table>
	<tr><td><h2>TorZillaPrint</h2></td></tr>
	<tr><td class="blurb"><a class="return" href="../index.html">return to TZP index</a></td></tr>
	</table>

	<table id="tb4">
		<col width="30%"><col width="70%">
		<thead><tr><th colspan="2">
			<div class="nav-title">pluralrules
			<div class="nav-up"><span class="c perf" id="perf"></span></div>
			</div>
		</th></tr></thead>
		<tr><td colspan="2" class="intro">
			<span class="no_color">A proof to confirm the minimum set of numbers to return maximum entropy in Intl.pluralRules</span>
		</td></tr>
		<tr>
			<td class="mono spaces" id="legend" style="text-align: left; vertical-align: top; color: #b3b3b3; font-size: 11px"></td>
			<td class="mono" style="text-align: left; vertical-align: top;">
				<span class="btn4 btnfirst" onClick="run()">[ run ]</span>
				<span class="btn4 btn"><input type="checkbox" id="supported" style="margin: 0; height: 12px"> supported [pluralrules]</span>
				<br><br><hr>
				<br><span class="spaces" id="numbers1"></span>
				<br><span class="spaces" id="results1"></span>
				<br><span class="spaces" id="numbers0"></span>
				<br><span class="spaces" id="results0"></span>
			</td></tr>
	</table>
	<br>

<script>
'use strict';

var list = [
"aa,afar",
"ab,abkhazian",
"ach,acholi",
"ae,avestan",
"af,afrikaans",
"ak,akan",
"am,amharic",
"an,aragonese",
"ar,arabic",
"as,assamese",
"ast,asturian",
"av,avaric",
"ay,aymara",
"az,azerbaijani",
"ba,bashkir",
"be,belarusian",
"bg,bulgarian",
"bh,bihari",
"bi,bislama",
"bm,bambara",
"bn,bengali",
"bo,tibetan",
"br,breton",
"bs,bosnian",
"ca,catalan",
"cak,kaqchikel",
"ce,chechen",
"ch,chamorro",
"ckb,central kurdish",
"co,corsican",
"cr,cree",
"crh,crimean tatar",
"cs,czech",
"csb,kashubian",
"cu,church slavic",
"cv,chuvash",
"cy,welsh",
"da,danish",
"de,german",
"dsb,lower sorbian",
"dv,divehi",
"dz,dzongkha",
"ee,ewe",
"el,greek",
"en,english",
"eo,esperanto",
"es,spanish",
"et,estonian",
"eu,basque",
"fa,persian",
"ff,fulah",
"fi,finnish",
"fj,fijian",
"fo,faroese",
"fr,french",
"fur,friulian",
"fy,frisian",
"ga,irish",
"gd,scottish gaelic",
"gl,galician",
"gn,guarani",
"gu,gujarati",
"gv,manx",
"ha,hausa",
"haw,hawaiian",
"he,hebrew",
"hi,hindi",
"hil,hiligaynon",
"ho,hiri motu",
"hr,croatian",
"hsb,upper sorbian",
"ht,haitian",
"hu,hungarian",
"hy,armenian",
"hye,eastern armenian",
"hz,herero",
"ia,interlingua",
"id,indonesian",
"ie,interlingue",
"ig,igbo",
"ii,sichuan yi",
"ik,inupiaq",
"io,ido",
"is,icelandic",
"it,italian",
"iu,inuktitut",
"ja,japanese",
"jv,javanese",
"ka,georgian",
"kab,kabyle",
"kg,kongo",
"ki,kikuyu",
"kj,kuanyama",
"kk,kazakh",
"kl,greenlandic",
"km,khmer",
"kn,kannada",
"ko,korean",
"kok,konkani",
"kr,kanuri",
"ks,kashmiri",
"ku,kurdish",
"kv,komi",
"kw,cornish",
"ky,kirghiz",
"la,latin",
"lb,luxembourgish",
"lg,ganda",
"li,limburgan",
"lij,ligurian",
"ln,lingala",
"lo,lao",
"lt,lithuanian",
"ltg,latgalian",
"lu,luba-katanga",
"lv,latvian",
"mai,maithili",
"meh,sw tlaxiaco mixtec",
"mg,malagasy",
"mh,marshallese",
"mi,maori",
"mix,mixtepec mixtec",
"mk,macedonian",
"ml,malayalam",
"mn,mongolian",
"mr,marathi",
"ms,malay",
"mt,maltese",
"my,burmese",
"na,nauru",
"nb,norwegian bokmål",
"nd,ndebele north",
"ne,nepali",
"ng,ndonga",
"nl,dutch",
"nn,norwegian nynorsk",
"no,norwegian",
"nr,ndebele south",
"nso,sotho northern",
"nv,navajo",
"ny,chichewa",
"oc,occitan",
"oj,ojibwa",
"om,oromo",
"or,odia",
"os,ossetian",
"pa,punjabi",
"pi,pali",
"pl,polish",
"ps,pashto",
"pt,portuguese",
"qu,quechua",
"rm,rhaeto-romanic",
"rn,kirundi",
"ro,romanian",
"ru,russian",
"rw,kinyarwanda",
"sa,sanskrit",
"sat,santali", // 1731528
"sc,sardinian",
"sco,scots", // 1714293
"sd,sindhi",
"se,northern sami",
"sg,sango",
"si,sinhala",
"sk,slovak",
"sl,slovenian",
"sm,samoan",
"sn,shona",
"so,somali",
"son,songhay",
"sq,albanian",
"sr,serbian",
"ss,siswati",
"st,sotho southern",
"su,sundanese",
"sv,swedish",
"sw,swahili",
"szl,silesian", // 1691695
"ta,tamil",
"te,telugu",
"tg,tajik",
"th,thai",
"ti,tigrinya",
"tig,tigre",
"tk,turkmen",
"tl,tagalog",
"tlh,klingon",
"tn,tswana",
"to,tonga",
"tr,turkish",
"trs,triqui", // 1583177
"ts,tsonga",
"tt,tatar",
"tw,twi",
"ty,tahitian",
"ug,uighur",
"uk,ukrainian",
"ur,urdu",
"uz,uzbek",
"ve,venda",
"vi,vietnamese",
"vo,volapük",
"wa,walloon",
"wen,sorbian",
"wo,wolof",
"xh,xhosa",
"yi,yiddish",
"yo,yoruba",
"za,zhuang",
"zam,miahuatlán zapotec",
"zh,chinese",
"zh-cn,chinese china",
"zh-Hans,chinese simple",
"zh-Hant,chinese traditional",
"zh-hk,chinese hong kong",
"zh-sg,chinese singapore",
"zh-tw,chinese taiwan",
"zu,zulu",
]

var aLegend = [],
	aLegendSupported = [],
	aLocales = [],
	aSupported = [],
	aListOne = [], // 1st run
	aListTwo = [], // 2nd run
	main_buckets = [],
	useSupportedOnly = true,
	isDebug = false,
	debug0 = [],
	debug1 = [],
	perf = ""

s4 = s4.trim()
s12 = s12.trim()
s14 = s14.trim()
s16 = s16.trim()
sg = sg.trim()
sb = sb.trim()

function legend() {
	// builds locales array and outputs a legend
	// build once
	if (aLegend.length == 0) {
		list.sort()
		for (let i = 0 ; i < list.length; i++) {
			let str = list[i].toLowerCase()
			let code = str.split(",")[0].trim()
			let name = str.split(",")[1].trim()
			aLocales.push(code)
			let test = Intl.PluralRules.supportedLocalesOf([code])
			if (test.length) {
				aSupported.push(code)
				aLegendSupported.push(code.padStart(7) +": "+ name)
			}
			aLegend.push(code.padStart(7) +": "+ name)
		}
	}
	// output
	useSupportedOnly = dom.supported.checked
	let aDisplay = aLegend
	if (useSupportedOnly) {aDisplay = aLegendSupported}
	let	header = s4 +"   LEGEND ["+ aDisplay.length
		+ (useSupportedOnly ? " supported" : "") +"]"+ sc +"<br><br>"
	dom.legend.innerHTML = header + aDisplay.join("<br>")
}

function run_test(type) {

	// vars
	let t0 = performance.now()
	let test_array = [], // numbers used
		test_all = [], // result hash + locale code + result
		go = true,
		perfname = "all",
		str = ""

	let	element = document.getElementById("results" + type)
	let	elperf = document.getElementById("perf" + type)

	// main test
	if (type == "0") {
		// reset
		aListOne = []
		aListTwo = []
		main_buckets = []
		// build
		for (let i=0; i < 101; i++) {aListOne.push(i)}
		// temp smaller tests
		//aListOne = [0,1,2,3,4,6,7,11,20,21,100]
		//aListOne = [1,2,3,4,5,25,134,910293019,12,1412,15,2931,31231,3123,13231,91,0,231,33,728,2,291,24,479,291,778,919,93]
		//aLocales = ['ar','br','bs','cs','cy','en','fr','ga','gd','gv','he','is','kw','lt','lv','mt','pl','ro','ru','sl','zh',]
		//aLocales = ['ar','bo','bn','dz','en','fa','fi','gd','he','kw','ku','lv','se','sl','ss',]
		test_array = aListOne
	}

	// subsequent tests
	if (aListOne.length == 0) {
		go = false
		dom.numbers1.innerHTML = sb +"ABORTED: "+ sc + "run the main test first"
	}

	if (go) {
		// small test
		if (type == "1") {
			test_array = aListTwo
			if (isEngine == "blink") {
				test_array.push(81) // chromium to keep lij unique from it,sc in ordinal (bug?)
			}
			perfname = "first changes only"
		}
		// always sort the array
		test_array.sort((a,b) => a-b)

		useSupportedOnly = dom.supported.checked
		let loop = useSupportedOnly ? aSupported : aLocales

		// for each locale
		for (let j=0; j < loop.length; j++) {
			// reset cardinal
			let prevC = "", currentC = "", tmp_resultC = []
			let c0 = true, c1 = true, c2 = true, c3 = true, c4 = true, c5 = true
			// reset ordinal
			let prevO = "", currentO = "", tmp_resultO = []
			let o0 = true, o1 = true, o2 = true, o3 = true, o4 = true, o5 = true

			let code = loop[j]
			let intlPRcardinal = new Intl.PluralRules(code, {type:"cardinal"})
			let intlPRordinal = new Intl.PluralRules(code, {type:"ordinal"})
			// aListOne
			for (let k=0; k < test_array.length; k++) {
				let n = test_array[k]
				// cardinal
				try {
					currentC = intlPRcardinal.select(n)
					if (type == "0") {
						// catch first
						if (c0 && currentC == "zero") {c0 = false; aListTwo.push(n)}
						if (c1 && currentC == "one") {c1 = false; aListTwo.push(n)}
						if (c2 && currentC == "two") {c2 = false; aListTwo.push(n)}
						if (c3 && currentC == "few") {c3 = false; aListTwo.push(n)}
						if (c4 && currentC == "many") {c4 = false; aListTwo.push(n)}
						if (c5 && currentC == "other") {c5 = false; aListTwo.push(n)}
					}
				} catch(e) {
					currentC = "error"
				}
				// record all changes
				if (prevC !== currentC) {
					tmp_resultC.push(n +": "+ currentC)
				}
				prevC = currentC

				// ordinal
				try {
					currentO = intlPRordinal.select(n)
					if (type == "0") {
						// catch first
						if (o0 && currentO == "zero") {o0 = false; aListTwo.push(n)}
						if (o1 && currentO == "one") {o1 = false; aListTwo.push(n)}
						if (o2 && currentO == "two") {o2 = false; aListTwo.push(n)}
						if (o3 && currentO == "few") {o3 = false; aListTwo.push(n)}
						if (o4 && currentO == "many") {o4 = false; aListTwo.push(n)}
						if (o5 && currentO == "other") {o5 = false; aListTwo.push(n)}
					}
				} catch(e) {
					currentO = "error"
				}
				// record all changes
				if (prevO !== currentO) {
					tmp_resultO.push(n +": "+ currentO)
				}
				prevO = currentO
			}
			// array: hash-combined + code + resultC + resultO
			let strC = tmp_resultC.join(", ")
			let hashC = sha1(strC)
			let strO = tmp_resultO.join(", ")
			let hashO = sha1(strO)
			let hashCombined = sha1(hashC + hashO)
			test_all.push(hashCombined +"~"+ code +"~"+ strC +"~"+ strO)

			if (isDebug) { // example
				//if (code == "lij" || code == "it" || code == "sc") {
				if (code == "en") {
					if (type == "0") {
						debug0.push(code)
						debug0.push(hashC +":"+ strC)
						debug0.push(hashO +":"+ strO)
					} else {
						debug1.push(code)
						debug1.push(hashC +":"+ strC)
						debug1.push(hashO +":"+ strO)
					}
				}
			}
		}
		// set things in main test for small test
		if (type == "0") {
			// first changes
			aListTwo = aListTwo.filter(function(item, position) {return aListTwo.indexOf(item) === position})
			aListTwo.sort((a,b) => a-b)
		} else if( type == "1") {
			let blinkStr = isEngine == "blink" ? " [81 added for blink + lij]" : ""
			dom.numbers1.innerHTML = s4 + perfname.toUpperCase() +" ["
				+ aListTwo.length +"]"+ sc + blinkStr +"<br><br>"+ aListTwo.join(", ")
			if (isDebug) {
				console.debug("BIG test\n - " + debug0.join("\n - "))
				console.debug("SMALL test\n - " + debug1.join("\n - "))
			}
		}
		// perf
		if (type == 0) {
			perf = "all: "+ Math.round(performance.now()-t0)
		} else {
			dom.perf.innerHTML = perf +" | 1st: "+ Math.round(performance.now()-t0) +" ms"
		}

		// sort array & loop: get hash + code + result buckets, and code_total
		test_all.sort()
		let bucket_hash = [], bucket_code = [], bucket_resC = [], bucket_resO = []
		let tmp_code = [], nextHash = "", code_total = 0

		for (let i=0; i < test_all.length; i++) {
			let part1 = test_all[i].split("~")[0],
				part2 = test_all[i].split("~")[1],
				part3 = test_all[i].split("~")[2],
				part4 = test_all[i].split("~")[3]
			// build code string
			tmp_code.push(part2)
			// grab next item
			if (i < test_all.length - 1) {
				nextHash = test_all[(i+1)].split("~")[0]
			} else {
				nextHash = "end"
			}
			// next hash is diff: write data
			if (nextHash !== part1) {
				bucket_hash.push(part1 + s4 +" ["+ tmp_code.length +"]"+ sc)
				bucket_resC.push(part3)
				bucket_resO.push(part4)
				bucket_code.push(tmp_code.join(", "))
				code_total += tmp_code.length
				tmp_code = [] // reset tmp_code
			}
		}

		// main
		if (type == "0") {
			// build pretty BEFORE sorting
			let pretty = []
			for (let i=0; i < bucket_hash.length; i++) {
				let part1 = s4 +"hash: "+ sc + bucket_hash[i]
				let part2 = "<ul><li>" + s12 +"cardinal: "+ sc + bucket_resC[i] +"</li>"
				let part3 = "<li>" + s12 +"ordinal: "+ sc + bucket_resO[i] +"</li>"
				let part4 = "<li>" + s12 +"locale: "+ sc + bucket_code[i] +"</li></ul>"
				pretty.push(part1 + part2 + part3 + part4)
			}
			// remember main details
			main_buckets = bucket_code
			main_buckets.sort()
			// output
			str = code_total + (code_total == loop.length ? sg : sb) +" [match]"+ sc
			str = "<hr><br>"+ s4 +"ALL NUMBERS ["+ aListOne.length +"]"+ sc +"<br>"
				+"<ul><li>"+ s12 +"unique hashes: "+ sc + main_buckets.length +"</li>"
				+"<li>"+ s12 +" locales hash: "+ sc + sha1(main_buckets.join()) +"</li>"
				+"<li>"+ s12 +" locale check: "+ sc + str +"</li></ul>"
			dom.numbers0.innerHTML = str
			element.innerHTML = pretty.join("")
		} else {
			// set vars to compare to main
			bucket_code.sort()
			let check_count = bucket_code.length
			let check_hash = sha1(bucket_code.join())
			let main_hash = sha1(main_buckets.join())
			// append results
			let matchbad = sb +" [match]"+ sc, matchgood = sg +" [match]"+ sc
			str = "<ul><li>" + s12 +"unique hashes:"+ sc
			str += " "+ check_count + (check_count == main_buckets.length ? matchgood : matchbad)
			str += "</li><li>"+ s12 +" locales hash: "+ sc + check_hash + (check_hash == main_hash ? matchgood : matchbad)
			str += "</li></ul>"
			element.innerHTML = str
			if (check_hash !== main_hash) {
				console.debug("MISMATCH\n" + "101 TEST buckets\n", main_buckets, "SMALL TEST buckets\n", bucket_code)
			}
		}
	}
}

function run() {
	//isDebug = true
	perf = ""
	dom.perf = ""
	dom.numbers1 = "calculating..."
	dom.numbers0 = ""
	dom.results1 = ""
	dom.results0 = ""
	legend()
	// delay so users see change and allow paint
	setTimeout(function() {
		run_test("0") // main test
		run_test("1")
	}, 1)
}

dom.supported.checked = true
legend()
get_globals()

</script>
</body>
</html>
